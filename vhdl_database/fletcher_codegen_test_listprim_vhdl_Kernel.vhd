-- Copyright 2018-2019 Delft University of Technology
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- This file was generated by Fletchgen. Modify this file at your own risk.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.Axi_pkg.all;
use work.UtilStr_pkg.all;

entity Kernel is
  generic (
    INDEX_WIDTH : integer := 32;
    TAG_WIDTH   : integer := 1
  );
  port (
    kcd_clk              : in  std_logic;
    kcd_reset            : in  std_logic;
    src_vec_valid        : in  std_logic;
    src_vec_ready        : out std_logic;
    src_vec_dvalid       : in  std_logic;
    src_vec_last         : in  std_logic;
    src_vec_length       : in  std_logic_vector(31 downto 0);
    src_vec_count        : in  std_logic_vector(0 downto 0);
    src_vec_elem_valid   : in  std_logic;
    src_vec_elem_ready   : out std_logic;
    src_vec_elem_dvalid  : in  std_logic;
    src_vec_elem_last    : in  std_logic;
    src_vec_elem         : in  std_logic_vector(15 downto 0);
    src_vec_elem_count   : in  std_logic_vector(0 downto 0);
    src_vec_unl_valid    : in  std_logic;
    src_vec_unl_ready    : out std_logic;
    src_vec_unl_tag      : in  std_logic_vector(TAG_WIDTH-1 downto 0);
    src_vec_cmd_valid    : out std_logic;
    src_vec_cmd_ready    : in  std_logic;
    src_vec_cmd_firstIdx : out std_logic_vector(INDEX_WIDTH-1 downto 0);
    src_vec_cmd_lastIdx  : out std_logic_vector(INDEX_WIDTH-1 downto 0);
    src_vec_cmd_tag      : out std_logic_vector(TAG_WIDTH-1 downto 0);
    dst_vec_valid        : out std_logic;
    dst_vec_ready        : in  std_logic;
    dst_vec_dvalid       : out std_logic;
    dst_vec_last         : out std_logic;
    dst_vec_length       : out std_logic_vector(31 downto 0);
    dst_vec_count        : out std_logic_vector(0 downto 0);
    dst_vec_elem_valid   : out std_logic;
    dst_vec_elem_ready   : in  std_logic;
    dst_vec_elem_dvalid  : out std_logic;
    dst_vec_elem_last    : out std_logic;
    dst_vec_elem         : out std_logic_vector(15 downto 0);
    dst_vec_elem_count   : out std_logic_vector(0 downto 0);
    dst_vec_unl_valid    : in  std_logic;
    dst_vec_unl_ready    : out std_logic;
    dst_vec_unl_tag      : in  std_logic_vector(TAG_WIDTH-1 downto 0);
    dst_vec_cmd_valid    : out std_logic;
    dst_vec_cmd_ready    : in  std_logic;
    dst_vec_cmd_firstIdx : out std_logic_vector(INDEX_WIDTH-1 downto 0);
    dst_vec_cmd_lastIdx  : out std_logic_vector(INDEX_WIDTH-1 downto 0);
    dst_vec_cmd_tag      : out std_logic_vector(TAG_WIDTH-1 downto 0);
    start                : in  std_logic;
    stop                 : in  std_logic;
    reset                : in  std_logic;
    idle                 : out std_logic;
    busy                 : out std_logic;
    done                 : out std_logic;
    result               : out std_logic_vector(63 downto 0);
    src_firstidx         : in  std_logic_vector(31 downto 0);
    src_lastidx          : in  std_logic_vector(31 downto 0);
    dst_firstidx         : in  std_logic_vector(31 downto 0);
    dst_lastidx          : in  std_logic_vector(31 downto 0)
  );
end entity;

architecture Implementation of Kernel is
  constant ELEM_SIZE : integer := 16;

  procedure command(signal c            : in  std_logic;
                    signal r    		    : in  std_logic;
                    signal firstidx     : in  std_logic_vector(31 downto 0);
                    signal lastidx      : in  std_logic_vector(31 downto 0);
                    signal firstidx_out : out std_logic_vector(31 downto 0);
                    signal lastidx_out  : out std_logic_vector(31 downto 0);
                    signal valid		    : out std_logic;
                    signal ready        : in  std_logic)
  is begin
    firstidx_out <= firstidx;
    lastidx_out  <= lastidx;
    valid        <= '1';
    -- wait for acceptance
    loop
      wait until rising_edge(c);
      exit when ready = '1';
      exit when reset = '1';
    end loop;
    valid <= '0';
  end procedure;
begin
  process is
	variable vec_idx      : natural := 0;
    variable vec_length   : natural := 0;
    variable current_elem :  natural := 0;
    variable num_elems    : natural := 0;
    variable is_last      : boolean := false;
    variable int_elem     : integer := 0;
    variable elem         : character := '0';
  begin
    -- Initial outputs
    busy <= '0';
    done <= '0';
    idle <= '0';

    src_vec_cmd_valid <= '0';
    src_vec_ready <= '0';
    src_vec_elem_ready <= '0';
    src_vec_unl_ready <= '1';
    
    dst_vec_cmd_valid <= '0';
    dst_vec_valid <= '0';
    dst_vec_elem_valid <= '0';    
    dst_vec_last <= '0';
    dst_vec_unl_ready <= '1';
 
    -- Wait for reset to go low and start to go high.
    loop
      wait until rising_edge(kcd_clk);
      exit when reset = '0' and start = '1';
    end loop;

    busy <= '1';

    -- Issue the commands to all ArrayReaders/Writers
    command(kcd_clk, kcd_reset, src_firstidx, src_lastidx, src_vec_cmd_firstidx, src_vec_cmd_lastidx, src_vec_cmd_valid, src_vec_cmd_ready);
    command(kcd_clk, kcd_reset, dst_firstidx, dst_lastidx, dst_vec_cmd_firstidx, dst_vec_cmd_lastidx, dst_vec_cmd_valid, dst_vec_cmd_ready);
    
	loop
      -- Receive a vector length

      -- Wait for valid length
      src_vec_ready <= '1';
      loop
        wait until rising_edge(kcd_clk);
        exit when src_vec_valid = '1';
      end loop;
      
      println("Got a new vector:");
      current_elem := 0;
      vec_length := to_integer(unsigned(src_vec_length));

      -- Check if this is the last vector
      is_last := src_vec_last = '1';

      -- Not ready to receive a new length at the moment.
      src_vec_ready <= '0';

      -- Obtain all vec elems
      loop

        src_vec_elem_ready <= '1';

        -- Wait for handshake
        loop
          wait until rising_edge(kcd_clk);
          exit when src_vec_elem_valid = '1';
        end loop;

        -- Check the number of characters delivered
        num_elems := to_integer(unsigned(src_vec_elem_count));

        -- For each element in the current output
        for I in 0 to num_elems-1 loop
          -- Convert the std_logic_vector part to a character
          int_elem := to_integer(signed(src_vec_elem(ELEM_SIZE*(i+1)-1 downto ELEM_SIZE*i)));
          println(integer'image(int_elem));
          current_elem := current_elem + 1;
        end loop;

        -- Exit when this is the last (bunch of) elements
        exit when src_vec_elem_last = '1';
      end loop;

      src_vec_elem_ready <= '0';

      -- Check if the string length and the number of characters received is correct
      assert(current_elem = vec_length)
        report "Vector length expected to be zero on last signal, " & integer'image(vec_length) & " instead."
        severity failure;

      vec_idx := vec_idx + 1;

      -- If this was the last string, exit the loop
      exit when is_last;
    end loop;
    
    -- Wait a few extra cycles (normally you should use unlock stream for this)
    for I in 0 to 128 loop
        wait until rising_edge(kcd_clk);
    end loop;

    -- TODO(johanpel): check the write path

    -- Signal done to the usercore controller
    busy <= '0';
    done <= '1';
    wait;
  end process;
end Implementation;
