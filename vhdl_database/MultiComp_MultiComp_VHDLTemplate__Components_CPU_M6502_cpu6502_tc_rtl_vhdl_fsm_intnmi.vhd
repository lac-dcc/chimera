-- VHDL Entity r6502_tc.fsm_intnmi.symbol
--
-- Created:
--          by - remoteghost.UNKNOWN (ENTW-7HPZ200)
--          at - 09:22:12 07/24/13
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

entity fsm_intnmi is
   port( 
      clk_clk_i   : in     std_logic;
      nmi_n_i     : in     std_logic;
      rst_nmi_i   : in     std_logic;
      rst_rst_n_i : in     std_logic;
      nmi_o       : out    std_logic
   );

-- Declarations

end fsm_intnmi ;

-- (C) 2008 - 2018 Jens Gutschmidt
-- (email: opencores@vivare-services.com)
-- 
-- Versions:
-- Revision 1.9  2018/09/11 11:37:00  jens
-- - NMI = '0' need at least 1 cycles for correct
--   operation now (2 cycles in the past)
-- 
-- Revision 1.8  2013/07/24 11:11:00  jens
-- - Changing the title block and internal revision history
-- 
-- Revision 1.6  2009/01/04 10:20:47  eda
-- Changes for cosmetic issues only
-- 
-- Revision 1.5  2009/01/04 09:23:10  eda
-- - Delete unused nets and blocks
-- - Rename blocks
-- 
-- Revision 1.4  2009/01/03 16:53:02  eda
-- - Unused nets and blocks deleted
-- - Renamed blocks
-- 
-- Revision 1.3  2009/01/03 16:42:02  eda
-- - Unused nets and blocks deleted
-- - Renamed blocks
-- 
-- Revision 1.2  2008/12/31 19:31:24  eda
-- Production Release
--  
-- 
--
-- VHDL Architecture r6502_tc.fsm_intnmi.fsm
--
-- Created:
--          by - eda.UNKNOWN (ENTW-7HPZ200)
--          at - 11:45:38 11.09.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
-- COPYRIGHT (C) 2008 - 2018 by Jens Gutschmidt
-- 
-- This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.
-- 
-- This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-- 
-- You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.
-- 
-- 
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
 
architecture fsm of fsm_intnmi is

   subtype state_type is 
      std_logic_vector(1 downto 0);
 
   -- Hard encoding
   constant idle : state_type := "00";
   constant idle1 : state_type := "01";
   constant IMP : state_type := "11";

   -- Declare current and next state signals
   signal current_state : state_type;
   signal next_state : state_type;

   -- Declare any pre-registered internal signals
   signal nmi_o_cld : std_logic ;

begin

   -----------------------------------------------------------------
   clocked_proc : process ( 
      clk_clk_i,
      rst_rst_n_i
   )
   -----------------------------------------------------------------
   begin
      if (rst_rst_n_i = '0') then
         current_state <= idle;
         -- Default Reset Values
         nmi_o_cld <= '0';
      elsif (clk_clk_i'event and clk_clk_i = '1') then
         current_state <= next_state;
         -- Default Assignment To Internals
         nmi_o_cld <= '0';

         -- Combined Actions
         case current_state is
            when idle1 => 
               if (nmi_n_i = '0') then 
                  nmi_o_cld <= '1';
               end if;
            when IMP => 
               nmi_o_cld <= '1';
               if (rst_nmi_i = '1') then 
                  nmi_o_cld <= '0';
               end if;
            when others =>
               null;
         end case;
      end if;
   end process clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : process ( 
      current_state,
      nmi_n_i,
      rst_nmi_i
   )
   -----------------------------------------------------------------
   begin
      case current_state is
         when idle => 
            if (nmi_n_i = '1') then 
               next_state <= idle1;
            else
               next_state <= idle;
            end if;
         when idle1 => 
            if (nmi_n_i = '0') then 
               next_state <= IMP;
            else
               next_state <= idle1;
            end if;
         when IMP => 
            if (rst_nmi_i = '1') then 
               next_state <= idle;
            else
               next_state <= IMP;
            end if;
         when others =>
            next_state <= idle;
      end case;
   end process nextstate_proc;
 
   -- Concurrent Statements
   -- Clocked output assignments
   nmi_o <= nmi_o_cld;
end fsm;
