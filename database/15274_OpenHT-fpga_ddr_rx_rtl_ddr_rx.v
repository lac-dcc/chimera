// This program was cloned from: https://github.com/M17-Project/OpenHT-fpga
// License: GNU General Public License v3.0


/*******************************************************************************
    Verilog netlist generated by IPGEN Lattice Radiant Software (64-bit)
    2022.1.1.289.4
    Soft IP Version: 1.6.0
    2023 06 18 18:37:09
*******************************************************************************/
/*******************************************************************************
    Wrapper Module generated per user settings.
*******************************************************************************/
module ddr_rx (rst_i, 
        data_i, 
        clk_i, 
        data_o, 
        sclk_o) ;
    input rst_i ; 
    input [0:0] data_i ; 
    input clk_i ; 
    output [1:0] data_o ; 
    output sclk_o ; 
    ddr_rx_ipgen_lscc_gddr #(.INTERFACE_TYPE("RECEIVE"),
            .IO_TYPE("LVDS"),
            .GEARING(1),
            .BUS_WIDTH(1),
            .OUT_WIDTH(1),
            .IN_WIDTH(0),
            .CLOCK_DATA_RELATION("CENTERED"),
            .DATA_PATH_DELAY("BYPASS"),
            .DATA_DELAY_ADJUSTMENT("DEFAULT"),
            .D_FINE_DEL_INPUT(0),
            .DATA_FINE_DELAY_VALUE("0"),
            .DATA_COARSE_DELAY_VALUE("0NS"),
            .CLOCK_PATH_DELAY("FIXED"),
            .INCLUDE_GDDR_SYNC(0),
            .TRISTATE_EN(0),
            .CLK_FREQ(100.0),
            .PLL_ENABLE(0),
            .INTFBKDEL_SEL("DISABLED"),
            .PMU_WAITFORLOCK("ENABLED"),
            .REF_OSC_CTRL("3P2"),
            .REF_COUNTS("0000"),
            .EN_REFCLK_MON(0),
            .FVCO(900.0),
            .CLKI_FREQ(25.0),
            .CLKI_DIVIDER_ACTUAL_STR("1"),
            .FRAC_N_EN(0),
            .FBK_MODE("CLKOP"),
            .FBCLK_DIVIDER_ACTUAL_STR("6"),
            .SSC_N_CODE_STR("0b000000110"),
            .SSC_F_CODE_STR("0b000000000000000"),
            .SS_EN(0),
            .SSC_PROFILE("DOWN"),
            .SSC_TBASE_STR("0b000000000000"),
            .SSC_STEP_IN_STR("0b0000000"),
            .SSC_REG_WEIGHTING_SEL_STR("0b000"),
            .CLKOP_BYPASS(1),
            .ENCLKOP_EN(0),
            .CLKOP_FREQ_ACTUAL(150.0),
            .CLKOP_PHASE_ACTUAL(0.0),
            .DIVOP_ACTUAL_STR("5"),
            .DELA("5"),
            .PHIA("0"),
            .TRIM_EN_P(0),
            .CLKOP_TRIM_MODE("Falling"),
            .CLKOP_TRIM("0b0000"),
            .CLKOS_EN(1),
            .CLKOS_BYPASS(0),
            .ENCLKOS_EN(0),
            .CLKOS_FREQ_ACTUAL(100.0),
            .CLKOS_PHASE_ACTUAL(0.0),
            .DIVOS_ACTUAL_STR("7"),
            .DELB("7"),
            .PHIB("0"),
            .TRIM_EN_S(0),
            .CLKOS_TRIM_MODE("Falling"),
            .CLKOS_TRIM("0b0000"),
            .CLKOS2_EN(0),
            .CLKOS2_BYPASS(1),
            .ENCLKOS2_EN(0),
            .CLKOS2_FREQ_ACTUAL(100.0),
            .CLKOS2_PHASE_ACTUAL(0.0),
            .DIVOS2_ACTUAL_STR("7"),
            .DELC("7"),
            .PHIC("0"),
            .CLKOS3_EN(0),
            .CLKOS3_BYPASS(1),
            .ENCLKOS3_EN(0),
            .CLKOS3_FREQ_ACTUAL(100.0),
            .CLKOS3_PHASE_ACTUAL(0.0),
            .DIVOS3_ACTUAL_STR("7"),
            .DELD("7"),
            .PHID("0"),
            .CLKOS4_EN(0),
            .CLKOS4_BYPASS(1),
            .ENCLKOS4_EN(0),
            .CLKOS4_FREQ_ACTUAL(100.0),
            .CLKOS4_PHASE_ACTUAL(0.0),
            .DIVOS4_ACTUAL_STR("7"),
            .DELE("7"),
            .PHIE("0"),
            .CLKOS5_EN(0),
            .CLKOS5_BYPASS(1),
            .ENCLKOS5_EN(0),
            .CLKOS5_FREQ_ACTUAL(100.0),
            .CLKOS5_PHASE_ACTUAL(0.0),
            .DIVOS5_ACTUAL_STR("7"),
            .DELF("7"),
            .PHIF("0"),
            .PLL_REFCLK_FROM_PIN(0),
            .REF_CLK_IO_TYPE("LVDS"),
            .DYN_PORTS_EN(0),
            .PLL_RST(1),
            .LOCK_EN(1),
            .PLL_LOCK_STICKY(0),
            .LMMI_EN(0),
            .APB_EN(0),
            .LEGACY_EN(0),
            .POWERDOWN_EN(0),
            .IPI_CMP("0b0100"),
            .CSET("24P"),
            .CRIPPLE("3P"),
            .IPP_CTRL("0b0100"),
            .IPP_SEL("0b1111"),
            .BW_CTL_BIAS("0b1111"),
            .V2I_PP_RES("9K"),
            .KP_VCO("0b00011"),
            .V2I_KVCO_SEL("60"),
            .V2I_1V_EN("ENABLED")) lscc_gddr_inst (.rst_i(rst_i), 
                .alignwd_i(1'b1), 
                .sync_clk_i(1'b1), 
                .sync_rst_i(1'b1), 
                .sync_update_i(1'b1), 
                .sync_start_i(1'b1), 
                .pll_clki_i(1'b1), 
                .pll_rstn_i(1'b1), 
                .data_loadn_i(1'b1), 
                .data_move_i(1'b1), 
                .data_direction_i(1'b1), 
                .data_coarse_dly_i(2'b11), 
                .data_i(data_i[0]), 
                .clk_loadn_i(1'b1), 
                .clk_move_i(1'b1), 
                .clk_direction_i(1'b1), 
                .clk_coarse_dly_i(2'b11), 
                .outen_n_i(1'b1), 
                .clk_i(clk_i), 
                .clk90_i(1'b0), 
                .eclk_i(1'b0), 
                .eclk90_i(1'b0), 
                .data_cflag_o(), 
                .data_o(data_o[1:0]), 
                .clk_cflag_o(), 
                .dcntl_o(), 
                .clk_o(), 
                .sclk_o(sclk_o), 
                .ready_o(), 
                .lmmi_clk_i(1'b0), 
                .lmmi_resetn_i(1'b1), 
                .lmmi_request_i(1'b0), 
                .lmmi_wr_rdn_i(1'b0), 
                .lmmi_offset_i(7'b0000000), 
                .lmmi_wdata_i(8'b00000000), 
                .lmmi_rdata_o(), 
                .lmmi_rdata_valid_o(), 
                .lmmi_ready_o(), 
                .apb_pclk_i(1'b0), 
                .apb_preset_n_i(1'b1), 
                .apb_penable_i(1'b0), 
                .apb_psel_i(1'b0), 
                .apb_pwrite_i(1'b0), 
                .apb_paddr_i(7'b0000000), 
                .apb_pwdata_i(8'b00000000), 
                .apb_pready_o(), 
                .apb_pslverr_o(), 
                .apb_prdata_o()) ; 
endmodule



`timescale 100fs/100fs
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : 
// File                  : gddr_sync.v
// Title                 : 
// Dependencies          :
// Description           : 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 03.20.2018
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_gddr_sync (// -----------------------------------------------------------------------------
    // Input Ports
    // -----------------------------------------------------------------------------
    rst,  // Asynchronous reset
    sync_clk,  // oscillator clk or other constant running low speed clk.
    // note that this clk should not be coming from clk sources
    // that this module will stop or reset (e.g. ECLKSYNC, CLKDIV)
    start,  // Initialize the sync process
    // -----------------------------------------------------------------------------
    // Output Ports
    // -----------------------------------------------------------------------------
    // outputs
    stop,  // ECLKSYNC.stop signal
    ddr_reset,  // DDR and CLKDIV reset signal
    ready // READY signal; clock sync is done.
    ) ;
    //-----------------------------------------------------------------------------
    // PORTS DECLARATIONS
    //-----------------------------------------------------------------------------
    // Input ports
    input rst ; 
    input sync_clk ; 
    input start ; 
    // Output ports
    output stop ; 
    output ddr_reset ; 
    output ready ; 
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    // Local parameters: States
    /* Aldec enum gddr_sync_main_sm STATES=
          INIT,
          STOP,
          RESET,
          READY
*/
    localparam INIT = 3'b000 ; 
    localparam STOP = 3'b001 ; 
    localparam RESET = 3'b011 ; 
    localparam READY = 3'b100 ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire rst ; 
    wire sync_clk ; 
    wire start ; 
    wire ddr_reset ; 
    wire stop ; 
    wire ready ; 
    reg ddr_reset_d ; 
    reg [3:0] ctrl_cnt ; // control counter
    reg [2:0] stop_assert ; // stop signal counter
    /* Aldec state_vector cs_gddr_sync enum gddr_sync_main_sm */
    (* syn_preserve=1 *) reg [2:0] cs_gddr_sync ; // current state
    reg [2:0] ns_gddr_sync ; // next state
    reg reset_flag ; // flag signal that
    // indicates that RESET
    // is already done
    // -----------------------------------------------------------------------------
    // Assign Statements
    // -----------------------------------------------------------------------------
    assign stop = cs_gddr_sync[0] ; 
    assign ddr_reset = (cs_gddr_sync[1] | ddr_reset_d) ; 
    assign ready = cs_gddr_sync[2] ; 
    // -----------------------------------------------------------------------------
    // Sequential Blocks
    // -----------------------------------------------------------------------------
    always
        @(posedge sync_clk or 
            posedge rst)
        begin
            if ((rst == 1'b1)) 
                begin
                    cs_gddr_sync <=  INIT ;
                    ctrl_cnt <=  4'd0 ;
                    stop_assert <=  3'd0 ;
                    reset_flag <=  1'b0 ;
                    ddr_reset_d <=  1'b1 ;
                end
            else
                begin
                    cs_gddr_sync <=  ns_gddr_sync ;
                    ddr_reset_d <=  1'b0 ;
                    // CTRL_CNT for state machines
                    if ((((cs_gddr_sync == INIT) && (reset_flag == 1'b0)) || ((ctrl_cnt == 4'd3) && (cs_gddr_sync != INIT)))) 
                        begin
                            ctrl_cnt <=  4'd0 ;
                        end
                    else
                        if ((ctrl_cnt < 4'd8)) 
                            begin
                                ctrl_cnt <=  (ctrl_cnt + 4'd1) ;
                            end
                    // STOP signal will then be asserted 4T after rstn
                    if (((((!rst) && start) && (stop_assert < 3'd4)) && (reset_flag == 1'b0))) 
                        begin
                            stop_assert <=  (stop_assert + 3'd1) ;
                        end
                    // Asserts the reset_flag after RESET state
                    if (((cs_gddr_sync == RESET) && (ns_gddr_sync == STOP))) 
                        begin
                            reset_flag <=  1'b1 ;
                        end
                    // Deasserts the reset_flag after READY state
                    if (((cs_gddr_sync == READY) && (ns_gddr_sync == INIT))) 
                        begin
                            reset_flag <=  1'b0 ;
                        end
                end
        end
    // GDDR_SYNC State machine
    always
        @(*)
        begin
            case (cs_gddr_sync)
            INIT : 
                // INIT state 0
                begin
                    if (((start && (stop_assert == 3'd3)) && (reset_flag == 1'b0))) 
                        begin
                            ns_gddr_sync = STOP ;
                        end
                    else
                        if ((((reset_flag == 1'b1) && (ctrl_cnt == 4'd7)) && start)) 
                            begin
                                ns_gddr_sync = READY ;
                            end
                        else
                            begin
                                ns_gddr_sync = INIT ;
                            end
                end
            STOP : 
                //STOP state 1
                begin
                    if ((ctrl_cnt == 4'd3)) 
                        begin
                            if ((reset_flag == 1'b1)) 
                                begin
                                    ns_gddr_sync = INIT ;
                                end
                            else
                                begin
                                    ns_gddr_sync = RESET ;
                                end
                        end
                    else
                        begin
                            ns_gddr_sync = STOP ;
                        end
                end
            RESET : 
                // RESET state 2
                begin
                    if ((ctrl_cnt == 4'd3)) 
                        begin
                            ns_gddr_sync = STOP ;
                        end
                    else
                        begin
                            ns_gddr_sync = RESET ;
                        end
                end
            READY : 
                // READY state 5
                begin
                    if ((!start)) 
                        begin
                            ns_gddr_sync = INIT ;
                        end
                    else
                        begin
                            ns_gddr_sync = READY ;
                        end
                end
            default : 
                begin
                    ns_gddr_sync = cs_gddr_sync ;
                end
            endcase 
        end

// gddr_sync
endmodule



`timescale 100fs/100fs
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddr.v
// Title                 :
// Dependencies          : 1. GDDR module
// Description           : Generic DDR IO Interface.
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddr_rx_sclk_centered_static_bypass.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddr_rx_sclk_centered_static_bypass #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input rst_i, 
    input clk_i, 
    input [(BUS_WIDTH - 1):0] data_i, 
    output [((2 * BUS_WIDTH) - 1):0] data_o, 
    output sclk_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_PATH_DELAY == "BYPASS") ? "SCLK_CENTERED" : "USER_DEFINED") ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire [(BUS_WIDTH - 1):0] data_i_del_w ; // Data after DELAYB.
    // -----------------------------------------------------------------------------
    // Assign Statements
    // -----------------------------------------------------------------------------
    assign sclk_o = clk_i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // DELAYB
            DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .DEL_MODE(DEL_MODE)) u_DELAYB (.A(data_i[i]), 
                        .Z(data_i_del_w[i])) ; 
            // IDDRX
            IDDRX1 #(.GSR("DISABLED")) u_IDDRX1 (.D(data_i_del_w[i]), 
                        .SCLK(clk_i), 
                        .RST(rst_i), 
                        .Q1(data_o[((i * 2) + 1)]), 
                        .Q0(data_o[((i * 2) + 0)])) ; 
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddr_rx_sclk_centered_static_bypass.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddr_rx_sclk_centered_dynamic.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddr_rx_sclk_centered_dynamic #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input rst_i, 
    input clk_i, 
    input [(BUS_WIDTH - 1):0] data_i, 
    input [(BUS_WIDTH - 1):0] data_loadn_i, 
    input [(BUS_WIDTH - 1):0] data_move_i, 
    input [(BUS_WIDTH - 1):0] data_direction_i, 
    input [((2 * BUS_WIDTH) - 1):0] data_coarse_dly_i, 
    output [(BUS_WIDTH - 1):0] data_cflag_o, 
    output [((2 * BUS_WIDTH) - 1):0] data_o, 
    output sclk_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_PATH_DELAY == "BYPASS") ? "SCLK_CENTERED" : "USER_DEFINED") ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire [(BUS_WIDTH - 1):0] data_i_del_w ; // Data after DELAYA.
    // -----------------------------------------------------------------------------
    // Assign Statements
    // -----------------------------------------------------------------------------
    assign sclk_o = clk_i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // DELAYA
            DELAYA #(.DEL_MODE(DEL_MODE),
                    .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .COARSE_DELAY_MODE("DYNAMIC"),
                    .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .EDGE_MONITOR("DISABLED"),
                    .WAIT_FOR_EDGE("DISABLED")) u_DELAYA (// Inputs
                    .A(data_i[i]), 
                        .LOAD_N(data_loadn_i[i]), 
                        .MOVE(data_move_i[i]), 
                        .DIRECTION(data_direction_i[i]), 
                        .COARSE0(data_coarse_dly_i[((i * 2) + 0)]), 
                        .COARSE1(data_coarse_dly_i[((i * 2) + 1)]), 
                        .RANKENABLE(1'b0), 
                        .RANKSELECT(1'b0), 
                        .RANK0UPDATE(1'b0), 
                        .RANK1UPDATE(1'b0), 
                        // Outputs
                    .Z(data_i_del_w[i]), 
                        .EDETERR(), 
                        .CFLAG(data_cflag_o[i])) ; 
            // IDDRX
            IDDRX1 #(.GSR("DISABLED")) u_IDDRX1 (// Inputs
                    .D(data_i_del_w[i]), 
                        .SCLK(clk_i), 
                        .RST(rst_i), 
                        // Outputs
                    .Q1(data_o[((i * 2) + 1)]), 
                        .Q0(data_o[((i * 2) + 0)])) ; 
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddr_rx_sclk_centered_dynamic.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddr_rx_sclk_aligned_static_bypass.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : rx_sync.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             :
// Mod. Date             : 02.12.2019
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_rx_sync (// input
    rst,  // Asynchronous reset
    sync_clk,  // oscillator clk or other constant running low speed clk.
    // Note that this clk should not be coming from clk sources that
    // this module will stop or reset (e.g. ECLKSYNC, CLKDIV, etc.)
    update,  // Restart the sync process
    dll_lock,  // 'lock' signal of DDRDLL module
    // output
    dll_reset,  // 'rst' signal of DDRDLL module
    uddcntln,  // 'uddnctln' signal of DDRDLL module
    freeze,  // 'freeze' signal of DDRDLL module
    stop,  // 'stop' signal of ECLKSYNC module
    ddr_reset,  // 'rst' signal of IDDR and CLKDIV
    ready // Indicates startup is done; RX is ready to operate
    ) ;
    //-----------------------------------------------------------------------------
    // PORT DECLARATIONS
    //-----------------------------------------------------------------------------
    // Input ports
    input rst ; 
    input sync_clk ; 
    input update ; 
    input dll_lock ; 
    // Output ports
    output uddcntln ; 
    output freeze ; 
    output stop ; 
    output ddr_reset ; 
    output ready ; 
    (* syn_preserve=1 *) output dll_reset ; 
    //-----------------------------------------------------------------------------
    // WIRE AND REGISTER DECLARATIONS
    //-----------------------------------------------------------------------------
    wire rst ; 
    wire sync_clk ; 
    wire dll_lock ; 
    wire update ; 
    wire uddcntln ; 
    wire freeze ; 
    wire stop ; 
    wire ddr_reset ; 
    wire ready ; 
    (* syn_preserve=1 *) reg dll_reset ; 
    (* syn_preserve=1 *) reg ddr_reset_d ; 
    reg [2:0] ctrl_cnt ; // 4 clock cycles counter
    reg [2:0] dll_lock_cnt ; // counter for lock and freeze timing
    reg [2:0] ready_cnt ; // counter for ready signal
    /* Aldec state_vector cs_rx_sync enum rx_sync_main_sm */
    (* syn_preserve=1 *) reg [4:0] cs_rx_sync ; // current state
    reg [4:0] ns_rx_sync ; // next state
    reg dll_lock_q1 ; 
    reg dll_lock_q2 ; 
    reg not_uddcntln ; 
    reg assert_stop ; 
    reg not_reset ; 
    reg not_stop ; 
    reg not_freeze ; 
    reg get_ready ; 
    //-----------------------------------------------------------------------------
    // PARAMETERS
    //-----------------------------------------------------------------------------
    //States
    /* Aldec enum rx_sync_main_sm STATES=
          UPDATE,
          FREEZE,
          UDDCNTLN,
          STOP,
          RESET,
          READY
*/
    localparam UPDATE = 5'b00010 ; 
    localparam FREEZE = 5'b10010 ; 
    localparam UDDCNTLN = 5'b10000 ; 
    localparam STOP = 5'b11010 ; 
    localparam RESET = 5'b11110 ; 
    localparam READY = 5'b00011 ; 
    //-----------------------------------------------------------------------------
    // ASSIGN STATEMENTS
    //-----------------------------------------------------------------------------
    // State assignments
    assign freeze = cs_rx_sync[4] ; 
    assign stop = cs_rx_sync[3] ; 
    assign ddr_reset = (cs_rx_sync[2] | ddr_reset_d) ; 
    assign uddcntln = cs_rx_sync[1] ; 
    assign ready = cs_rx_sync[0] ; 
    // State Machine Next State decoder
    always
        @(*)
        begin
            case (cs_rx_sync) // synopsys full_case parallel_case
            UPDATE : 
                begin
                    if (((dll_lock_cnt == 3'd5) && (!not_uddcntln))) 
                        begin
                            ns_rx_sync = FREEZE ;
                        end
                    else
                        if (((ready_cnt == 3'd7) && (get_ready == 1'b1))) 
                            begin
                                ns_rx_sync = READY ;
                            end
                        else
                            begin
                                ns_rx_sync = UPDATE ;
                            end
                end// UPDATE
            FREEZE : 
                begin
                    if ((ctrl_cnt == 3'd3)) 
                        begin
                            if ((assert_stop == 1'b1)) 
                                begin
                                    ns_rx_sync = STOP ;
                                end
                            else
                                if ((not_freeze == 1'b1)) 
                                    begin
                                        ns_rx_sync = UPDATE ;
                                    end
                                else
                                    begin
                                        ns_rx_sync = UDDCNTLN ;
                                    end
                        end
                    else
                        begin
                            ns_rx_sync = FREEZE ;
                        end
                end// FREEZE
            UDDCNTLN : 
                begin
                    if (((ctrl_cnt == 3'd3) && (not_uddcntln == 1'b1))) 
                        begin
                            ns_rx_sync = FREEZE ;
                        end
                    else
                        begin
                            ns_rx_sync = UDDCNTLN ;
                        end
                end// UDDCTLN
            STOP : 
                begin
                    if ((ctrl_cnt == 3)) 
                        begin
                            if ((not_stop == 1'b1)) 
                                begin
                                    ns_rx_sync = FREEZE ;
                                end
                            else
                                begin
                                    ns_rx_sync = RESET ;
                                end
                        end
                    else
                        begin
                            ns_rx_sync = STOP ;
                        end
                end// STOP
            RESET : 
                begin
                    if (((ctrl_cnt == 3'd3) && (not_reset == 1'b1))) 
                        begin
                            ns_rx_sync = STOP ;
                        end
                    else
                        begin
                            ns_rx_sync = RESET ;
                        end
                end// RESET
            READY : 
                begin
                    if (((!dll_lock_q2) || update)) 
                        begin
                            ns_rx_sync = UPDATE ;// If DLL unlocks, re-start sync process
                        end
                    else
                        begin
                            ns_rx_sync = READY ;
                        end
                end
            default : 
                begin
                    ns_rx_sync = cs_rx_sync ;
                end
            endcase //case(cs_rx_sync)
        end// always (*) FSM Next State Decoder
    //-----------------------------------------------------------------------------
    // REGISTER ASSIGNMENTS
    //----------------------------------------------------------------------------
    // Synchronize LOCK signal
    always
        @(posedge sync_clk or 
            posedge rst)
        begin
            if (rst) 
                begin
                    dll_lock_q1 <=  1'b0 ;
                    dll_lock_q2 <=  1'b0 ;
                end
            else
                begin
                    dll_lock_q1 <=  dll_lock ;
                    dll_lock_q2 <=  dll_lock_q1 ;
                end
        end
    always
        @(posedge sync_clk or 
            posedge rst)
        begin
            if (rst) 
                begin
                    cs_rx_sync <=  UPDATE ;
                    ctrl_cnt <=  3'd0 ;
                    dll_lock_cnt <=  3'd0 ;
                    ready_cnt <=  3'd0 ;
                    ddr_reset_d <=  1'b1 ;
                    dll_reset <=  1'b1 ;
                    not_uddcntln <=  1'b0 ;
                    assert_stop <=  1'b0 ;
                    not_reset <=  1'b0 ;
                    not_stop <=  1'b0 ;
                    not_freeze <=  1'b0 ;
                    get_ready <=  1'b0 ;
                end
            else
                begin
                    cs_rx_sync <=  ns_rx_sync ;
                    ddr_reset_d <=  1'b0 ;
                    dll_reset <=  1'b0 ;
                    // DLL LOCK Counter
                    // Counter starts to increment when DLL lock signal goes high and stops
                    // when it reaches 8T (8 clock cycles)
                    if (((dll_lock_q2 && dll_lock) && (dll_lock_cnt < 3'd5))) 
                        begin
                            dll_lock_cnt <=  (dll_lock_cnt + 3'd1) ;
                        end
                    // Counter for 4 clock cycles (4T)
                    // Sees to it that DLL stays locked for 8 clock cycles
                    if ((dll_lock_cnt != 3'd5)) 
                        begin
                            ctrl_cnt <=  3'd3 ;
                        end
                    else
                        if (((ctrl_cnt == 3'd3) && (cs_rx_sync != READY))) 
                            // Resets counter every 4T and when current state is not yet READY
                            begin
                                ctrl_cnt <=  3'd0 ;
                            end
                        else
                            if ((ctrl_cnt < 3'd4)) 
                                // Increments counter until 4T
                                begin
                                    ctrl_cnt <=  (ctrl_cnt + 3'd1) ;
                                end
                    // Counter for 'ready' signal
                    // Count for 8 clock cycles before 'ready' signal is asserted
                    if ((get_ready && (ready_cnt < 3'd7))) 
                        // starts to increment when get_ready signal is asserted
                        begin
                            ready_cnt <=  (ready_cnt + 3'd1) ;
                        end
                    // assert UDDCNTLN signal
                    if (((cs_rx_sync == FREEZE) && (ns_rx_sync == UDDCNTLN))) 
                        begin
                            not_uddcntln <=  1'b1 ;
                        end
                    // assert STOP signal
                    if (((cs_rx_sync == UDDCNTLN) && (ns_rx_sync == FREEZE))) 
                        begin
                            assert_stop <=  1'b1 ;
                        end
                    // de-assert RESET signal
                    if (((cs_rx_sync == STOP) && (ns_rx_sync == RESET))) 
                        begin
                            not_reset <=  1'b1 ;
                        end
                    // de-assert STOP signal
                    if (((cs_rx_sync == RESET) && (ns_rx_sync == STOP))) 
                        begin
                            not_stop <=  1'b1 ;
                        end
                    // de-assert FREEZE signal
                    if (((cs_rx_sync == STOP) && (ns_rx_sync == FREEZE))) 
                        begin
                            not_freeze <=  1'b1 ;
                            assert_stop <=  1'b0 ;
                        end
                    // sync process is done; ready to assert READY signal
                    if (((cs_rx_sync == FREEZE) && (ns_rx_sync == UPDATE))) 
                        begin
                            get_ready <=  1'b1 ;
                        end
                    // restart sync process when either the 'update' signal is
                    // asserted or DLL unlocks
                    if (((cs_rx_sync == READY) && (ns_rx_sync == UPDATE))) 
                        begin
                            not_freeze <=  1'b0 ;
                            assert_stop <=  1'b0 ;
                            not_stop <=  1'b0 ;
                            not_reset <=  1'b0 ;
                            not_uddcntln <=  1'b0 ;
                            get_ready <=  1'b0 ;
                            ready_cnt <=  3'b0 ;
                            dll_lock_cnt <=  3'b0 ;
                            ctrl_cnt <=  3'b0 ;
                            dll_reset <=  1'b1 ;
                        end
                end// else begin
        end// always @(posedge sync_clk or posedge rst) begin

//=============================================================================
//  Notes: RX_SYNC TIMING DIAGRAM
//=============================================================================
//  ____ rst
//      |__________________________________________________________________________________________
//
//  ____ DLL.RESET
//      |__________________________________________________________________________________________
//
//           ____DLL.LOCK goes high________________________________________________________________
//  ________|
//
//          |----8T----|
//                      ________________________________________________
//  __DLL.FREEZE_______|                                                |__________________________
//
//                     |--4T--|--4T--|                           |--4T--|----8T----|
//  __DLL.UDDCNTLN____________        _____________________________________________________________
//                            |______|
//
//                                   |--4T--|
//                                           ____________________
//  __ECLKSYNC.STOP_________________________|                    |_________________________________
//
//                                          |--4T--|--4T--|--4T--|
//  ____ ddr_reset to CLKDIV & IDDR                 ______
//      |__________________________________________|      |________________________________________
//
//                                                                                   ______________
//  __READY_________________________________________________________________________|
// rx_sync
endmodule



`timescale 100fs/100fs
//==============================================================================
// rx_sync.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : <Project Name>
// File                  : lscc_init_delay_cell.v
// Title                 : 
// Dependencies          : 1.
//                       : 2.
// Description           : 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : 
// =============================================================================
module ddr_rx_ipgen_lscc_init_delay_cell (
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    // Inputs
    input rst_n_i,  // Asynchronous, Active Low Reset.
    input sclk_i,  // System clock.
    input start_i,  // Start initialization process.
    // Outputs
    output wire load_n_o,  // Delay Cell LOAD_N pulse.
    output wire move_o,  // Delay Cell MOVE pulse.
    output wire direction_o,  // Delay Cell DIR pulse.
    output wire del_init_done_o // Delay Cell Initialization done.
        ) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam [3:0] LDN_START = 4'h1 ; // loadn pulse start counter value.
    localparam [3:0] LDN_END = 4'h5 ; // loadn pulse end   counter value.
    localparam [3:0] MV_START = 4'h2 ; // move  pulse start counter value.
    localparam [3:0] MV_END = 4'h4 ; // move  pulse end   counter value.
    // Delay Cell Initialization FSM States.
    localparam [1:0] D_IDLE = 2'h0 ; // Delay initialization IDLE state.
    localparam [1:0] D_ACT = 2'h1 ; // Delay initialization ACTIVE state.
    localparam [1:0] D_DONE = 2'h2 ; // Delay initialization DONE state.
    // -----------------------------------------------------------------------------
    // Sequential Registers
    // -----------------------------------------------------------------------------
    reg init_load_n_r ; 
    reg init_move_r ; 
    reg init_dir_r ; 
    reg [1:0] delay_st_r ; 
    reg [3:0] loadn_cntr_r ; 
    // -----------------------------------------------------------------------------
    // Assign Statements
    // -----------------------------------------------------------------------------
    assign del_init_done_o = (start_i & (delay_st_r == D_DONE)) ; 
    assign load_n_o = init_load_n_r ; 
    assign move_o = init_move_r ; 
    assign direction_o = init_dir_r ; 
    // -----------------------------------------------------------------------------
    // Sequential Blocks
    // -----------------------------------------------------------------------------
    always
        @(negedge rst_n_i or 
            posedge sclk_i)
        begin
            if ((!rst_n_i)) 
                begin
                    delay_st_r <=  D_IDLE ;
                    loadn_cntr_r <=  'd0 ;
                    init_load_n_r <=  'd0 ;
                    init_move_r <=  'd0 ;
                    init_dir_r <=  'd0 ;
                end
            else
                begin
                    case (delay_st_r) // synopsys parallel_case
                    D_IDLE : 
                        begin
                            // 2'b00;
                            loadn_cntr_r <=  'd0 ;
                            init_load_n_r <=  'd1 ;
                            init_move_r <=  'd0 ;
                            init_dir_r <=  'd0 ;
                            delay_st_r <=  D_ACT ;
                        end
                    D_ACT : 
                        begin
                            // 2'b01;
                            loadn_cntr_r <=  'd0 ;
                            if (start_i) 
                                begin
                                    loadn_cntr_r <=  (loadn_cntr_r + 'd1) ;
                                    if ((loadn_cntr_r == LDN_START)) 
                                        begin
                                            init_load_n_r <=  'd0 ;
                                            init_move_r <=  'd0 ;
                                            init_dir_r <=  'd0 ;
                                        end
                                    else
                                        if ((loadn_cntr_r == MV_START)) 
                                            begin
                                                init_load_n_r <=  'd0 ;
                                                init_move_r <=  'd1 ;
                                                init_dir_r <=  'd0 ;
                                            end
                                        else
                                            if ((loadn_cntr_r == MV_END)) 
                                                begin
                                                    init_load_n_r <=  'd0 ;
                                                    init_move_r <=  'd0 ;
                                                    init_dir_r <=  'd0 ;
                                                end
                                            else
                                                if ((loadn_cntr_r == LDN_END)) 
                                                    begin
                                                        init_load_n_r <=  'd1 ;
                                                        init_move_r <=  'd0 ;
                                                        init_dir_r <=  'd0 ;
                                                        delay_st_r <=  D_DONE ;
                                                    end
                                end
                            else
                                begin
                                    delay_st_r <=  D_ACT ;
                                end
                        end
                    D_DONE : 
                        begin
                            // 2'b10
                            init_load_n_r <=  'd1 ;
                            init_move_r <=  'd0 ;
                            init_dir_r <=  'd0 ;
                            loadn_cntr_r <=  'd0 ;
                            delay_st_r <=  D_DONE ;
                        end
                    default : 
                        begin
                            delay_st_r <=  D_IDLE ;
                        end
                    endcase 
                end
        end// END
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_init_delay_cell.v
//==============================================================================
module ddr_rx_ipgen_lscc_gddr_rx_sclk_aligned_static_bypass #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input clk_i, 
    input [(BUS_WIDTH - 1):0] data_i, 
    input sync_clk_i, 
    input sync_rst_i, 
    input sync_update_i, 
    output [((2 * BUS_WIDTH) - 1):0] data_o, 
    output sclk_o, 
    output ready_o, 
    output [8:0] dcntl_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_PATH_DELAY == "BYPASS") ? "SCLK_ALIGNED" : "USER_DEFINED") ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire [8:0] code_w ; 
    wire rst_w ; 
    wire freeze_w ; 
    wire lock_w ; 
    wire uddcntln_w ; 
    wire dll_reset_w ; 
    wire [(BUS_WIDTH - 1):0] data_i_del_w ; 
    wire ready_w ; 
    wire load_n_w ; 
    wire move_w ; 
    wire dir_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    DDRDLL #(.GSR("ENABLED"),
            .ENA_ROUNDOFF("ENABLED"),
            .FORCE_MAX_DELAY("CODE_OR_LOCK_FROM_DLL_LOOP")) u0_DDRDLL (.CODE(code_w), 
                .FREEZE(freeze_w), 
                .LOCK(lock_w), 
                .CLKIN(sclk_o), 
                .RST(dll_reset_w), 
                .DCNTL(dcntl_o), 
                .UDDCNTL_N(uddcntln_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    DLLDEL #(.ADJUST("0"),
            .ENABLE("ENABLED")) u0_DLLDEL (.CLKIN(clk_i), 
                .CLKOUT(sclk_o), 
                .CODE(code_w), 
                .COUT(), 
                .DIR(dir_w), 
                .LOAD_N(load_n_w), 
                .MOVE(move_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_lscc_init_delay_cell u0_lscc_init_delay_cell (.rst_n_i((~sync_rst_i)), 
                .sclk_i(sclk_o), 
                .start_i(ready_w), 
                .load_n_o(load_n_w), 
                .move_o(move_w), 
                .direction_o(dir_w), 
                .del_init_done_o(ready_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_rx_sync u1_rx_sync (.rst(sync_rst_i), 
                .sync_clk(sync_clk_i), 
                .update(sync_update_i), 
                .dll_lock(lock_w), 
                .uddcntln(uddcntln_w), 
                .freeze(freeze_w), 
                .stop(), 
                .ddr_reset(rst_w), 
                .ready(ready_w), 
                .dll_reset(dll_reset_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // DELAYB
            DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .DEL_MODE(DEL_MODE)) u_DELAYB (.A(data_i[i]), 
                        .Z(data_i_del_w[i])) ; 
            // IDDRX
            IDDRX1 #(.GSR("DISABLED")) u_IDDRX1 (.D(data_i_del_w[i]), 
                        .SCLK(sclk_o), 
                        .RST(rst_w), 
                        .Q1(data_o[((i * 2) + 1)]), 
                        .Q0(data_o[((i * 2) + 0)])) ; 
        end
    endgenerate
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddr_rx_sclk_aligned_static_bypass.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddr_rx_sclk_aligned_dynamic_clock.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : rx_sync.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             :
// Mod. Date             : 02.12.2019
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : <Project Name>
// File                  : lscc_init_delay_cell.v
// Title                 : 
// Dependencies          : 1.
//                       : 2.
// Description           : 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : 
// =============================================================================
module ddr_rx_ipgen_lscc_gddr_rx_sclk_aligned_dynamic_clock #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input clk_i, 
    input [(BUS_WIDTH - 1):0] data_i, 
    input sync_clk_i, 
    input sync_rst_i, 
    input sync_update_i, 
    output [((2 * BUS_WIDTH) - 1):0] data_o, 
    output sclk_o, 
    output ready_o, 
    input clk_loadn_i, 
    input clk_move_i, 
    input clk_direction_i, 
    output clk_cflag_o, 
    output [8:0] dcntl_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_PATH_DELAY == "BYPASS") ? "SCLK_ALIGNED" : "USER_DEFINED") ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire [8:0] code_w ; 
    wire rst_w ; 
    wire freeze_w ; 
    wire lock_w ; 
    wire uddcntln_w ; 
    wire dll_reset_w ; 
    wire [(BUS_WIDTH - 1):0] data_i_del_w ; 
    wire ready_w ; 
    wire load_n_w ; 
    wire move_w ; 
    wire dir_w ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    DDRDLL #(.GSR("ENABLED"),
            .ENA_ROUNDOFF("ENABLED"),
            .FORCE_MAX_DELAY("CODE_OR_LOCK_FROM_DLL_LOOP")) u0_DDRDLL (.CODE(code_w), 
                .FREEZE(freeze_w), 
                .LOCK(lock_w), 
                .CLKIN(sclk_o), 
                .RST(dll_reset_w), 
                .DCNTL(dcntl_o), 
                .UDDCNTL_N(uddcntln_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    DLLDEL #(.ADJUST("0"),
            .ENABLE("ENABLED")) u0_DLLDEL (.CLKIN(clk_i), 
                .CLKOUT(sclk_o), 
                .CODE(code_w), 
                .COUT(clk_cflag_o), 
                .DIR(((ready_o == 1'h1) ? clk_direction_i : dir_w)), 
                .LOAD_N(((ready_o == 1'h1) ? clk_loadn_i : load_n_w)), 
                .MOVE(((ready_o == 1'h1) ? clk_move_i : move_w))) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_lscc_init_delay_cell u0_lscc_init_delay_cell (.rst_n_i((~sync_rst_i)), 
                .sclk_i(sclk_o), 
                .start_i(ready_w), 
                .load_n_o(load_n_w), 
                .move_o(move_w), 
                .direction_o(dir_w), 
                .del_init_done_o(ready_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_rx_sync u1_rx_sync (.rst(sync_rst_i), 
                .sync_clk(sync_clk_i), 
                .update(sync_update_i), 
                .dll_lock(lock_w), 
                .uddcntln(uddcntln_w), 
                .freeze(freeze_w), 
                .stop(), 
                .ddr_reset(rst_w), 
                .ready(ready_w), 
                .dll_reset(dll_reset_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // DELAYB
            DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .DEL_MODE(DEL_MODE)) u_DELAYB (.A(data_i[i]), 
                        .Z(data_i_del_w[i])) ; 
            // IDDRX
            IDDRX1 #(.GSR("DISABLED")) u_IDDRX1 (.D(data_i_del_w[i]), 
                        .SCLK(sclk_o), 
                        .RST(rst_w), 
                        .Q1(data_o[((i * 2) + 1)]), 
                        .Q0(data_o[((i * 2) + 0)])) ; 
        end
    endgenerate
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddr_rx_sclk_aligned_dynamic_clock.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddr_rx_sclk_aligned_dynamic_clock_data.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : rx_sync.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             :
// Mod. Date             : 02.12.2019
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : <Project Name>
// File                  : lscc_init_delay_cell.v
// Title                 : 
// Dependencies          : 1.
//                       : 2.
// Description           : 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : 
// =============================================================================
module ddr_rx_ipgen_lscc_gddr_rx_sclk_aligned_dynamic_clock_data #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input clk_i, 
    input [(BUS_WIDTH - 1):0] data_i, 
    input sync_clk_i, 
    input sync_rst_i, 
    input sync_update_i, 
    output [((2 * BUS_WIDTH) - 1):0] data_o, 
    output sclk_o, 
    output ready_o, 
    input clk_loadn_i, 
    input clk_move_i, 
    input clk_direction_i, 
    output clk_cflag_o, 
    input [(BUS_WIDTH - 1):0] data_loadn_i, 
    input [(BUS_WIDTH - 1):0] data_move_i, 
    input [(BUS_WIDTH - 1):0] data_direction_i, 
    output [(BUS_WIDTH - 1):0] data_cflag_o, 
    input [((2 * BUS_WIDTH) - 1):0] data_coarse_dly_i, 
    output [8:0] dcntl_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_PATH_DELAY == "BYPASS") ? "SCLK_ALIGNED" : "USER_DEFINED") ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire [8:0] code_w ; 
    wire rst_w ; 
    wire freeze_w ; 
    wire lock_w ; 
    wire uddcntln_w ; 
    wire dll_reset_w ; 
    wire [(BUS_WIDTH - 1):0] data_i_del_w ; 
    wire ready_w ; 
    wire load_n_w ; 
    wire move_w ; 
    wire dir_w ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    DDRDLL #(.GSR("ENABLED"),
            .ENA_ROUNDOFF("ENABLED"),
            .FORCE_MAX_DELAY("CODE_OR_LOCK_FROM_DLL_LOOP")) u0_DDRDLL (.CODE(code_w), 
                .FREEZE(freeze_w), 
                .LOCK(lock_w), 
                .CLKIN(sclk_o), 
                .RST(dll_reset_w), 
                .DCNTL(dcntl_o), 
                .UDDCNTL_N(uddcntln_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    DLLDEL #(.ADJUST("0"),
            .ENABLE("ENABLED")) u0_DLLDEL (.CLKIN(clk_i), 
                .CLKOUT(sclk_o), 
                .CODE(code_w), 
                .COUT(clk_cflag_o), 
                .DIR(((ready_o == 1'h1) ? clk_direction_i : dir_w)), 
                .LOAD_N(((ready_o == 1'h1) ? clk_loadn_i : load_n_w)), 
                .MOVE(((ready_o == 1'h1) ? clk_move_i : move_w))) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_lscc_init_delay_cell u0_lscc_init_delay_cell (.rst_n_i((~sync_rst_i)), 
                .sclk_i(sclk_o), 
                .start_i(ready_w), 
                .load_n_o(load_n_w), 
                .move_o(move_w), 
                .direction_o(dir_w), 
                .del_init_done_o(ready_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_rx_sync u1_rx_sync (.rst(sync_rst_i), 
                .sync_clk(sync_clk_i), 
                .update(sync_update_i), 
                .dll_lock(lock_w), 
                .uddcntln(uddcntln_w), 
                .freeze(freeze_w), 
                .stop(), 
                .ddr_reset(rst_w), 
                .ready(ready_w), 
                .dll_reset(dll_reset_w)) ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // DELAYA
            DELAYA #(.DEL_MODE(DEL_MODE),
                    .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .COARSE_DELAY_MODE("DYNAMIC"),
                    .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .EDGE_MONITOR("DISABLED"),
                    .WAIT_FOR_EDGE("DISABLED")) u_DELAYA (// Inputs
                    .A(data_i[i]), 
                        .LOAD_N(data_loadn_i[i]), 
                        .MOVE(data_move_i[i]), 
                        .DIRECTION(data_direction_i[i]), 
                        .COARSE0(data_coarse_dly_i[((i * 2) + 0)]), 
                        .COARSE1(data_coarse_dly_i[((i * 2) + 1)]), 
                        .RANKSELECT(1'h0), 
                        .RANKENABLE(1'h0), 
                        .RANK0UPDATE(1'h0), 
                        .RANK1UPDATE(1'h0), 
                        // Outputs
                    .Z(data_i_del_w[i]), 
                        .EDETERR(), 
                        .CFLAG(data_cflag_o[i])) ; 
            // IDDRX
            IDDRX1 #(.GSR("DISABLED")) u_IDDRX1 (.D(data_i_del_w[i]), 
                        .SCLK(sclk_o), 
                        .RST(rst_w), 
                        .Q1(data_o[((i * 2) + 1)]), 
                        .Q0(data_o[((i * 2) + 0)])) ; 
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddr_rx_sclk_aligned_dynamic_clock_data.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddrx2_4_5_rx_eclk_centered_static_bypass.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddrx2_4_5_rx_eclk_centered_static_bypass #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter GEARING = 2, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input rst_i, 
    input clk_i, 
    input [(BUS_WIDTH - 1):0] data_i, 
    output [(((2 * GEARING) * BUS_WIDTH) - 1):0] data_o, 
    output sclk_o, 
    input alignwd_i) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_DELAY_ADJUSTMENT == "DEFAULT") ? "ECLK_CENTERED" : "USER_DEFINED") ; 
    localparam GEARING_STR = ((GEARING == 5) ? "5" : ((GEARING == 4) ? "4" : "2")) ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire eclkout_w ; 
    wire [(BUS_WIDTH - 1):0] del_data_i_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKDIV #(.ECLK_DIV(GEARING_STR),
            .GSR("DISABLED")) u0_ECLKDIV (.DIVOUT(sclk_o), 
                .DIVRST(rst_i), 
                .ECLKIN(eclkout_w), 
                .SLIP(alignwd_i)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKSYNC #(.STOP_EN("DISABLE")) u0_ECLKSYNC (.ECLKIN(clk_i), 
                .ECLKOUT(eclkout_w), 
                .STOP(rst_i)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // DELAYB
            DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .DEL_MODE(DEL_MODE)) u_data_DELAYB (.A(data_i[i]), 
                        .Z(del_data_i_w[i])) ; 
            if ((GEARING == 2)) 
                begin : genblk1
                    //IDDRX2
                    IDDRX2 #(.GSR("DISABLED")) u_IDDRX2 (// Inputs
                            .D(del_data_i_w[i]), 
                                .RST(rst_i), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                .ALIGNWD(alignwd_i), 
                                // Outputs
                            .Q0(data_o[((i * 4) + 0)]), 
                                .Q1(data_o[((i * 4) + 1)]), 
                                .Q2(data_o[((i * 4) + 2)]), 
                                .Q3(data_o[((i * 4) + 3)])) ; 
                end
            else
                if ((GEARING == 4)) 
                    begin : genblk1
                        // IDDRX4
                        IDDRX4 #(.GSR("DISABLED")) u_IDDRX4 (// Inputs
                                .D(del_data_i_w[i]), 
                                    .RST(rst_i), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    .ALIGNWD(alignwd_i), 
                                    // Outputs
                                .Q0(data_o[((i * 8) + 0)]), 
                                    .Q1(data_o[((i * 8) + 1)]), 
                                    .Q2(data_o[((i * 8) + 2)]), 
                                    .Q3(data_o[((i * 8) + 3)]), 
                                    .Q4(data_o[((i * 8) + 4)]), 
                                    .Q5(data_o[((i * 8) + 5)]), 
                                    .Q6(data_o[((i * 8) + 6)]), 
                                    .Q7(data_o[((i * 8) + 7)])) ; 
                    end
                else
                    if ((GEARING == 5)) 
                        begin : genblk1
                            // IDDRX5
                            IDDRX5 #(.GSR("DISABLED")) u_IDDRX5 (// Inputs
                                    .D(del_data_i_w[i]), 
                                        .RST(rst_i), 
                                        .ECLK(eclkout_w), 
                                        .SCLK(sclk_o), 
                                        .ALIGNWD(alignwd_i), 
                                        // Outputs
                                    .Q0(data_o[((i * 10) + 0)]), 
                                        .Q1(data_o[((i * 10) + 1)]), 
                                        .Q2(data_o[((i * 10) + 2)]), 
                                        .Q3(data_o[((i * 10) + 3)]), 
                                        .Q4(data_o[((i * 10) + 4)]), 
                                        .Q5(data_o[((i * 10) + 5)]), 
                                        .Q6(data_o[((i * 10) + 6)]), 
                                        .Q7(data_o[((i * 10) + 7)]), 
                                        .Q8(data_o[((i * 10) + 8)]), 
                                        .Q9(data_o[((i * 10) + 9)])) ; 
                        end
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddrx2_4_5_rx_eclk_centered_static_bypass.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddrx2_4_5_rx_eclk_centered_static_bypass_gddr_sync.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : 
// File                  : gddr_sync.v
// Title                 : 
// Dependencies          :
// Description           : 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 03.20.2018
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddrx2_4_5_rx_eclk_centered_static_bypass_gddr_sync #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter GEARING = 2, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input sync_rst_i, 
    input clk_i, 
    input sync_clk_i, 
    input sync_start_i, 
    output ready_o, 
    input [(BUS_WIDTH - 1):0] data_i, 
    output [(((2 * GEARING) * BUS_WIDTH) - 1):0] data_o, 
    output sclk_o, 
    input alignwd_i) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_DELAY_ADJUSTMENT == "DEFAULT") ? "ECLK_CENTERED" : "USER_DEFINED") ; 
    localparam GEARING_STR = ((GEARING == 5) ? "5" : ((GEARING == 4) ? "4" : "2")) ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire eclkout_w ; 
    wire stop_w ; 
    wire rst_w ; 
    wire [(BUS_WIDTH - 1):0] del_data_i_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKDIV #(.ECLK_DIV(GEARING_STR),
            .GSR("DISABLED")) u0_ECLKDIV (.DIVOUT(sclk_o), 
                .DIVRST(rst_w), 
                .ECLKIN(eclkout_w), 
                .SLIP(alignwd_i)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKSYNC #(.STOP_EN("ENABLE")) u0_ECLKSYNC (.ECLKIN(clk_i), 
                .ECLKOUT(eclkout_w), 
                .STOP(stop_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_gddr_sync u1_gddr_sync (.rst(sync_rst_i), 
                .sync_clk(sync_clk_i), 
                .start(sync_start_i), 
                .stop(stop_w), 
                .ddr_reset(rst_w), 
                .ready(ready_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // DELAYB
            DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .DEL_MODE(DEL_MODE)) u_data_DELAYB (.A(data_i[i]), 
                        .Z(del_data_i_w[i])) ; 
            if ((GEARING == 2)) 
                begin : genblk1
                    //IDDRX2
                    IDDRX2 #(.GSR("DISABLED")) u_IDDRX2 (// Inputs
                            .D(del_data_i_w[i]), 
                                .RST(rst_w), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                .ALIGNWD(alignwd_i), 
                                // Outputs
                            .Q0(data_o[((i * 4) + 0)]), 
                                .Q1(data_o[((i * 4) + 1)]), 
                                .Q2(data_o[((i * 4) + 2)]), 
                                .Q3(data_o[((i * 4) + 3)])) ; 
                end
            else
                if ((GEARING == 4)) 
                    begin : genblk1
                        // IDDRX4
                        IDDRX4 #(.GSR("DISABLED")) u_IDDRX4 (// Inputs
                                .D(del_data_i_w[i]), 
                                    .RST(rst_w), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    .ALIGNWD(alignwd_i), 
                                    // Outputs
                                .Q0(data_o[((i * 8) + 0)]), 
                                    .Q1(data_o[((i * 8) + 1)]), 
                                    .Q2(data_o[((i * 8) + 2)]), 
                                    .Q3(data_o[((i * 8) + 3)]), 
                                    .Q4(data_o[((i * 8) + 4)]), 
                                    .Q5(data_o[((i * 8) + 5)]), 
                                    .Q6(data_o[((i * 8) + 6)]), 
                                    .Q7(data_o[((i * 8) + 7)])) ; 
                    end
                else
                    if ((GEARING == 5)) 
                        begin : genblk1
                            // IDDRX5
                            IDDRX5 #(.GSR("DISABLED")) u_IDDRX5 (// Inputs
                                    .D(del_data_i_w[i]), 
                                        .RST(rst_w), 
                                        .ECLK(eclkout_w), 
                                        .SCLK(sclk_o), 
                                        .ALIGNWD(alignwd_i), 
                                        // Outputs
                                    .Q0(data_o[((i * 10) + 0)]), 
                                        .Q1(data_o[((i * 10) + 1)]), 
                                        .Q2(data_o[((i * 10) + 2)]), 
                                        .Q3(data_o[((i * 10) + 3)]), 
                                        .Q4(data_o[((i * 10) + 4)]), 
                                        .Q5(data_o[((i * 10) + 5)]), 
                                        .Q6(data_o[((i * 10) + 6)]), 
                                        .Q7(data_o[((i * 10) + 7)]), 
                                        .Q8(data_o[((i * 10) + 8)]), 
                                        .Q9(data_o[((i * 10) + 9)])) ; 
                        end
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddrx2_4_5_rx_eclk_centered_static_bypass_gddr_sync.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddrx2_4_5_rx_eclk_centered_dynamic.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddrx2_4_5_rx_eclk_centered_dynamic #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter GEARING = 2, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input rst_i, 
    input clk_i, 
    input [(BUS_WIDTH - 1):0] data_i, 
    output [(((2 * GEARING) * BUS_WIDTH) - 1):0] data_o, 
    output sclk_o, 
    input alignwd_i, 
    input [(BUS_WIDTH - 1):0] data_loadn_i, 
    input [(BUS_WIDTH - 1):0] data_move_i, 
    input [(BUS_WIDTH - 1):0] data_direction_i, 
    output [(BUS_WIDTH - 1):0] data_cflag_o, 
    input [((2 * BUS_WIDTH) - 1):0] data_coarse_dly_i) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_DELAY_ADJUSTMENT == "DEFAULT") ? "ECLK_CENTERED" : "USER_DEFINED") ; 
    localparam GEARING_STR = ((GEARING == 5) ? "5" : ((GEARING == 4) ? "4" : "2")) ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire eclkout_w ; 
    wire [(BUS_WIDTH - 1):0] del_data_i_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKDIV #(.ECLK_DIV(GEARING_STR),
            .GSR("DISABLED")) u0_ECLKDIV (.DIVOUT(sclk_o), 
                .DIVRST(rst_i), 
                .ECLKIN(eclkout_w), 
                .SLIP(alignwd_i)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKSYNC #(.STOP_EN("ENABLE")) u0_ECLKSYNC (.ECLKIN(clk_i), 
                .ECLKOUT(eclkout_w), 
                .STOP(rst_i)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // DELAYA
            DELAYA #(.COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .EDGE_MONITOR("DISABLED"),
                    .WAIT_FOR_EDGE("DISABLED"),
                    .DEL_MODE(DEL_MODE),
                    .COARSE_DELAY_MODE("DYNAMIC")) u_data_DELAYA (// Inputs
                    .A(data_i[i]), 
                        .LOAD_N(data_loadn_i[i]), 
                        .MOVE(data_move_i[i]), 
                        .DIRECTION(data_direction_i[i]), 
                        .COARSE0(data_coarse_dly_i[((i * 2) + 0)]), 
                        .COARSE1(data_coarse_dly_i[((i * 2) + 1)]), 
                        .RANKENABLE(1'b0), 
                        .RANKSELECT(1'b0), 
                        .RANK0UPDATE(1'b0), 
                        .RANK1UPDATE(1'b0), 
                        // Outputs
                    .Z(del_data_i_w[i]), 
                        .EDETERR(), 
                        .CFLAG(data_cflag_o[i])) ; 
            if ((GEARING == 2)) 
                begin : genblk1
                    //IDDRX2
                    IDDRX2 #(.GSR("DISABLED")) u_IDDRX2 (// Inputs
                            .D(del_data_i_w[i]), 
                                .RST(rst_i), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                .ALIGNWD(alignwd_i), 
                                // Outputs
                            .Q0(data_o[((i * 4) + 0)]), 
                                .Q1(data_o[((i * 4) + 1)]), 
                                .Q2(data_o[((i * 4) + 2)]), 
                                .Q3(data_o[((i * 4) + 3)])) ; 
                end
            else
                if ((GEARING == 4)) 
                    begin : genblk1
                        // IDDRX4
                        IDDRX4 #(.GSR("DISABLED")) u_IDDRX4 (// Inputs
                                .D(del_data_i_w[i]), 
                                    .RST(rst_i), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    .ALIGNWD(alignwd_i), 
                                    // Outputs
                                .Q0(data_o[((i * 8) + 0)]), 
                                    .Q1(data_o[((i * 8) + 1)]), 
                                    .Q2(data_o[((i * 8) + 2)]), 
                                    .Q3(data_o[((i * 8) + 3)]), 
                                    .Q4(data_o[((i * 8) + 4)]), 
                                    .Q5(data_o[((i * 8) + 5)]), 
                                    .Q6(data_o[((i * 8) + 6)]), 
                                    .Q7(data_o[((i * 8) + 7)])) ; 
                    end
                else
                    if ((GEARING == 5)) 
                        begin : genblk1
                            // IDDRX5
                            IDDRX5 #(.GSR("DISABLED")) u_IDDRX5 (// Inputs
                                    .D(del_data_i_w[i]), 
                                        .RST(rst_i), 
                                        .ECLK(eclkout_w), 
                                        .SCLK(sclk_o), 
                                        .ALIGNWD(alignwd_i), 
                                        // Outputs
                                    .Q0(data_o[((i * 10) + 0)]), 
                                        .Q1(data_o[((i * 10) + 1)]), 
                                        .Q2(data_o[((i * 10) + 2)]), 
                                        .Q3(data_o[((i * 10) + 3)]), 
                                        .Q4(data_o[((i * 10) + 4)]), 
                                        .Q5(data_o[((i * 10) + 5)]), 
                                        .Q6(data_o[((i * 10) + 6)]), 
                                        .Q7(data_o[((i * 10) + 7)]), 
                                        .Q8(data_o[((i * 10) + 8)]), 
                                        .Q9(data_o[((i * 10) + 9)])) ; 
                        end
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddrx2_4_5_rx_eclk_centered_dynamic.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddrx2_4_5_rx_eclk_aligned_static_bypass.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : rx_sync.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             :
// Mod. Date             : 02.12.2019
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : <Project Name>
// File                  : lscc_init_delay_cell.v
// Title                 : 
// Dependencies          : 1.
//                       : 2.
// Description           : 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : 
// =============================================================================
module ddr_rx_ipgen_lscc_gddrx2_4_5_rx_eclk_aligned_static_bypass #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter GEARING = 2, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input sync_clk_i, 
    input sync_rst_i, 
    input sync_update_i, 
    output ready_o, 
    input alignwd_i, 
    input clk_i, 
    input [(BUS_WIDTH - 1):0] data_i, 
    output [(((2 * GEARING) * BUS_WIDTH) - 1):0] data_o, 
    output sclk_o, 
    output [8:0] dcntl_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_DELAY_ADJUSTMENT == "DEFAULT") ? "ECLK_ALIGNED" : "USER_DEFINED") ; 
    localparam GEARING_STR = ((GEARING == 5) ? "5" : ((GEARING == 4) ? "4" : "2")) ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire eclkout_w ; 
    wire stop_w ; 
    wire rst_w ; 
    wire [8:0] code_w ; 
    wire lock_w ; 
    wire dll_clk_w ; 
    wire dll_rst_w ; 
    wire [(BUS_WIDTH - 1):0] del_data_i_w ; 
    wire ready_w ; 
    wire load_n_w ; 
    wire move_w ; 
    wire dir_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKDIV #(.ECLK_DIV(GEARING_STR),
            .GSR("DISABLED")) u0_ECLKDIV (.DIVOUT(sclk_o), 
                .DIVRST(rst_w), 
                .ECLKIN(eclkout_w), 
                .SLIP(alignwd_i)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKSYNC #(.STOP_EN("ENABLE")) u0_ECLKSYNC (.ECLKIN(dll_clk_w), 
                .ECLKOUT(eclkout_w), 
                .STOP(stop_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_rx_sync u0_rx_sync (.rst(sync_rst_i), 
                .sync_clk(sync_clk_i), 
                .update(sync_update_i), 
                .dll_lock(lock_w), 
                .uddcntln(uddcntln_w), 
                .freeze(freeze_w), 
                .stop(stop_w), 
                .ddr_reset(rst_w), 
                .ready(ready_w), 
                .dll_reset(dll_rst_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    DDRDLL #(.GSR("ENABLED"),
            .ENA_ROUNDOFF("ENABLED"),
            .FORCE_MAX_DELAY("CODE_OR_LOCK_FROM_DLL_LOOP")) u0_DDRDLL (.CODE(code_w), 
                .FREEZE(freeze_w), 
                .LOCK(lock_w), 
                .CLKIN(eclkout_w), 
                .RST(dll_rst_w), 
                .DCNTL(dcntl_o), 
                .UDDCNTL_N(uddcntln_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    DLLDEL #(.ADJUST("0"),
            .ENABLE("ENABLED")) u0_DLLDEL (.CLKIN(clk_i), 
                .CLKOUT(dll_clk_w), 
                .CODE(code_w), 
                .COUT(), 
                .DIR(dir_w), 
                .LOAD_N(load_n_w), 
                .MOVE(move_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_lscc_init_delay_cell u0_lscc_init_delay_cell (.rst_n_i((~sync_rst_i)), 
                .sclk_i(sclk_o), 
                .start_i(ready_w), 
                .load_n_o(load_n_w), 
                .move_o(move_w), 
                .direction_o(dir_w), 
                .del_init_done_o(ready_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // DELAYB
            DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .DEL_MODE(DEL_MODE)) u_data_DELAYB (.A(data_i[i]), 
                        .Z(del_data_i_w[i])) ; 
            if ((GEARING == 2)) 
                begin : genblk1
                    //IDDRX2
                    IDDRX2 #(.GSR("DISABLED")) u_IDDRX2 (// Inputs
                            .D(del_data_i_w[i]), 
                                .RST(rst_w), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                .ALIGNWD(alignwd_i), 
                                // Outputs
                            .Q0(data_o[((i * 4) + 0)]), 
                                .Q1(data_o[((i * 4) + 1)]), 
                                .Q2(data_o[((i * 4) + 2)]), 
                                .Q3(data_o[((i * 4) + 3)])) ; 
                end
            else
                if ((GEARING == 4)) 
                    begin : genblk1
                        // IDDRX4
                        IDDRX4 #(.GSR("DISABLED")) u_IDDRX4 (// Inputs
                                .D(del_data_i_w[i]), 
                                    .RST(rst_w), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    .ALIGNWD(alignwd_i), 
                                    // Outputs
                                .Q0(data_o[((i * 8) + 0)]), 
                                    .Q1(data_o[((i * 8) + 1)]), 
                                    .Q2(data_o[((i * 8) + 2)]), 
                                    .Q3(data_o[((i * 8) + 3)]), 
                                    .Q4(data_o[((i * 8) + 4)]), 
                                    .Q5(data_o[((i * 8) + 5)]), 
                                    .Q6(data_o[((i * 8) + 6)]), 
                                    .Q7(data_o[((i * 8) + 7)])) ; 
                    end
                else
                    if ((GEARING == 5)) 
                        begin : genblk1
                            // IDDRX5
                            IDDRX5 #(.GSR("DISABLED")) u_IDDRX5 (// Inputs
                                    .D(del_data_i_w[i]), 
                                        .RST(rst_w), 
                                        .ECLK(eclkout_w), 
                                        .SCLK(sclk_o), 
                                        .ALIGNWD(alignwd_i), 
                                        // Outputs
                                    .Q0(data_o[((i * 10) + 0)]), 
                                        .Q1(data_o[((i * 10) + 1)]), 
                                        .Q2(data_o[((i * 10) + 2)]), 
                                        .Q3(data_o[((i * 10) + 3)]), 
                                        .Q4(data_o[((i * 10) + 4)]), 
                                        .Q5(data_o[((i * 10) + 5)]), 
                                        .Q6(data_o[((i * 10) + 6)]), 
                                        .Q7(data_o[((i * 10) + 7)]), 
                                        .Q8(data_o[((i * 10) + 8)]), 
                                        .Q9(data_o[((i * 10) + 9)])) ; 
                        end
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddrx2_4_5_rx_eclk_aligned_static_bypass.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddrx2_4_5_rx_eclk_aligned_dynamic.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : rx_sync.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             :
// Mod. Date             : 02.12.2019
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : <Project Name>
// File                  : lscc_init_delay_cell.v
// Title                 : 
// Dependencies          : 1.
//                       : 2.
// Description           : 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : 
// =============================================================================
module ddr_rx_ipgen_lscc_gddrx2_4_5_rx_eclk_aligned_dynamic #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter GEARING = 2, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input sync_rst_i, 
    input clk_i, 
    input sync_clk_i, 
    input sync_update_i, 
    output ready_o, 
    input [(BUS_WIDTH - 1):0] data_i, 
    output [(((2 * GEARING) * BUS_WIDTH) - 1):0] data_o, 
    output sclk_o, 
    input alignwd_i, 
    input clk_loadn_i, 
    input clk_move_i, 
    input clk_direction_i, 
    output clk_cflag_o, 
    input [(BUS_WIDTH - 1):0] data_loadn_i, 
    input [(BUS_WIDTH - 1):0] data_move_i, 
    input [(BUS_WIDTH - 1):0] data_direction_i, 
    output [(BUS_WIDTH - 1):0] data_cflag_o, 
    input [((2 * BUS_WIDTH) - 1):0] data_coarse_dly_i, 
    output [8:0] dcntl_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_DELAY_ADJUSTMENT == "DEFAULT") ? "ECLK_ALIGNED" : "USER_DEFINED") ; 
    localparam GEARING_STR = ((GEARING == 5) ? "5" : ((GEARING == 4) ? "4" : "2")) ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire eclkout_w ; 
    wire stop_w ; 
    wire rst_w ; 
    wire [8:0] code_w ; 
    wire lock_w ; 
    wire dll_rst_w ; 
    wire dll_clkout_w ; 
    wire [(BUS_WIDTH - 1):0] del_data_i_w ; 
    wire ready_w ; 
    wire load_n_w ; 
    wire move_w ; 
    wire dir_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKDIV #(.ECLK_DIV(GEARING_STR),
            .GSR("DISABLED")) u0_ECLKDIV (.DIVOUT(sclk_o), 
                .DIVRST(rst_w), 
                .ECLKIN(eclkout_w), 
                .SLIP(alignwd_i)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKSYNC #(.STOP_EN("ENABLE")) u0_ECLKSYNC (.ECLKIN(dll_clkout_w), 
                .ECLKOUT(eclkout_w), 
                .STOP(stop_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_rx_sync u1_rx_sync (.rst(sync_rst_i), 
                .sync_clk(sync_clk_i), 
                .update(sync_update_i), 
                .dll_lock(lock_w), 
                .uddcntln(uddcntln_w), 
                .freeze(freeze_w), 
                .stop(stop_w), 
                .ddr_reset(rst_w), 
                .ready(ready_w), 
                .dll_reset(dll_rst_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    DDRDLL #(.GSR("ENABLED"),
            .ENA_ROUNDOFF("ENABLED"),
            .FORCE_MAX_DELAY("CODE_OR_LOCK_FROM_DLL_LOOP")) u0_DDRDLL (.CODE(code_w), 
                .FREEZE(freeze_w), 
                .LOCK(lock_w), 
                .CLKIN(eclkout_w), 
                .RST(dll_rst_w), 
                .DCNTL(dcntl_o), 
                .UDDCNTL_N(uddcntln_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    DLLDEL #(.ADJUST("0"),
            .ENABLE("ENABLED")) u0_DLLDEL (.CLKIN(clk_i), 
                .CLKOUT(dll_clkout_w), 
                .CODE(code_w), 
                .COUT(clk_cflag_o), 
                .DIR(((ready_o == 1'h1) ? clk_direction_i : dir_w)), 
                .LOAD_N(((ready_o == 1'h1) ? clk_loadn_i : load_n_w)), 
                .MOVE(((ready_o == 1'h1) ? clk_move_i : move_w))) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_lscc_init_delay_cell u0_lscc_init_delay_cell (.rst_n_i((~sync_rst_i)), 
                .sclk_i(sclk_o), 
                .start_i(ready_w), 
                .load_n_o(load_n_w), 
                .move_o(move_w), 
                .direction_o(dir_w), 
                .del_init_done_o(ready_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // DELAYA
            DELAYA #(.COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .EDGE_MONITOR("DISABLED"),
                    .WAIT_FOR_EDGE("DISABLED"),
                    .DEL_MODE(DEL_MODE),
                    .COARSE_DELAY_MODE("DYNAMIC")) u_data_DELAYA (// Inputs
                    .A(data_i[i]), 
                        .LOAD_N(data_loadn_i[i]), 
                        .MOVE(data_move_i[i]), 
                        .DIRECTION(data_direction_i[i]), 
                        .COARSE0(data_coarse_dly_i[((i * 2) + 0)]), 
                        .COARSE1(data_coarse_dly_i[((i * 2) + 1)]), 
                        .RANKSELECT(1'h0), 
                        .RANKENABLE(1'h0), 
                        .RANK0UPDATE(1'h0), 
                        .RANK1UPDATE(1'h0), 
                        // Outputs
                    .Z(del_data_i_w[i]), 
                        .EDETERR(), 
                        .CFLAG(data_cflag_o[i])) ; 
            if ((GEARING == 2)) 
                begin : genblk1
                    //IDDRX2
                    IDDRX2 #(.GSR("DISABLED")) u_IDDRX2 (// Inputs
                            .D(del_data_i_w[i]), 
                                .RST(rst_w), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                .ALIGNWD(alignwd_i), 
                                // Outputs
                            .Q0(data_o[((i * 4) + 0)]), 
                                .Q1(data_o[((i * 4) + 1)]), 
                                .Q2(data_o[((i * 4) + 2)]), 
                                .Q3(data_o[((i * 4) + 3)])) ; 
                end
            else
                if ((GEARING == 4)) 
                    begin : genblk1
                        // IDDRX4
                        IDDRX4 #(.GSR("DISABLED")) u_IDDRX4 (// Inputs
                                .D(del_data_i_w[i]), 
                                    .RST(rst_w), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    .ALIGNWD(alignwd_i), 
                                    // Outputs
                                .Q0(data_o[((i * 8) + 0)]), 
                                    .Q1(data_o[((i * 8) + 1)]), 
                                    .Q2(data_o[((i * 8) + 2)]), 
                                    .Q3(data_o[((i * 8) + 3)]), 
                                    .Q4(data_o[((i * 8) + 4)]), 
                                    .Q5(data_o[((i * 8) + 5)]), 
                                    .Q6(data_o[((i * 8) + 6)]), 
                                    .Q7(data_o[((i * 8) + 7)])) ; 
                    end
                else
                    if ((GEARING == 5)) 
                        begin : genblk1
                            // IDDRX5
                            IDDRX5 #(.GSR("DISABLED")) u_IDDRX5 (// Inputs
                                    .D(del_data_i_w[i]), 
                                        .RST(rst_w), 
                                        .ECLK(eclkout_w), 
                                        .SCLK(sclk_o), 
                                        .ALIGNWD(alignwd_i), 
                                        // Outputs
                                    .Q0(data_o[((i * 10) + 0)]), 
                                        .Q1(data_o[((i * 10) + 1)]), 
                                        .Q2(data_o[((i * 10) + 2)]), 
                                        .Q3(data_o[((i * 10) + 3)]), 
                                        .Q4(data_o[((i * 10) + 4)]), 
                                        .Q5(data_o[((i * 10) + 5)]), 
                                        .Q6(data_o[((i * 10) + 6)]), 
                                        .Q7(data_o[((i * 10) + 7)]), 
                                        .Q8(data_o[((i * 10) + 8)]), 
                                        .Q9(data_o[((i * 10) + 9)])) ; 
                        end
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddrx2_4_5_rx_eclk_aligned_dynamic.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddr_tx_sclk_centered_static_bypass.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddr_tx_sclk_centered_static_bypass #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input rst_i, 
    input clk_i, 
    input clk90_i, 
    input [((2 * BUS_WIDTH) - 1):0] data_i, 
    output [(BUS_WIDTH - 1):0] data_o, 
    output clk_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_PATH_DELAY == "BYPASS") ? "SCLK_CENTERED" : "USER_DEFINED") ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire [(BUS_WIDTH - 1):0] del_data_o_w ; // Data before DELAYB. 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    // ODDRX1
    ODDRX1 u_clk_ODDRX1 (// Inputs
            .D0(1'h1), 
                .D1(1'h0), 
                .SCLK(clk90_i), 
                .RST(rst_i), 
                // Outputs
            .Q(clk_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            if ((DATA_PATH_DELAY == "BYPASS")) 
                begin : DATA_DEL_BYPASS
                    assign data_o[i] = del_data_o_w[i] ; 
                end
            else
                begin : DATA_DEL_STATIC
                    // DELAYB
                    DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                            .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                            .DEL_MODE(DEL_MODE)) u_DELAYB (// Always "USER_DEFINED".
                            .A(del_data_o_w[i]), 
                                .Z(data_o[i])) ; 
                end
            // ODDRX1
            ODDRX1 u_data_ODDRX1 (// Inputs
                    .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                        .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                        .SCLK(clk_i), 
                        .RST(rst_i), 
                        // Outputs
                    .Q(del_data_o_w[i])) ; 
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddr_tx_sclk_centered_static_bypass.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddr_tx_sclk_centered_dynamic.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddr_tx_sclk_centered_dynamic #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input rst_i, 
    input clk_i, 
    input clk90_i, 
    input [((2 * BUS_WIDTH) - 1):0] data_i, 
    input [(BUS_WIDTH - 1):0] data_loadn_i, 
    input [(BUS_WIDTH - 1):0] data_move_i, 
    input [(BUS_WIDTH - 1):0] data_direction_i, 
    output [(BUS_WIDTH - 1):0] data_cflag_o, 
    input [((2 * BUS_WIDTH) - 1):0] data_coarse_dly_i, 
    output [(BUS_WIDTH - 1):0] data_o, 
    output clk_o) ;
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire [(BUS_WIDTH - 1):0] del_data_o_w ; // Data before DELAYA.
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    // ODDRX1
    ODDRX1 u_clk_ODDRX1 (// Inputs
            .D0(1'h1), 
                .D1(1'h0), 
                .SCLK(clk90_i), 
                .RST(rst_i), 
                // Outputs
            .Q(clk_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // DELAYA
            DELAYA #(.DEL_MODE("USER_DEFINED"),
                    .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .COARSE_DELAY_MODE("DYNAMIC"),
                    .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .EDGE_MONITOR("DISABLED"),
                    .WAIT_FOR_EDGE("DISABLED")) u_DELAYA (// Inputs
                    .A(del_data_o_w[i]), 
                        .LOAD_N(data_loadn_i[i]), 
                        .MOVE(data_move_i[i]), 
                        .DIRECTION(data_direction_i[i]), 
                        .COARSE0(data_coarse_dly_i[((i * 2) + 0)]), 
                        .COARSE1(data_coarse_dly_i[((i * 2) + 1)]), 
                        .RANKENABLE(1'b0), 
                        .RANKSELECT(1'b0), 
                        .RANK0UPDATE(1'b0), 
                        .RANK1UPDATE(1'b0), 
                        // Outputs
                    .Z(data_o[i]), 
                        .EDETERR(), 
                        .CFLAG(data_cflag_o[i])) ; 
            // ODDRX1
            ODDRX1 u_data_ODDRX1 (// Inputs
                    .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                        .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                        .SCLK(clk_i), 
                        .RST(rst_i), 
                        // Outputs
                    .Q(del_data_o_w[i])) ; 
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddr_tx_sclk_centered_dynamic.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddr_tx_sclk_aligned_static_bypass.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddr_tx_sclk_aligned_static_bypass #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input rst_i, 
    input clk_i, 
    input [((2 * BUS_WIDTH) - 1):0] data_i, 
    output [(BUS_WIDTH - 1):0] data_o, 
    output clk_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_PATH_DELAY == "BYPASS") ? "SCLK_ALIGNED" : "USER_DEFINED") ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire [(BUS_WIDTH - 1):0] del_data_o_w ; // Data before DELAYB.
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    // ODDRX1
    ODDRX1 u_clk_ODDRX1 (// Inputs
            .D0(1'h1), 
                .D1(1'h0), 
                .SCLK(clk_i), 
                .RST(rst_i), 
                // Outputs
            .Q(clk_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            if ((DATA_PATH_DELAY == "BYPASS")) 
                begin : DATA_DEL_BYPASS
                    assign data_o[i] = del_data_o_w[i] ; 
                end
            else
                begin : DATA_DEL_STATIC
                    // DELAYB
                    DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                            .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                            .DEL_MODE(DEL_MODE)) u_DELAYB (// Always "USER_DEFINED".
                            .A(del_data_o_w[i]), 
                                .Z(data_o[i])) ; 
                end
            // ODDRX1
            ODDRX1 u_data_ODDRX1 (// Inputs
                    .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                        .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                        .SCLK(clk_i), 
                        .RST(rst_i), 
                        // Outputs
                    .Q(del_data_o_w[i])) ; 
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddr_tx_sclk_aligned_static_bypass.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddrx2_4_5_tx_eclk_centered_dynamic.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : 
// File                  : gddr_sync.v
// Title                 : 
// Dependencies          :
// Description           : 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 03.20.2018
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_centered_dynamic #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter GEARING = 2, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input [((2 * BUS_WIDTH) - 1):0] data_coarse_dly_i, 
    input [1:0] clk_coarse_dly_i, 
    input [(BUS_WIDTH - 1):0] data_move_i, 
    input clk_move_i, 
    input [(BUS_WIDTH - 1):0] data_loadn_i, 
    input clk_loadn_i, 
    input [(BUS_WIDTH - 1):0] data_direction_i, 
    input clk_direction_i, 
    output [(BUS_WIDTH - 1):0] data_cflag_o, 
    output clk_cflag_o, 
    input eclk_i, 
    input eclk90_i, 
    input [(((GEARING * BUS_WIDTH) * 2) - 1):0] data_i, 
    input sync_clk_i, 
    input sync_rst_i, 
    input sync_start_i, 
    output ready_o, 
    output [(BUS_WIDTH - 1):0] data_o, 
    output clk_o, 
    output sclk_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam GEARING_STR = ((GEARING == 5) ? "5" : ((GEARING == 4) ? "4" : "2")) ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire eclkout_w ; 
    wire rst_w ; 
    wire stop_w ; 
    wire del_clk_o_w ; 
    wire [(BUS_WIDTH - 1):0] del_data_o_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKDIV #(.ECLK_DIV(GEARING_STR),
            .GSR("DISABLED")) u0_ECLKDIV (.DIVOUT(sclk_o), 
                .DIVRST(rst_w), 
                .ECLKIN(eclkout_w), 
                .SLIP(1'b0)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKSYNC #(.STOP_EN("ENABLE")) u0_ECLKSYNC (.ECLKIN(eclk_i), 
                .ECLKOUT(eclkout_w), 
                .STOP(stop_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_gddr_sync u1_gddr_sync (.rst(sync_rst_i), 
                .sync_clk(sync_clk_i), 
                .start(sync_start_i), 
                .stop(stop_w), 
                .ddr_reset(rst_w), 
                .ready(ready_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        // DELAYA
        DELAYA #(.COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                .EDGE_MONITOR("DISABLED"),
                .WAIT_FOR_EDGE("DISABLED"),
                .DEL_MODE("USER_DEFINED"),
                .COARSE_DELAY_MODE("DYNAMIC")) u_clock_DELAYA (// Inputs
                .A(del_clk_o_w), 
                    .LOAD_N(clk_loadn_i), 
                    .MOVE(clk_move_i), 
                    .DIRECTION(clk_direction_i), 
                    .COARSE0(clk_coarse_dly_i[0]), 
                    .COARSE1(clk_coarse_dly_i[1]), 
                    .RANKENABLE(1'b0), 
                    .RANKSELECT(1'b0), 
                    .RANK0UPDATE(1'b0), 
                    .RANK1UPDATE(1'b0), 
                    // Outputs                
                .Z(clk_o), 
                    .EDETERR(), 
                    .CFLAG(clk_cflag_o)) ; 
        if ((GEARING == 2)) 
            begin : genblk1
                // ODDRX2
                ODDRX2 u_clock_ODDRX2 (// Inputs
                        .D0(1'h1), 
                            .D1(1'h0), 
                            .D2(1'h1), 
                            .D3(1'h0), 
                            .RST(rst_w), 
                            .ECLK(eclk90_i), 
                            .SCLK(sclk_o), 
                            // Outputs
                        .Q(del_clk_o_w)) ; 
            end
        else
            if ((GEARING == 4)) 
                begin : genblk1
                    // ODDRX4
                    ODDRX4 u_clock_ODDRX4 (// Inputs
                            .D0(1'h1), 
                                .D1(1'h0), 
                                .D2(1'h1), 
                                .D3(1'h0), 
                                .D4(1'h1), 
                                .D5(1'h0), 
                                .D6(1'h1), 
                                .D7(1'h0), 
                                .RST(rst_w), 
                                .ECLK(eclk90_i), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_clk_o_w)) ; 
                end
            else
                if ((GEARING == 5)) 
                    begin : genblk1
                        // ODDRX5
                        ODDRX5 u_clock_ODDRX5 (// Inputs
                                .D0(1'h1), 
                                    .D1(1'h0), 
                                    .D2(1'h1), 
                                    .D3(1'h0), 
                                    .D4(1'h1), 
                                    .D5(1'h0), 
                                    .D6(1'h1), 
                                    .D7(1'h0), 
                                    .D8(1'h1), 
                                    .D9(1'h0), 
                                    .RST(rst_w), 
                                    .ECLK(eclk90_i), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_clk_o_w)) ; 
                    end
    endgenerate
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // DELAYA
            DELAYA #(.COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .EDGE_MONITOR("DISABLED"),
                    .WAIT_FOR_EDGE("DISABLED"),
                    .DEL_MODE("USER_DEFINED"),
                    .COARSE_DELAY_MODE("DYNAMIC")) u_data_DELAYA (// Inputs
                    .A(del_data_o_w[i]), 
                        .LOAD_N(data_loadn_i[i]), 
                        .MOVE(data_move_i[i]), 
                        .DIRECTION(data_direction_i[i]), 
                        .COARSE0(data_coarse_dly_i[((i * 2) + 0)]), 
                        .COARSE1(data_coarse_dly_i[((i * 2) + 1)]), 
                        .RANKENABLE(1'b0), 
                        .RANKSELECT(1'b0), 
                        .RANK0UPDATE(1'b0), 
                        .RANK1UPDATE(1'b0), 
                        // Outputs
                    .Z(data_o[i]), 
                        .EDETERR(), 
                        .CFLAG(data_cflag_o[i])) ; 
            if ((GEARING == 2)) 
                begin : genblk1
                    // ODDRX2
                    ODDRX2 u_data_ODDRX2 (// Inputs
                            .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                .RST(rst_w), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_data_o_w[i])) ; 
                end
            else
                if ((GEARING == 4)) 
                    begin : genblk1
                        // ODDRX4
                        ODDRX4 u_data_ODDRX4 (// Inputs
                                .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                    .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                    .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                    .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                    .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                    .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                    .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                    .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                    .RST(rst_w), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_data_o_w[i])) ; 
                    end
                else
                    if ((GEARING == 5)) 
                        begin : genblk1
                            // ODDRX5
                            ODDRX5 u_data_ODDRX5 (// Inputs
                                    .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                        .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                        .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                        .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                        .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                        .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                        .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                        .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                        .D8(data_i[(i + (BUS_WIDTH * 8))]), 
                                        .D9(data_i[(i + (BUS_WIDTH * 9))]), 
                                        .RST(rst_w), 
                                        .ECLK(eclkout_w), 
                                        .SCLK(sclk_o), 
                                        // Outputs
                                    .Q(del_data_o_w[i])) ; 
                        end
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddrx2_4_5_tx_eclk_centered_dynamic.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddr_tx_sclk_aligned_dynamic.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddr_tx_sclk_aligned_dynamic #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input rst_i, 
    input clk_i, 
    input [((2 * BUS_WIDTH) - 1):0] data_i, 
    input [((2 * BUS_WIDTH) - 1):0] data_coarse_dly_i, 
    input [(BUS_WIDTH - 1):0] data_move_i, 
    input [(BUS_WIDTH - 1):0] data_loadn_i, 
    input [(BUS_WIDTH - 1):0] data_direction_i, 
    output [(BUS_WIDTH - 1):0] data_cflag_o, 
    output [(BUS_WIDTH - 1):0] data_o, 
    output clk_o) ;
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire [(BUS_WIDTH - 1):0] del_data_o_w ; // Data before DELAYA.
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    // ODDRX1
    ODDRX1 u_clk_ODDRX1 (// Inputs
            .D0(1'h1), 
                .D1(1'h0), 
                .SCLK(clk_i), 
                .RST(rst_i), 
                // Outputs
            .Q(clk_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // DELAYA
            DELAYA #(.DEL_MODE("USER_DEFINED"),
                    .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .COARSE_DELAY_MODE("DYNAMIC"),
                    .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .EDGE_MONITOR("DISABLED"),
                    .WAIT_FOR_EDGE("DISABLED")) u_DELAYA (// Inputs
                    .A(del_data_o_w[i]), 
                        .LOAD_N(data_loadn_i[i]), 
                        .MOVE(data_move_i[i]), 
                        .DIRECTION(data_direction_i[i]), 
                        .COARSE0(data_coarse_dly_i[((i * 2) + 0)]), 
                        .COARSE1(data_coarse_dly_i[((i * 2) + 1)]), 
                        .RANKENABLE(1'b0), 
                        .RANKSELECT(1'b0), 
                        .RANK0UPDATE(1'b0), 
                        .RANK1UPDATE(1'b0), 
                        // Outputs
                    .Z(data_o[i]), 
                        .EDETERR(), 
                        .CFLAG(data_cflag_o[i])) ; 
            // ODDRX1
            ODDRX1 u_data_ODDRX1 (// Inputs
                    .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                        .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                        .SCLK(clk_i), 
                        .RST(rst_i), 
                        // Outputs
                    .Q(del_data_o_w[i])) ; 
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddr_tx_sclk_aligned_dynamic.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddrx2_4_5_tx_eclk_centered_static_bypass.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : 
// File                  : gddr_sync.v
// Title                 : 
// Dependencies          :
// Description           : 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 03.20.2018
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_centered_static_bypass #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter GEARING = 2, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input sync_rst_i, 
    input eclk_i, 
    input eclk90_i, 
    input [(((GEARING * BUS_WIDTH) * 2) - 1):0] data_i, 
    input sync_clk_i, 
    input sync_start_i, 
    output ready_o, 
    output [(BUS_WIDTH - 1):0] data_o, 
    output clk_o, 
    output sclk_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_DELAY_ADJUSTMENT == "DEFAULT") ? "ECLK_CENTERED" : "USER_DEFINED") ; 
    localparam GEARING_STR = ((GEARING == 5) ? "5" : ((GEARING == 4) ? "4" : "2")) ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire eclkout_w ; 
    wire rst_w ; 
    wire stop_w ; 
    wire del_clk_o_w ; 
    wire [(BUS_WIDTH - 1):0] del_data_o_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKDIV #(.ECLK_DIV(GEARING_STR),
            .GSR("DISABLED")) u0_ECLKDIV (.DIVOUT(sclk_o), 
                .DIVRST(rst_w), 
                .ECLKIN(eclkout_w), 
                .SLIP(1'b0)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKSYNC #(.STOP_EN("ENABLE")) u0_ECLKSYNC (.ECLKIN(eclk_i), 
                .ECLKOUT(eclkout_w), 
                .STOP(stop_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_gddr_sync u1_gddr_sync (.rst(sync_rst_i), 
                .sync_clk(sync_clk_i), 
                .start(sync_start_i), 
                .stop(stop_w), 
                .ddr_reset(rst_w), 
                .ready(ready_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        if ((DATA_PATH_DELAY == "BYPASS")) 
            begin : CLOCK_DEL_BYPASS
                assign clk_o = del_clk_o_w ; 
            end
        else
            begin : CLOCK_DEL_STATIC
                // DELAYB
                DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                        .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                        .DEL_MODE(DEL_MODE)) u_clock_DELAYB (// Always "USER_DEFINED".
                        .A(del_clk_o_w), 
                            .Z(clk_o)) ; 
            end
        if ((GEARING == 2)) 
            begin : genblk2
                // ODDRX2
                ODDRX2 u_clock_ODDRX2 (// Inputs
                        .D0(1'h1), 
                            .D1(1'h0), 
                            .D2(1'h1), 
                            .D3(1'h0), 
                            .RST(rst_w), 
                            .ECLK(eclk90_i), 
                            .SCLK(sclk_o), 
                            // Outputs
                        .Q(del_clk_o_w)) ; 
            end
        else
            if ((GEARING == 4)) 
                begin : genblk2
                    // ODDRX4
                    ODDRX4 u_clock_ODDRX4 (// Inputs
                            .D0(1'h1), 
                                .D1(1'h0), 
                                .D2(1'h1), 
                                .D3(1'h0), 
                                .D4(1'h1), 
                                .D5(1'h0), 
                                .D6(1'h1), 
                                .D7(1'h0), 
                                .RST(rst_w), 
                                .ECLK(eclk90_i), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_clk_o_w)) ; 
                end
            else
                if ((GEARING == 5)) 
                    begin : genblk2
                        // ODDRX5
                        ODDRX5 u_clock_ODDRX5 (// Inputs
                                .D0(1'h1), 
                                    .D1(1'h0), 
                                    .D2(1'h1), 
                                    .D3(1'h0), 
                                    .D4(1'h1), 
                                    .D5(1'h0), 
                                    .D6(1'h1), 
                                    .D7(1'h0), 
                                    .D8(1'h1), 
                                    .D9(1'h0), 
                                    .RST(rst_w), 
                                    .ECLK(eclk90_i), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_clk_o_w)) ; 
                    end
    endgenerate
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            if ((DATA_PATH_DELAY == "BYPASS")) 
                begin : DATA_DEL_BYPASS
                    assign data_o[i] = del_data_o_w[i] ; 
                end
            else
                begin : DATA_DEL_STATIC
                    // DELAYB
                    DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                            .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                            .DEL_MODE(DEL_MODE)) u_data_DELAYB (// Always "USER_DEFINED".
                            .A(del_data_o_w[i]), 
                                .Z(data_o[i])) ; 
                end
            if ((GEARING == 2)) 
                begin : genblk2
                    // ODDRX2
                    ODDRX2 u_data_ODDRX2 (// Inputs
                            .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                .RST(rst_w), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_data_o_w[i])) ; 
                end
            else
                if ((GEARING == 4)) 
                    begin : genblk2
                        // ODDRX4
                        ODDRX4 u_data_ODDRX4 (// Inputs
                                .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                    .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                    .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                    .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                    .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                    .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                    .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                    .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                    .RST(rst_w), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_data_o_w[i])) ; 
                    end
                else
                    if ((GEARING == 5)) 
                        begin : genblk2
                            // ODDRX5
                            ODDRX5 u_data_ODDRX5 (// Inputs
                                    .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                        .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                        .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                        .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                        .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                        .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                        .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                        .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                        .D8(data_i[(i + (BUS_WIDTH * 8))]), 
                                        .D9(data_i[(i + (BUS_WIDTH * 9))]), 
                                        .RST(rst_w), 
                                        .ECLK(eclkout_w), 
                                        .SCLK(sclk_o), 
                                        // Outputs
                                    .Q(del_data_o_w[i])) ; 
                        end
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddrx2_4_5_tx_eclk_centered_static_bypass.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddrx2_4_5_tx_eclk_centered_dynamic_tri_state_control.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : 
// File                  : gddr_sync.v
// Title                 : 
// Dependencies          :
// Description           : 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 03.20.2018
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_centered_dynamic_tri_state_control #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter GEARING = 2, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input [((2 * BUS_WIDTH) - 1):0] data_coarse_dly_i, 
    input [1:0] clk_coarse_dly_i, 
    input [(BUS_WIDTH - 1):0] data_move_i, 
    input clk_move_i, 
    input [(BUS_WIDTH - 1):0] data_loadn_i, 
    input clk_loadn_i, 
    input [(BUS_WIDTH - 1):0] data_direction_i, 
    input clk_direction_i, 
    output [(BUS_WIDTH - 1):0] data_cflag_o, 
    output clk_cflag_o, 
    input outen_n_i, 
    input eclk_i, 
    input eclk90_i, 
    input [(((GEARING * BUS_WIDTH) * 2) - 1):0] data_i, 
    input sync_clk_i, 
    input sync_rst_i, 
    input sync_start_i, 
    output ready_o, 
    output [(BUS_WIDTH - 1):0] data_o, 
    output clk_o, 
    output sclk_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam GEARING_STR = ((GEARING == 5) ? "5" : ((GEARING == 4) ? "4" : "2")) ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire [(BUS_WIDTH - 1):0] data_q_obz_i_w ; 
    wire clock_q_obz_i_w ; 
    wire outen_n_i_w ; 
    wire eclkout_w ; 
    wire rst_w ; 
    wire stop_w ; 
    wire [(BUS_WIDTH - 1):0] outen_n_w ; 
    wire outen_n_clk_w ; 
    wire del_clk_o_w ; 
    wire [(BUS_WIDTH - 1):0] del_data_o_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKDIV #(.ECLK_DIV(GEARING_STR),
            .GSR("DISABLED")) u0_ECLKDIV (.DIVOUT(sclk_o), 
                .DIVRST(rst_w), 
                .ECLKIN(eclkout_w), 
                .SLIP(1'b0)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKSYNC #(.STOP_EN("ENABLE")) u0_ECLKSYNC (.ECLKIN(eclk_i), 
                .ECLKOUT(eclkout_w), 
                .STOP(stop_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_gddr_sync u1_gddr_sync (.rst(sync_rst_i), 
                .sync_clk(sync_clk_i), 
                .start(sync_start_i), 
                .stop(stop_w), 
                .ddr_reset(rst_w), 
                .ready(ready_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    // FD1P3BX
    FD1P3BX #(.GSR("ENABLED")) u_FD1P3BX (// Inputs
            .D(outen_n_i), 
                .CK(sclk_o), 
                .SP(1'h1), 
                .PD(rst_w), 
                // Outputs
            .Q(outen_n_i_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        // OBZ
        OBZ u_clock_OBZ (.I(clock_q_obz_i_w), 
                    .T(outen_n_i_w), 
                    .O(clk_o)) ; 
        // DELAYA
        DELAYA #(.COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                .EDGE_MONITOR("DISABLED"),
                .WAIT_FOR_EDGE("DISABLED"),
                .DEL_MODE("USER_DEFINED"),
                .COARSE_DELAY_MODE("DYNAMIC")) u_clock_DELAYA (// Inputs
                .A(del_clk_o_w), 
                    .LOAD_N(clk_loadn_i), 
                    .MOVE(clk_move_i), 
                    .DIRECTION(clk_direction_i), 
                    .COARSE0(clk_coarse_dly_i[0]), 
                    .COARSE1(clk_coarse_dly_i[1]), 
                    .RANKENABLE(1'b0), 
                    .RANKSELECT(1'b0), 
                    .RANK0UPDATE(1'b0), 
                    .RANK1UPDATE(1'b0), 
                    // Outputs                
                .Z(clock_q_obz_i_w), 
                    .EDETERR(), 
                    .CFLAG(clk_cflag_o)) ; 
        if ((GEARING == 2)) 
            begin : genblk1
                // ODDRX2
                ODDRX2 u_clock_ODDRX2 (// Inputs
                        .D0(1'h1), 
                            .D1(1'h0), 
                            .D2(1'h1), 
                            .D3(1'h0), 
                            .RST(rst_w), 
                            .ECLK(eclk90_i), 
                            .SCLK(sclk_o), 
                            // Outputs
                        .Q(del_clk_o_w)) ; 
            end
        else
            if ((GEARING == 4)) 
                begin : genblk1
                    // ODDRX4
                    ODDRX4 u_clock_ODDRX4 (// Inputs
                            .D0(1'h1), 
                                .D1(1'h0), 
                                .D2(1'h1), 
                                .D3(1'h0), 
                                .D4(1'h1), 
                                .D5(1'h0), 
                                .D6(1'h1), 
                                .D7(1'h0), 
                                .RST(rst_w), 
                                .ECLK(eclk90_i), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_clk_o_w)) ; 
                end
            else
                if ((GEARING == 5)) 
                    begin : genblk1
                        // ODDRX5
                        ODDRX5 u_clock_ODDRX5 (// Inputs
                                .D0(1'h1), 
                                    .D1(1'h0), 
                                    .D2(1'h1), 
                                    .D3(1'h0), 
                                    .D4(1'h1), 
                                    .D5(1'h0), 
                                    .D6(1'h1), 
                                    .D7(1'h0), 
                                    .D8(1'h1), 
                                    .D9(1'h0), 
                                    .RST(rst_w), 
                                    .ECLK(eclk90_i), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_clk_o_w)) ; 
                    end
    endgenerate
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // OBZ
            OBZ u_data_OBZ (.I(data_q_obz_i_w[i]), 
                        .T(outen_n_i_w), 
                        .O(data_o[i])) ; 
            // DELAYA
            DELAYA #(.COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .EDGE_MONITOR("DISABLED"),
                    .WAIT_FOR_EDGE("DISABLED"),
                    .DEL_MODE("USER_DEFINED"),
                    .COARSE_DELAY_MODE("DYNAMIC")) u_data_DELAYA (// Inputs
                    .A(del_data_o_w[i]), 
                        .LOAD_N(data_loadn_i[i]), 
                        .MOVE(data_move_i[i]), 
                        .DIRECTION(data_direction_i[i]), 
                        .COARSE0(data_coarse_dly_i[((i * 2) + 0)]), 
                        .COARSE1(data_coarse_dly_i[((i * 2) + 1)]), 
                        .RANKENABLE(1'b0), 
                        .RANKSELECT(1'b0), 
                        .RANK0UPDATE(1'b0), 
                        .RANK1UPDATE(1'b0), 
                        // Outputs
                    .Z(data_q_obz_i_w[i]), 
                        .EDETERR(), 
                        .CFLAG(data_cflag_o[i])) ; 
            if ((GEARING == 2)) 
                begin : genblk1
                    // ODDRX2
                    ODDRX2 u_data_ODDRX2 (// Inputs
                            .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                .RST(rst_w), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_data_o_w[i])) ; 
                end
            else
                if ((GEARING == 4)) 
                    begin : genblk1
                        // ODDRX4
                        ODDRX4 u_data_ODDRX4 (// Inputs
                                .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                    .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                    .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                    .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                    .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                    .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                    .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                    .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                    .RST(rst_w), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_data_o_w[i])) ; 
                    end
                else
                    if ((GEARING == 5)) 
                        begin : genblk1
                            // ODDRX5
                            ODDRX5 u_data_ODDRX5 (// Inputs
                                    .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                        .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                        .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                        .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                        .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                        .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                        .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                        .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                        .D8(data_i[(i + (BUS_WIDTH * 8))]), 
                                        .D9(data_i[(i + (BUS_WIDTH * 9))]), 
                                        .RST(rst_w), 
                                        .ECLK(eclkout_w), 
                                        .SCLK(sclk_o), 
                                        // Outputs
                                    .Q(del_data_o_w[i])) ; 
                        end
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddrx2_4_5_tx_eclk_centered_dynamic_tri_state_control.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddrx2_4_5_tx_eclk_aligned_dynamic.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_aligned_dynamic #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter GEARING = 2, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input rst_i, 
    input outen_n_i, 
    input [((2 * BUS_WIDTH) - 1):0] data_coarse_dly_i, 
    input [1:0] clk_coarse_dly_i, 
    input [(BUS_WIDTH - 1):0] data_move_i, 
    input clk_move_i, 
    input [(BUS_WIDTH - 1):0] data_loadn_i, 
    input clk_loadn_i, 
    input [(BUS_WIDTH - 1):0] data_direction_i, 
    input clk_direction_i, 
    output [(BUS_WIDTH - 1):0] data_cflag_o, 
    output clk_cflag_o, 
    input clk_i, 
    input [(((GEARING * BUS_WIDTH) * 2) - 1):0] data_i, 
    output [(BUS_WIDTH - 1):0] data_o, 
    output clk_o, 
    output sclk_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam GEARING_STR = ((GEARING == 5) ? "5" : ((GEARING == 4) ? "4" : "2")) ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire eclkout_w ; 
    wire outen_n_i_w ; 
    wire [(BUS_WIDTH - 1):0] data_q_obz_i_w ; 
    wire clock_q_obz_i_w ; 
    wire del_clk_o_w ; 
    wire [(BUS_WIDTH - 1):0] del_data_o_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKDIV #(.ECLK_DIV(GEARING_STR),
            .GSR("DISABLED")) u0_ECLKDIV (.DIVOUT(sclk_o), 
                .DIVRST(rst_i), 
                .ECLKIN(eclkout_w), 
                .SLIP(1'b0)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKSYNC #(.STOP_EN("ENABLE")) u0_ECLKSYNC (.ECLKIN(clk_i), 
                .ECLKOUT(eclkout_w), 
                .STOP(rst_i)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    // FD1P3BX
    FD1P3BX #(.GSR("ENABLED")) u_FD1P3BX (// Inputs
            .D(outen_n_i), 
                .CK(sclk_o), 
                .SP(1'h1), 
                .PD(rst_i), 
                // Outputs
            .Q(outen_n_i_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        // OBZ
        OBZ u_clock_OBZ (.I(clock_q_obz_i_w), 
                    .T(outen_n_i_w), 
                    .O(clk_o)) ; 
        // DELAYA
        DELAYA #(.COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                .EDGE_MONITOR("DISABLED"),
                .WAIT_FOR_EDGE("DISABLED"),
                .DEL_MODE("USER_DEFINED"),
                .COARSE_DELAY_MODE("DYNAMIC")) u_clock_DELAYA (// Inputs
                .A(del_clk_o_w), 
                    .LOAD_N(clk_loadn_i), 
                    .MOVE(clk_move_i), 
                    .DIRECTION(clk_direction_i), 
                    .COARSE0(clk_coarse_dly_i[0]), 
                    .COARSE1(clk_coarse_dly_i[1]), 
                    .RANKENABLE(1'b0), 
                    .RANKSELECT(1'b0), 
                    .RANK0UPDATE(1'b0), 
                    .RANK1UPDATE(1'b0), 
                    // Outputs
                .Z(clock_q_obz_i_w), 
                    .EDETERR(), 
                    .CFLAG(clk_cflag_o)) ; 
        if ((GEARING == 2)) 
            begin : genblk1
                // ODDRX2
                ODDRX2 u_clock_ODDRX2 (// Inputs
                        .D0(1'h1), 
                            .D1(1'h0), 
                            .D2(1'h1), 
                            .D3(1'h0), 
                            .RST(rst_i), 
                            .ECLK(eclkout_w), 
                            .SCLK(sclk_o), 
                            // Outputs
                        .Q(del_clk_o_w)) ; 
            end
        else
            if ((GEARING == 4)) 
                begin : genblk1
                    // ODDRX4
                    ODDRX4 u_clock_ODDRX4 (// Inputs
                            .D0(1'h1), 
                                .D1(1'h0), 
                                .D2(1'h1), 
                                .D3(1'h0), 
                                .D4(1'h1), 
                                .D5(1'h0), 
                                .D6(1'h1), 
                                .D7(1'h0), 
                                .RST(rst_i), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_clk_o_w)) ; 
                end
            else
                if ((GEARING == 5)) 
                    begin : genblk1
                        // ODDRX5
                        ODDRX5 u_clock_ODDRX5 (// Inputs
                                .D0(1'h1), 
                                    .D1(1'h0), 
                                    .D2(1'h1), 
                                    .D3(1'h0), 
                                    .D4(1'h1), 
                                    .D5(1'h0), 
                                    .D6(1'h1), 
                                    .D7(1'h0), 
                                    .D8(1'h1), 
                                    .D9(1'h0), 
                                    .RST(rst_i), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_clk_o_w)) ; 
                    end
    endgenerate
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // OBZ
            OBZ u_data_OBZ (.I(data_q_obz_i_w[i]), 
                        .T(outen_n_i_w), 
                        .O(data_o[i])) ; 
            // DELAYA
            DELAYA #(.COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .EDGE_MONITOR("DISABLED"),
                    .WAIT_FOR_EDGE("DISABLED"),
                    .DEL_MODE("USER_DEFINED"),
                    .COARSE_DELAY_MODE("DYNAMIC")) u_data_DELAYA (// Inputs
                    .A(del_data_o_w[i]), 
                        .LOAD_N(data_loadn_i[i]), 
                        .MOVE(data_move_i[i]), 
                        .DIRECTION(data_direction_i[i]), 
                        .COARSE0(data_coarse_dly_i[((i * 2) + 0)]), 
                        .COARSE1(data_coarse_dly_i[((i * 2) + 1)]), 
                        .RANKENABLE(1'b0), 
                        .RANKSELECT(1'b0), 
                        .RANK0UPDATE(1'b0), 
                        .RANK1UPDATE(1'b0), 
                        // Outputs
                    .Z(data_q_obz_i_w[i]), 
                        .EDETERR(), 
                        .CFLAG(data_cflag_o[i])) ; 
            if ((GEARING == 2)) 
                begin : genblk1
                    // ODDRX2
                    ODDRX2 u_data_ODDRX2 (// Inputs
                            .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                .RST(rst_i), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_data_o_w[i])) ; 
                end
            else
                if ((GEARING == 4)) 
                    begin : genblk1
                        // ODDRX4
                        ODDRX4 u_data_ODDRX4 (// Inputs
                                .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                    .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                    .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                    .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                    .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                    .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                    .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                    .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                    .RST(rst_i), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_data_o_w[i])) ; 
                    end
                else
                    if ((GEARING == 5)) 
                        begin : genblk1
                            // ODDRX5
                            ODDRX5 u_data_ODDRX5 (// Inputs
                                    .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                        .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                        .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                        .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                        .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                        .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                        .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                        .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                        .D8(data_i[(i + (BUS_WIDTH * 8))]), 
                                        .D9(data_i[(i + (BUS_WIDTH * 9))]), 
                                        .RST(rst_i), 
                                        .ECLK(eclkout_w), 
                                        .SCLK(sclk_o), 
                                        // Outputs
                                    .Q(del_data_o_w[i])) ; 
                        end
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddrx2_4_5_tx_eclk_aligned_dynamic.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddrx2_4_5_tx_eclk_aligned_static_bypass.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : 
// File                  : gddr_sync.v
// Title                 : 
// Dependencies          :
// Description           : 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 03.20.2018
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_aligned_static_bypass #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter GEARING = 2, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input sync_rst_i, 
    input clk_i, 
    input [(((GEARING * BUS_WIDTH) * 2) - 1):0] data_i, 
    input sync_clk_i, 
    input sync_start_i, 
    output ready_o, 
    output [(BUS_WIDTH - 1):0] data_o, 
    output clk_o, 
    output sclk_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_DELAY_ADJUSTMENT == "DEFAULT") ? "ECLK_ALIGNED" : "USER_DEFINED") ; 
    localparam GEARING_STR = ((GEARING == 5) ? "5" : ((GEARING == 4) ? "4" : "2")) ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire eclkout_w ; 
    wire rst_w ; 
    wire stop_w ; 
    wire del_clk_o_w ; 
    wire [(BUS_WIDTH - 1):0] del_data_o_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKDIV #(.ECLK_DIV(GEARING_STR),
            .GSR("DISABLED")) u0_ECLKDIV (.DIVOUT(sclk_o), 
                .DIVRST(rst_w), 
                .ECLKIN(eclkout_w), 
                .SLIP(1'b0)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKSYNC #(.STOP_EN("ENABLE")) u0_ECLKSYNC (.ECLKIN(clk_i), 
                .ECLKOUT(eclkout_w), 
                .STOP(stop_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_gddr_sync u1_gddr_sync (.rst(sync_rst_i), 
                .sync_clk(sync_clk_i), 
                .start(sync_start_i), 
                .stop(stop_w), 
                .ddr_reset(rst_w), 
                .ready(ready_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        if ((DATA_PATH_DELAY == "BYPASS")) 
            begin : CLOCK_DEL_BYPASS
                assign clk_o = del_clk_o_w ; 
            end
        else
            begin : CLOCK_DEL_STATIC
                // DELAYB
                DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                        .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                        .DEL_MODE(DEL_MODE)) u_clock_DELAYB (// Always "USER_DEFINED".
                        .A(del_clk_o_w), 
                            .Z(clk_o)) ; 
            end
        if ((GEARING == 2)) 
            begin : genblk2
                // ODDRX2
                ODDRX2 u_clock_ODDRX2 (// Inputs
                        .D0(1'h1), 
                            .D1(1'h0), 
                            .D2(1'h1), 
                            .D3(1'h0), 
                            .RST(rst_w), 
                            .ECLK(eclkout_w), 
                            .SCLK(sclk_o), 
                            // Outputs
                        .Q(del_clk_o_w)) ; 
            end
        else
            if ((GEARING == 4)) 
                begin : genblk2
                    // ODDRX4
                    ODDRX4 u_clock_ODDRX4 (// Inputs
                            .D0(1'h1), 
                                .D1(1'h0), 
                                .D2(1'h1), 
                                .D3(1'h0), 
                                .D4(1'h1), 
                                .D5(1'h0), 
                                .D6(1'h1), 
                                .D7(1'h0), 
                                .RST(rst_w), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_clk_o_w)) ; 
                end
            else
                if ((GEARING == 5)) 
                    begin : genblk2
                        // ODDRX5
                        ODDRX5 u_clock_ODDRX5 (// Inputs
                                .D0(1'h1), 
                                    .D1(1'h0), 
                                    .D2(1'h1), 
                                    .D3(1'h0), 
                                    .D4(1'h1), 
                                    .D5(1'h0), 
                                    .D6(1'h1), 
                                    .D7(1'h0), 
                                    .D8(1'h1), 
                                    .D9(1'h0), 
                                    .RST(rst_w), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_clk_o_w)) ; 
                    end
    endgenerate
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            if ((DATA_PATH_DELAY == "BYPASS")) 
                begin : DATA_DEL_BYPASS
                    assign data_o[i] = del_data_o_w[i] ; 
                end
            else
                begin : DATA_DEL_STATIC
                    // DELAYB
                    DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                            .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                            .DEL_MODE(DEL_MODE)) u_data_DELAYB (// Always "USER_DEFINED".
                            .A(del_data_o_w[i]), 
                                .Z(data_o[i])) ; 
                end
            if ((GEARING == 2)) 
                begin : genblk2
                    // ODDRX2
                    ODDRX2 u_data_ODDRX2 (// Inputs
                            .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                .RST(rst_w), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_data_o_w[i])) ; 
                end
            else
                if ((GEARING == 4)) 
                    begin : genblk2
                        // ODDRX4
                        ODDRX4 u_data_ODDRX4 (// Inputs
                                .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                    .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                    .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                    .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                    .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                    .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                    .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                    .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                    .RST(rst_w), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_data_o_w[i])) ; 
                    end
                else
                    if ((GEARING == 5)) 
                        begin : genblk2
                            // ODDRX5
                            ODDRX5 u_data_ODDRX5 (// Inputs
                                    .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                        .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                        .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                        .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                        .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                        .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                        .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                        .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                        .D8(data_i[(i + (BUS_WIDTH * 8))]), 
                                        .D9(data_i[(i + (BUS_WIDTH * 9))]), 
                                        .RST(rst_w), 
                                        .ECLK(eclkout_w), 
                                        .SCLK(sclk_o), 
                                        // Outputs
                                    .Q(del_data_o_w[i])) ; 
                        end
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddrx2_4_5_tx_eclk_aligned_static_bypass.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddrx2_4_5_tx_eclk_aligned_static_bypass_tri_state_control.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_aligned_static_bypass_tri_state_control #(parameter IO_TYPE = "LVDS", 
        parameter BUS_WIDTH = 8, 
        parameter GEARING = 2, 
        parameter DATA_PATH_DELAY = "BYPASS", 
        parameter DATA_DELAY_ADJUSTMENT = "DEFAULT", 
        parameter DATA_FINE_DELAY_VALUE = "0", 
        parameter DATA_COARSE_DELAY_VALUE = "0NS") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input rst_i, 
    input outen_n_i, 
    input [(((GEARING * BUS_WIDTH) * 2) - 1):0] data_i, 
    input clk_i, 
    output [(BUS_WIDTH - 1):0] data_o, 
    output clk_o, 
    output sclk_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_DELAY_ADJUSTMENT == "DEFAULT") ? "ECLK_ALIGNED" : "USER_DEFINED") ; 
    localparam GEARING_STR = ((GEARING == 5) ? "5" : ((GEARING == 4) ? "4" : "2")) ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire [(BUS_WIDTH - 1):0] data_q_obz_i_w ; 
    wire outen_n_i_w ; 
    wire clock_q_obz_i_w ; 
    wire eclkout_w ; 
    wire [(BUS_WIDTH - 1):0] outen_n_w ; 
    wire outen_n_clk_w ; 
    wire del_clk_o_w ; 
    wire [(BUS_WIDTH - 1):0] del_data_o_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKDIV #(.ECLK_DIV(GEARING_STR),
            .GSR("DISABLED")) u0_ECLKDIV (.DIVOUT(sclk_o), 
                .DIVRST(rst_i), 
                .ECLKIN(eclkout_w), 
                .SLIP(1'b0)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKSYNC #(.STOP_EN("ENABLE")) u0_ECLKSYNC (.ECLKIN(clk_i), 
                .ECLKOUT(eclkout_w), 
                .STOP(rst_i)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    // FD1P3BX
    FD1P3BX #(.GSR("ENABLED")) u_FD1P3BX (// Inputs
            .D(outen_n_i), 
                .CK(sclk_o), 
                .SP(1'h1), 
                .PD(rst_i), 
                // Outputs
            .Q(outen_n_i_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        // OBZ
        OBZ u_clock_OBZ (.I(clock_q_obz_i_w), 
                    .T(outen_n_i_w), 
                    .O(clk_o)) ; 
        if ((DATA_PATH_DELAY == "BYPASS")) 
            begin : CLOCK_DEL_BYPASS
                assign clock_q_obz_i_w = del_clk_o_w ; 
            end
        else
            begin : CLOCK_DEL_STATIC
                // DELAYB
                DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                        .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                        .DEL_MODE(DEL_MODE)) u_clock_DELAYB (// Always "USER_DEFINED".
                        .A(del_clk_o_w), 
                            .Z(clock_q_obz_i_w)) ; 
            end
        if ((GEARING == 2)) 
            begin : genblk2
                // ODDRX2
                ODDRX2 u_clock_ODDRX2 (// Inputs
                        .D0(1'h1), 
                            .D1(1'h0), 
                            .D2(1'h1), 
                            .D3(1'h0), 
                            .RST(rst_i), 
                            .ECLK(eclkout_w), 
                            .SCLK(sclk_o), 
                            // Outputs
                        .Q(del_clk_o_w)) ; 
            end
        else
            if ((GEARING == 4)) 
                begin : genblk2
                    // ODDRX4
                    ODDRX4 u_clock_ODDRX4 (// Inputs
                            .D0(1'h1), 
                                .D1(1'h0), 
                                .D2(1'h1), 
                                .D3(1'h0), 
                                .D4(1'h1), 
                                .D5(1'h0), 
                                .D6(1'h1), 
                                .D7(1'h0), 
                                .RST(rst_i), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_clk_o_w)) ; 
                end
            else
                if ((GEARING == 5)) 
                    begin : genblk2
                        // ODDRX5
                        ODDRX5 u_clock_ODDRX5 (// Inputs
                                .D0(1'h1), 
                                    .D1(1'h0), 
                                    .D2(1'h1), 
                                    .D3(1'h0), 
                                    .D4(1'h1), 
                                    .D5(1'h0), 
                                    .D6(1'h1), 
                                    .D7(1'h0), 
                                    .D8(1'h1), 
                                    .D9(1'h0), 
                                    .RST(rst_i), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_clk_o_w)) ; 
                    end
    endgenerate
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // OBZ
            OBZ u_data_OBZ (.I(data_q_obz_i_w[i]), 
                        .T(outen_n_i_w), 
                        .O(data_o[i])) ; 
            if ((DATA_PATH_DELAY == "BYPASS")) 
                begin : DATA_DEL_BYPASS
                    assign data_q_obz_i_w[i] = del_data_o_w[i] ; 
                end
            else
                begin : DATA_DEL_STATIC
                    // DELAYB
                    DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                            .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                            .DEL_MODE(DEL_MODE)) u_data_DELAYB (// Always "USER_DEFINED".
                            .A(del_data_o_w[i]), 
                                .Z(data_q_obz_i_w[i])) ; 
                end
            if ((GEARING == 2)) 
                begin : genblk2
                    // ODDRX2
                    ODDRX2 u_data_ODDRX2 (// Inputs
                            .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                .RST(rst_i), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_data_o_w[i])) ; 
                end
            else
                if ((GEARING == 4)) 
                    begin : genblk2
                        // ODDRX4
                        ODDRX4 u_data_ODDRX4 (// Inputs
                                .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                    .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                    .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                    .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                    .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                    .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                    .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                    .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                    .RST(rst_i), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_data_o_w[i])) ; 
                    end
                else
                    if ((GEARING == 5)) 
                        begin : genblk2
                            // ODDRX5
                            ODDRX5 u_data_ODDRX5 (// Inputs
                                    .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                        .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                        .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                        .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                        .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                        .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                        .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                        .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                        .D8(data_i[(i + (BUS_WIDTH * 8))]), 
                                        .D9(data_i[(i + (BUS_WIDTH * 9))]), 
                                        .RST(rst_i), 
                                        .ECLK(eclkout_w), 
                                        .SCLK(sclk_o), 
                                        // Outputs
                                    .Q(del_data_o_w[i])) ; 
                        end
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddrx2_4_5_tx_eclk_aligned_static_bypass_tri_state_control.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddrx2_4_5_tx_eclk_centered_dynamic_pll.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//==========================================================================
// Module : lscc_pll
//==========================================================================
module ddr_rx_ipgen_lscc_pll #(parameter FVCO = 800.0, 
        parameter CLKI_FREQ = 100.0, 
        parameter CLKOP_FREQ_ACTUAL = 100.0, 
        parameter CLKOS_FREQ_ACTUAL = 100.0, 
        parameter CLKOS2_FREQ_ACTUAL = 100.0, 
        parameter CLKOS3_FREQ_ACTUAL = 100.0, 
        parameter CLKOS4_FREQ_ACTUAL = 100.0, 
        parameter CLKOS5_FREQ_ACTUAL = 100.0, 
        parameter CLKOP_PHASE_ACTUAL = 0.0, 
        parameter CLKOS_PHASE_ACTUAL = 0.0, 
        parameter CLKOS2_PHASE_ACTUAL = 0.0, 
        parameter CLKOS3_PHASE_ACTUAL = 0.0, 
        parameter CLKOS4_PHASE_ACTUAL = 0.0, 
        parameter CLKOS5_PHASE_ACTUAL = 0.0, 
        parameter CLKOS_EN = 0, 
        parameter CLKOS2_EN = 0, 
        parameter CLKOS3_EN = 0, 
        parameter CLKOS4_EN = 0, 
        parameter CLKOS5_EN = 0, 
        parameter CLKOP_BYPASS = 0, 
        parameter CLKOS_BYPASS = 0, 
        parameter CLKOS2_BYPASS = 0, 
        parameter CLKOS3_BYPASS = 0, 
        parameter CLKOS4_BYPASS = 0, 
        parameter CLKOS5_BYPASS = 0, 
        parameter ENCLKOP_EN = 0, 
        parameter ENCLKOS_EN = 0, 
        parameter ENCLKOS2_EN = 0, 
        parameter ENCLKOS3_EN = 0, 
        parameter ENCLKOS4_EN = 0, 
        parameter ENCLKOS5_EN = 0, 
        parameter FRAC_N_EN = 0, 
        parameter SS_EN = 0, 
        parameter DYN_PORTS_EN = 0, 
        parameter PLL_RST = 0, 
        parameter LOCK_EN = 0, 
        parameter PLL_LOCK_STICKY = 0, 
        parameter LEGACY_EN = 0, 
        parameter LMMI_EN = 0, 
        parameter APB_EN = 0, 
        parameter POWERDOWN_EN = 0, 
        parameter TRIM_EN_P = 0, 
        parameter TRIM_EN_S = 0, 
        parameter PLL_REFCLK_FROM_PIN = 0, 
        parameter REF_CLK_IO_TYPE = "LVDS", 
        parameter CLKOP_TRIM_MODE = "Falling", 
        parameter CLKOS_TRIM_MODE = "Falling", 
        parameter CLKOP_TRIM = "0b0000", 
        parameter CLKOS_TRIM = "0b0000", 
        parameter FBK_MODE = "CLKOP", 
        parameter CLKI_DIVIDER_ACTUAL_STR = "1", 
        parameter FBCLK_DIVIDER_ACTUAL_STR = "1", 
        parameter DIVOP_ACTUAL_STR = "1", 
        parameter DIVOS_ACTUAL_STR = "1", 
        parameter DIVOS2_ACTUAL_STR = "1", 
        parameter DIVOS3_ACTUAL_STR = "1", 
        parameter DIVOS4_ACTUAL_STR = "1", 
        parameter DIVOS5_ACTUAL_STR = "1", 
        parameter SSC_N_CODE_STR = "0b000010100", 
        parameter SSC_F_CODE_STR = "0b000000000000000", 
        parameter SSC_PROFILE = "DOWN", 
        parameter SSC_TBASE_STR = "0b000000000000", 
        parameter SSC_STEP_IN_STR = "0b0000000", 
        parameter SSC_REG_WEIGHTING_SEL_STR = "0b000", 
        parameter DELA = "0", 
        parameter DELB = "0", 
        parameter DELC = "0", 
        parameter DELD = "0", 
        parameter DELE = "0", 
        parameter DELF = "0", 
        parameter PHIA = "0", 
        parameter PHIB = "0", 
        parameter PHIC = "0", 
        parameter PHID = "0", 
        parameter PHIE = "0", 
        parameter PHIF = "0", 
        parameter EN_REFCLK_MON = 0, 
        parameter REF_COUNTS = "0000", 
        parameter INTFBKDEL_SEL = "DISABLED", 
        parameter PMU_WAITFORLOCK = "ENABLED", 
        parameter REF_OSC_CTRL = "3P2", 
        parameter SIM_FLOAT_PRECISION = "0.1", 
        parameter IPI_CMP = "0b1000", 
        parameter CSET = "40P", 
        parameter CRIPPLE = "5P", 
        parameter IPP_CTRL = "0b1000", 
        parameter IPP_SEL = "0b1111", 
        parameter BW_CTL_BIAS = "0b0101", 
        parameter V2I_PP_RES = "10K", 
        parameter KP_VCO = "0b00011", 
        parameter V2I_KVCO_SEL = "60", 
        parameter V2I_1V_EN = "ENABLED") (
    //--begin_param--
    //----------------------------
    // Parameters
    //----------------------------
    // For simulation only
    //--end_param--
    //--begin_ports--
    input rstn_i, 
    input clki_i, 
    input usr_fbclk_i, 
    // Dynamic Phase Control
    input phasedir_i, 
    input phasestep_i, 
    input phaseloadreg_i, 
    input [2:0] phasesel_i, 
    // Clock output enable
    input enclkop_i, 
    input enclkos_i, 
    input enclkos2_i, 
    input enclkos3_i, 
    input enclkos4_i, 
    input enclkos5_i, 
    // Clock output
    output wire clkop_o, 
    output wire clkos_o, 
    output wire clkos2_o, 
    output wire clkos3_o, 
    output wire clkos4_o, 
    output wire clkos5_o, 
    output wire lock_o, 
    input pllpd_en_n_i, 
    input legacy_i, 
    // Ref clock monitor
    input refdetreset,  // Enables users to reset the refclk detection logic
    output wire refdetlos,  // Detect reset from the refclk detection logic
    // LMMI bus
    input wire lmmi_clk_i, 
    input wire lmmi_resetn_i, 
    input wire lmmi_request_i, 
    input wire lmmi_wr_rdn_i, 
    input wire [6:0] lmmi_offset_i, 
    input wire [7:0] lmmi_wdata_i, 
    output wire lmmi_ready_o, 
    output wire lmmi_rdata_valid_o, 
    output wire [7:0] lmmi_rdata_o, 
    // APB bus
    input apb_pclk_i, 
    input apb_preset_n_i, 
    input wire apb_penable_i, 
    input wire apb_psel_i, 
    input wire apb_pwrite_i, 
    input wire [6:0] apb_paddr_i, 
    input wire [7:0] apb_pwdata_i, 
    output wire apb_pready_o, 
    output wire apb_pslverr_o, 
    output wire [7:0] apb_prdata_o) ;
    //--end_ports--
    localparam MAX_STRING_LENGTH = 16 ; 
    localparam CONVWIDTH = 32 ; 
    function [(CONVWIDTH - 1):0] convertDeviceString ; 
    // convertDeviceString
        input [((MAX_STRING_LENGTH * 8) - 1):0] attributeValue ; 
        integer i, 
            j ; 
        integer decVal ; 
        integer decPlace ; 
        integer temp, 
            count ; 
        reg decimalFlag ; 
        reg [(CONVWIDTH - 1):0] reverseVal ; 
        integer concatDec [(CONVWIDTH - 1):0] ; 
        reg [1:8] character ; 
        reg [7:0] checkType ; 
        begin
            decimalFlag = 1'b0 ;
            decVal = 0 ;
            decPlace = 1 ;
            temp = 0 ;
            count = 0 ;
            for (i = 0 ; (i <= (CONVWIDTH - 1)) ; i = (i + 1))
                begin
                    concatDec[i] = (-1) ;
                end
            convertDeviceString = 0 ;
            checkType = "N" ;
            for (i = (MAX_STRING_LENGTH - 1) ; (i >= 1) ; i = (i - 1))
                begin
                    for (j = 1 ; (j <= 8) ; j = (j + 1))
                        begin
                            character[j] = attributeValue[((i * 8) - j)] ;
                        end
                    //Check to see if binary or hex
                    if ((checkType === "N")) 
                        begin
                            if (((character === "b") || (character === "x"))) 
                                begin
                                    checkType = character ;
                                    decimalFlag = 1'b1 ;
                                end
                            else
                                begin
                                    //Convert to string decimal to array of integers for each digit of the number
                                    case (character)
                                    "0" : 
                                        concatDec[(i - 1)] = 0 ;
                                    "1" : 
                                        concatDec[(i - 1)] = 1 ;
                                    "2" : 
                                        concatDec[(i - 1)] = 2 ;
                                    "3" : 
                                        concatDec[(i - 1)] = 3 ;
                                    "4" : 
                                        concatDec[(i - 1)] = 4 ;
                                    "5" : 
                                        concatDec[(i - 1)] = 5 ;
                                    "6" : 
                                        concatDec[(i - 1)] = 6 ;
                                    "7" : 
                                        concatDec[(i - 1)] = 7 ;
                                    "8" : 
                                        concatDec[(i - 1)] = 8 ;
                                    "9" : 
                                        concatDec[(i - 1)] = 9 ;
                                    default : 
                                        concatDec[(i - 1)] = (-1) ;
                                    endcase 
                                end
                        end// (checkType === "N")
                    else
                        begin
                            //$display("Index %d: %s", i, character);
                            //handle binary
                            if ((checkType === "b")) 
                                begin
                                    case (character)
                                    "0" : 
                                        convertDeviceString[(i - 1)] = 1'b0 ;
                                    "1" : 
                                        convertDeviceString[(i - 1)] = 1'b1 ;
                                    default : 
                                        convertDeviceString[(i - 1)] = 1'bx ;
                                    endcase 
                                end
                            else
                                //handle hex
                                if ((checkType === "x")) 
                                    begin
                                        case (character)
                                        "0" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'h0 ;
                                        "1" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'h1 ;
                                        "2" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'h2 ;
                                        "3" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'h3 ;
                                        "4" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'h4 ;
                                        "5" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'h5 ;
                                        "6" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'h6 ;
                                        "7" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'h7 ;
                                        "8" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'h8 ;
                                        "9" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'h9 ;
                                        "a",
                                                "A" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'hA ;
                                        "b",
                                                "B" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'hB ;
                                        "c",
                                                "C" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'hC ;
                                        "d",
                                                "D" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'hD ;
                                        "e",
                                                "E" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'hE ;
                                        "f",
                                                "F" : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'hF ;
                                        default : 
                                            {convertDeviceString[((i * 4) - 1)],
                                                    convertDeviceString[((i * 4) - 2)],
                                                    convertDeviceString[((i * 4) - 3)],
                                                    convertDeviceString[((i - 1) * 4)]} = 4'hX ;
                                        endcase 
                                    end
                        end
                end
            //Calculate decmial value from integer array.
            if ((decimalFlag === 1'b0)) 
                begin
                    for (i = 0 ; (i <= (CONVWIDTH - 1)) ; i = (i + 1))
                        begin
                            case (concatDec[i])
                            0 : 
                                temp = 0 ;
                            1 : 
                                temp = 1 ;
                            2 : 
                                temp = 2 ;
                            3 : 
                                temp = 3 ;
                            4 : 
                                temp = 4 ;
                            5 : 
                                temp = 5 ;
                            6 : 
                                temp = 6 ;
                            7 : 
                                temp = 7 ;
                            8 : 
                                temp = 8 ;
                            9 : 
                                temp = 9 ;
                            default : 
                                temp = (-1) ;
                            endcase 
                            if ((temp != (-1))) 
                                begin
                                    decVal = (decVal + (temp * decPlace)) ;
                                    count = (count + 1) ;
                                    decPlace = (10 ** count) ;
                                end
                        end
                    convertDeviceString = decVal ;
                end
        end
    endfunction
    function [(((2 + 7) * 8) - 1):0] int_to_7b_str ; 
    // int_to_7b_str
        input [6:0] value ; 
        reg [((8 * 7) - 1):0] binstr ; 
        integer idx ; 
        begin
            for (idx = 0 ; (idx < 7) ; idx = (idx + 1))
                begin
                    binstr[(idx * 8) +: 8] = (value[idx] ? "1" : "0") ;
                end
            int_to_7b_str = {"0b",
                    binstr} ;
        end
    endfunction
    //--------------------------------------------------------------------------
    //--- Local Parameters/Defines ---
    //--------------------------------------------------------------------------
    localparam SEL_FBK = ((FBK_MODE == "CLKOP") ? "FBKCLK0" : ((FBK_MODE == "CLKOS") ? "FBKCLK1" : ((FBK_MODE == "CLKOS2") ? "FBKCLK2" : ((FBK_MODE == "CLKOS3") ? "FBKCLK3" : ((FBK_MODE == "CLKOS4") ? "FBKCLK4" : ((FBK_MODE == "CLKOS5") ? "FBKCLK5" : ((FBK_MODE == "INTCLKOP") ? "DIVA" : ((FBK_MODE == "INTCLKOS") ? "DIVB" : ((FBK_MODE == "INTCLKOS2") ? "DIVC" : ((FBK_MODE == "INTCLKOS3") ? "DIVD" : ((FBK_MODE == "INTCLKOS4") ? "DIVE" : ((FBK_MODE == "INTCLKOS5") ? "DIVF" : "DIVA")))))))))))) ; 
    localparam CLKMUX_FB = (((FBK_MODE == "CLKOP") || (FBK_MODE == "INTCLKOP")) ? "CMUX_CLKOP" : (((FBK_MODE == "CLKOS") || (FBK_MODE == "INTCLKOS")) ? "CMUX_CLKOS" : (((FBK_MODE == "CLKOS2") || (FBK_MODE == "INTCLKOS2")) ? "CMUX_CLKOS2" : (((FBK_MODE == "CLKOS3") || (FBK_MODE == "INTCLKOS3")) ? "CMUX_CLKOS3" : (((FBK_MODE == "CLKOS4") || (FBK_MODE == "INTCLKOS4")) ? "CMUX_CLKOS4" : (((FBK_MODE == "CLKOS5") || (FBK_MODE == "INTCLKOS5")) ? "CMUX_CLKOS5" : "CMUX_CLKOP")))))) ; 
    localparam SEL_OUTA = ((CLKOP_BYPASS == 1) ? "ENABLED" : "DISABLED") ; 
    localparam SEL_OUTB = ((CLKOS_BYPASS == 1) ? "ENABLED" : "DISABLED") ; 
    localparam SEL_OUTC = ((CLKOS2_BYPASS == 1) ? "ENABLED" : "DISABLED") ; 
    localparam SEL_OUTD = ((CLKOS3_BYPASS == 1) ? "ENABLED" : "DISABLED") ; 
    localparam SEL_OUTE = ((CLKOS4_BYPASS == 1) ? "ENABLED" : "DISABLED") ; 
    localparam SEL_OUTF = ((CLKOS5_BYPASS == 1) ? "ENABLED" : "DISABLED") ; 
    localparam REF_INTEGER_MODE = "ENABLED" ; 
    localparam FBK_INTEGER_MODE = ((FRAC_N_EN || SS_EN) ? "DISABLED" : "ENABLED") ; 
    localparam SSC_EN_SSC = ((SS_EN == 1) ? "ENABLED" : "DISABLED") ; 
    localparam SSC_EN_SDM = ((FRAC_N_EN || SS_EN) ? "ENABLED" : "DISABLED") ; 
    localparam SSC_ORDER = ((FRAC_N_EN || SS_EN) ? "SDM_ORDER2" : "SDM_ORDER1") ; 
    localparam SSC_DITHER = "DISABLED" ; 
    localparam SSC_N_CODE = ((FRAC_N_EN || SS_EN) ? SSC_N_CODE_STR : "0b000000000") ; 
    localparam SSC_F_CODE = ((FRAC_N_EN || SS_EN) ? SSC_F_CODE_STR : "0b000000000000000") ; 
    localparam SSC_PI_BYPASS = "NOT_BYPASSED" ; 
    localparam SSC_SQUARE_MODE = "DISABLED" ; 
    localparam SSC_EN_CENTER_IN = ((SSC_PROFILE == "CENTER") ? "CENTER_TRIANGLE" : "DOWN_TRIANGLE") ; 
    localparam SSC_TBASE = (SS_EN ? SSC_TBASE_STR : "0b000000000000") ; 
    localparam SSC_STEP_IN = (SS_EN ? SSC_STEP_IN_STR : "0b0000000") ; 
    localparam SSC_REG_WEIGHTING_SEL = (SS_EN ? SSC_REG_WEIGHTING_SEL_STR : "0b000") ; 
    localparam ENCLK_CLKOP = ((ENCLKOP_EN == 0) ? "ENABLED" : "DISABLED") ; 
    localparam ENCLK_CLKOS = (((CLKOS_EN == 1) && (ENCLKOS_EN == 0)) ? "ENABLED" : "DISABLED") ; 
    localparam ENCLK_CLKOS2 = (((CLKOS2_EN == 1) && (ENCLKOS2_EN == 0)) ? "ENABLED" : "DISABLED") ; 
    localparam ENCLK_CLKOS3 = (((CLKOS3_EN == 1) && (ENCLKOS3_EN == 0)) ? "ENABLED" : "DISABLED") ; 
    localparam ENCLK_CLKOS4 = (((CLKOS4_EN == 1) && (ENCLKOS4_EN == 0)) ? "ENABLED" : "DISABLED") ; 
    localparam ENCLK_CLKOS5 = (((CLKOS5_EN == 1) && (ENCLKOS5_EN == 0)) ? "ENABLED" : "DISABLED") ; 
    localparam DYN_SOURCE = ((DYN_PORTS_EN == 1) ? "DYNAMIC" : "STATIC") ; 
    localparam PLLRESET_ENA = ((PLL_RST == 1) ? "ENABLED" : "DISABLED") ; 
    localparam PLLPDN_EN = ((POWERDOWN_EN == 1) ? "ENABLED" : "DISABLED") ; 
    localparam PLLPD_N = "USED" ; 
    localparam LEGACY_ATT = ((LEGACY_EN == 1) ? "ENABLED" : "DISABLED") ; 
    localparam LDT_LOCK_SEL = ((PLL_LOCK_STICKY == 1) ? "SFREQ" : "UFREQ") ; 
    localparam TRIMOP_BYPASS_N = ((TRIM_EN_P == 1) ? "USED" : "BYPASSED") ; 
    localparam TRIMOS_BYPASS_N = ((TRIM_EN_S == 1) ? "USED" : "BYPASSED") ; 
    localparam FBK_MMD_DIG = FBCLK_DIVIDER_ACTUAL_STR ; 
    localparam REF_MMD_DIG = CLKI_DIVIDER_ACTUAL_STR ; 
    localparam REF_MASK = "0b00000000" ; 
    localparam FBK_MASK = ((FRAC_N_EN || SS_EN) ? "0b00010000" : "0b00000000") ; 
    localparam FBK_MMD_PULS_CTL = (FRAC_N_EN ? "0b0110" : (SS_EN ? "0b0101" : (((FBCLK_DIVIDER_ACTUAL_STR == "1") || (FBCLK_DIVIDER_ACTUAL_STR == "2")) ? "0b0000" : "0b0001"))) ; 
    localparam REF_MMD_PULS_CTL = (((CLKI_DIVIDER_ACTUAL_STR == "1") || (CLKI_DIVIDER_ACTUAL_STR == "2")) ? "0b0000" : "0b0001") ; 
    localparam DIVA = DIVOP_ACTUAL_STR ; 
    localparam DIVB = DIVOS_ACTUAL_STR ; 
    localparam DIVC = DIVOS2_ACTUAL_STR ; 
    localparam DIVD = DIVOS3_ACTUAL_STR ; 
    localparam DIVE = DIVOS4_ACTUAL_STR ; 
    localparam DIVF = DIVOS5_ACTUAL_STR ; 
    localparam V2I_PP_ICTRL = "0b11111" ; 
    localparam IPI_CMPN = "0b0011" ; 
    localparam FBK_CLK_DIV_O = (((FBK_MODE == "CLKOP") || (FBK_MODE == "INTCLKOP")) ? convertDeviceString(DIVOP_ACTUAL_STR) : (((FBK_MODE == "CLKOS") || (FBK_MODE == "INTCLKOS")) ? convertDeviceString(DIVOS_ACTUAL_STR) : (((FBK_MODE == "CLKOS2") || (FBK_MODE == "INTCLKOS2")) ? convertDeviceString(DIVOS2_ACTUAL_STR) : (((FBK_MODE == "CLKOS3") || (FBK_MODE == "INTCLKOS3")) ? convertDeviceString(DIVOS3_ACTUAL_STR) : (((FBK_MODE == "CLKOS4") || (FBK_MODE == "INTCLKOS4")) ? convertDeviceString(DIVOS4_ACTUAL_STR) : (((FBK_MODE == "CLKOS5") || (FBK_MODE == "INTCLKOS5")) ? convertDeviceString(DIVOS5_ACTUAL_STR) : convertDeviceString(DIVOP_ACTUAL_STR))))))) ; 
    localparam DIV_DEL = int_to_7b_str(FBK_CLK_DIV_O) ; 
    //--------------------------------------------------------------------------
    //--- Combinational Wire/Reg ---
    //--------------------------------------------------------------------------
    wire pllreset ; 
    wire clki_w ; 
    wire fbclk_w ; 
    wire intclkop_w ; 
    wire intclkos_w ; 
    wire intclkos2_w ; 
    wire intclkos3_w ; 
    wire intclkos4_w ; 
    wire intclkos5_w ; 
    wire lmmi_clk_w ; 
    wire lmmi_resetn_w ; 
    wire [7:0] lmmi_wdata_w ; 
    wire lmmi_wr_rdn_w ; 
    wire [6:0] lmmi_offset_w ; 
    wire lmmi_request_w ; 
    wire apb_lmmi_request_w ; 
    wire [6:0] apb_lmmi_offset_w ; 
    wire [7:0] apb_lmmi_wdata_w ; 
    wire [7:0] apb_lmmi_rdata_w ; 
    wire apb_lmmi_wr_rdn_w ; 
    //--------------------------------------------------------------------------
    //--- Registers ---
    //--------------------------------------------------------------------------
    //--------------------------------------------------------------------------
    //--- Module Instantiation ---
    //--------------------------------------------------------------------------
    assign pllreset = (~rstn_i) ; 
    assign fbclk_w = ((FBK_MODE == "CLKOP") ? clkop_o : ((FBK_MODE == "CLKOS") ? clkos_o : ((FBK_MODE == "CLKOS2") ? clkos2_o : ((FBK_MODE == "CLKOS3") ? clkos3_o : ((FBK_MODE == "CLKOS4") ? clkos4_o : ((FBK_MODE == "CLKOS5") ? clkos5_o : ((FBK_MODE == "INTCLKOP") ? intclkop_w : ((FBK_MODE == "INTCLKOS") ? intclkos_w : ((FBK_MODE == "INTCLKOS2") ? intclkos2_w : ((FBK_MODE == "INTCLKOS3") ? intclkos3_w : ((FBK_MODE == "INTCLKOS4") ? intclkos4_w : ((FBK_MODE == "INTCLKOS5") ? intclkos5_w : ((FBK_MODE == "USERFBCLK") ? usr_fbclk_i : clkop_o))))))))))))) ; 
    generate
        if ((PLL_REFCLK_FROM_PIN == 0)) 
            begin : genblk1
                assign clki_w = clki_i ; 
            end
        else
            begin : genblk1
                BB u0_BB (.B(clki_i), 
                            .I(1'b0), 
                            .T(1'b1), 
                            .O(clki_w)) ; 
            end
    endgenerate
    generate
        if ((APB_EN == 1)) 
            begin : APB2LMMI_INST
                // lmmi_error_i is not used by lscc_spi_master_native, thus, this is set to 0
                wire lmmi_error_w ; 
                assign lmmi_error_w = 0 ; 
                ///
                ddr_rx_ipgen_lscc_apb2lmmi #(.DATA_WIDTH(8),
                        .ADDR_WIDTH(7),
                        .REG_OUTPUT(0)) u_lscc_apb2lmmi (.clk_i(apb_pclk_i), 
                            .rst_n_i(apb_preset_n_i), 
                            .apb_penable_i(apb_penable_i), 
                            .apb_psel_i(apb_psel_i), 
                            .apb_pwrite_i(apb_pwrite_i), 
                            .apb_paddr_i(apb_paddr_i), 
                            .apb_pwdata_i(apb_pwdata_i), 
                            .apb_pready_o(apb_pready_o), 
                            .apb_pslverr_o(apb_pslverr_o), 
                            .apb_prdata_o(apb_prdata_o), 
                            .lmmi_ready_i(lmmi_ready_o), 
                            .lmmi_rdata_valid_i(lmmi_rdata_valid_o), 
                            .lmmi_error_i(lmmi_error_w), 
                            .lmmi_rdata_i(apb_lmmi_rdata_w), 
                            .lmmi_request_o(apb_lmmi_request_w), 
                            .lmmi_wr_rdn_o(apb_lmmi_wr_rdn_w), 
                            .lmmi_offset_o(apb_lmmi_offset_w), 
                            .lmmi_wdata_o(apb_lmmi_wdata_w), 
                            .lmmi_resetn_o() // unused
                        ) ; 
                ///
                assign lmmi_clk_w = apb_pclk_i ; 
                assign lmmi_resetn_w = apb_preset_n_i ; 
                assign lmmi_wdata_w = apb_lmmi_wdata_w[7:0] ; 
                assign apb_lmmi_rdata_w[7:0] = lmmi_rdata_o ; 
                assign lmmi_wr_rdn_w = apb_lmmi_wr_rdn_w ; 
                assign lmmi_offset_w = apb_lmmi_offset_w ; 
                assign lmmi_request_w = apb_lmmi_request_w ; 
            end
    endgenerate
    // -----------------------------------------------------------------------------
    // Generate Assign Statements
    // -----------------------------------------------------------------------------
    generate
        if ((APB_EN == 0)) 
            begin : LMMI
                assign lmmi_clk_w = lmmi_clk_i ; 
                assign lmmi_resetn_w = lmmi_resetn_i ; 
                assign lmmi_wdata_w = lmmi_wdata_i ; 
                assign lmmi_wr_rdn_w = lmmi_wr_rdn_i ; 
                assign lmmi_offset_w = lmmi_offset_i ; 
                assign lmmi_request_w = lmmi_request_i ; 
            end
        if (EN_REFCLK_MON) 
            begin : gen_en_refclk_mon
                /*PLLA AUTO_TEMPLATE
    (
     .REF_COUNTS                            (REF_COUNTS),
     .CLKOP_TRIM                            (CLKOP_TRIM),
     .CLKOS_TRIM                            (CLKOS_TRIM),
     .TRIMOP_BYPASS_N                       (TRIMOP_BYPASS_N),
     .TRIMOS_BYPASS_N                       (TRIMOS_BYPASS_N),
     .DEL\(.\)                              (DEL\1),
     .PHI\(.\)                              (PHI\1),
     .DIV\(.\)                              (DIV\1),
     .SEL_OUT\(.\)                          (SEL_OUT\1),
     .ENCLK_CLKO\(.*\)                      (ENCLK_CLKO\1),
     .DYN_SOURCE                            (DYN_SOURCE),
     .\(.*\)_INTEGER_MODE                   (\1_INTEGER_MODE),
     .\(.*\)_MASK                           (\1_MASK),
     .\(.*\)_MMD_DIG                        (\1_MMD_DIG),
     .\(.*\)_MMD_PULS_CTL                   (\1_MMD_PULS_CTL),
     .LDT_LOCK_SEL                          (LDT_LOCK_SEL),
     .LEGACY_ATT                            (LEGACY_ATT),
     .PLL\(.*\)                             (PLL\1),
     .SSC_\(.*\)                            (SSC_\1),
     .V2I_\(.*\)                            (V2I_\1),
     .SEL_FBK                               (SEL_FBK),
     .CLKMUX_FB                             (CLKMUX_FB),
     .KP_VCO                                (KP_VCO),
     .CSET                                  (CSET),
     .CRIPPLE                               (CRIPPLE),
     .IPP_CTRL                              (IPP_CTRL),
     .IPP_SEL                               (IPP_SEL),
     .BW_CTL_BIAS                           (BW_CTL_BIAS),
     .IPI_CMPN                              (IPI_CMPN),
     .IPI_CMP                               (IPI_CMP),
     .INTFBKDEL_SEL                         (INTFBKDEL_SEL),
     .PMU_WAITFORLOCK                       (PMU_WAITFORLOCK),
     .REF_OSC_CTRL                          (REF_OSC_CTRL),
     .SIM_FLOAT_PRECISION                   (SIM_FLOAT_PRECISION),
     .DIR                                   (phasedir_i),
     .DIRSEL                                (phasesel_i),
     .LOADREG                               (phaseloadreg_i),
     .DYNROTATE                             (phasestep_i),
     .LMMICLK                               (lmmi_clk_w),
     .LMMIRESET_N                           (lmmi_resetn_w),
     .LMMIREQUEST                           (lmmi_request_w),
     .LMMIWRRD_N                            (lmmi_wr_rdn_w),
     .LMMIOFFSET                            (lmmi_offset_w),
     .LMMIWDATA                             (lmmi_wdata_w),
     .PLLPOWERDOWN_N                        (pllpd_en_n_i),
     .REFCK                                 (clki_w),
     .ENCLKO\(.*\)                          (enclko\l\1_i),
     .FBKCK                                 (fbclk_w),
     .LEGACY                                (legacy_i),
     .PLLRESET                              (pllreset),
     .LOCK                                  (lock_o),
     .CLKO\(.\)                             (clko\l\1_o),
     .CLKOS\(.\)                            (clkos\l\1_o),
     .INTFBKO\(.*\)                         (intclko\l\1_w),
     .LMMIRDATA                             (lmmi_rdata_o),
     .LMMIRDATAVALID                        (lmmi_rdata_valid_o),
     .LMMIREADY                             (lmmi_ready_o),
     .REFDETRESET                           (refdetreset),
     .REFDETLOS                             (refdetlos),
     .STDBY                                 (1'b0),
     .ROTDEL                                (1'b0),
     .DIRDEL                                (1'b0),
     .ROTDELP1                              (1'b0),
     .GRAYTEST                              (5'b0),
     .BINTEST                               (2'b0),
     .DIRDELP1                              (1'b0),
     .GRAYACT                               (5'b0),
     .BINACT                                (2'b0),
     .INTLOCK                               (),
     .LEGRDYN                               (),
     .PFDDN                                 (),
     .PFDUP                                 (),
     .REFMUXCK                              (),
     .REGQA                                 (),
     .REGQB                                 (),
     .REGQB1                                (),
     .CLKOUTDL                              (),
     .\(.*\)                                (),
    );*/
                PLLA #(.BW_CTL_BIAS(BW_CTL_BIAS),
                        .CLKOP_TRIM(CLKOP_TRIM),
                        .CLKOS_TRIM(CLKOS_TRIM),
                        .CLKOS2_TRIM(),
                        .CLKOS3_TRIM(),
                        .CLKOS4_TRIM(),
                        .CLKOS5_TRIM(),
                        .CRIPPLE(CRIPPLE),
                        .CSET(CSET),
                        .DELAY_CTRL(),
                        .DELA(DELA),
                        .DELB(DELB),
                        .DELC(DELC),
                        .DELD(DELD),
                        .DELE(DELE),
                        .DELF(DELF),
                        .DIRECTION(),
                        .DIVA(DIVA),
                        .DIVB(DIVB),
                        .DIVC(DIVC),
                        .DIVD(DIVD),
                        .DIVE(DIVE),
                        .DIVF(DIVF),
                        .DYN_SEL(),
                        .DYN_SOURCE(DYN_SOURCE),
                        .ENCLK_CLKOP(ENCLK_CLKOP),
                        .ENCLK_CLKOS(ENCLK_CLKOS),
                        .ENCLK_CLKOS2(ENCLK_CLKOS2),
                        .ENCLK_CLKOS3(ENCLK_CLKOS3),
                        .ENCLK_CLKOS4(ENCLK_CLKOS4),
                        .ENCLK_CLKOS5(ENCLK_CLKOS5),
                        .ENABLE_SYNC(),
                        .FAST_LOCK_EN(),
                        .V2I_1V_EN(V2I_1V_EN),
                        .FBK_CUR_BLE(),
                        .FBK_EDGE_SEL(),
                        .FBK_IF_TIMING_CTL(),
                        .FBK_INTEGER_MODE(FBK_INTEGER_MODE),
                        .FBK_MASK(FBK_MASK),
                        .FBK_MMD_DIG(FBK_MMD_DIG),
                        .FBK_MMD_PULS_CTL(FBK_MMD_PULS_CTL),
                        .FBK_MODE(),
                        .FBK_PI_BYPASS(),
                        .FBK_PI_RC(),
                        .FBK_PR_CC(),
                        .FBK_PR_IC(),
                        .FLOAT_CP(),
                        .FLOCK_CTRL(),
                        .FLOCK_EN(),
                        .FLOCK_SRC_SEL(),
                        .FORCE_FILTER(),
                        .I_CTRL(),
                        .IPI_CMP(IPI_CMP),
                        .IPI_CMPN(IPI_CMPN),
                        .IPI_COMP_EN(),
                        .IPP_CTRL(IPP_CTRL),
                        .IPP_SEL(IPP_SEL),
                        .KP_VCO(KP_VCO),
                        .LDT_INT_LOCK_STICKY(),
                        .LDT_LOCK(),
                        .LDT_LOCK_SEL(LDT_LOCK_SEL),
                        .LEGACY_ATT(LEGACY_ATT),
                        .LOAD_REG(),
                        .OPENLOOP_EN(),
                        .PHIA(PHIA),
                        .PHIB(PHIB),
                        .PHIC(PHIC),
                        .PHID(PHID),
                        .PHIE(PHIE),
                        .PHIF(PHIF),
                        .PLLPDN_EN(PLLPDN_EN),
                        .PLLPD_N(PLLPD_N),
                        .PLLRESET_ENA(PLLRESET_ENA),
                        .REF_INTEGER_MODE(REF_INTEGER_MODE),
                        .REF_MASK(REF_MASK),
                        .REF_MMD_DIG(REF_MMD_DIG),
                        .REF_MMD_IN(),
                        .REF_MMD_PULS_CTL(REF_MMD_PULS_CTL),
                        .REF_TIMING_CTL(),
                        .REFIN_RESET(),
                        .RESET_LF(),
                        .ROTATE(),
                        .SEL_OUTA(SEL_OUTA),
                        .SEL_OUTB(SEL_OUTB),
                        .SEL_OUTC(SEL_OUTC),
                        .SEL_OUTD(SEL_OUTD),
                        .SEL_OUTE(SEL_OUTE),
                        .SEL_OUTF(SEL_OUTF),
                        .SLEEP(),
                        .SSC_DITHER(SSC_DITHER),
                        .SSC_EN_CENTER_IN(SSC_EN_CENTER_IN),
                        .SSC_EN_SDM(SSC_EN_SDM),
                        .SSC_EN_SSC(SSC_EN_SSC),
                        .SSC_F_CODE(SSC_F_CODE),
                        .SSC_N_CODE(SSC_N_CODE),
                        .SSC_ORDER(SSC_ORDER),
                        .SSC_PI_BYPASS(SSC_PI_BYPASS),
                        .SSC_REG_WEIGHTING_SEL(SSC_REG_WEIGHTING_SEL),
                        .SSC_SQUARE_MODE(SSC_SQUARE_MODE),
                        .SSC_STEP_IN(SSC_STEP_IN),
                        .SSC_TBASE(SSC_TBASE),
                        .STDBY_ATT(),
                        .TRIMOP_BYPASS_N(TRIMOP_BYPASS_N),
                        .TRIMOS_BYPASS_N(TRIMOS_BYPASS_N),
                        .TRIMOS2_BYPASS_N(),
                        .TRIMOS3_BYPASS_N(),
                        .TRIMOS4_BYPASS_N(),
                        .TRIMOS5_BYPASS_N(),
                        .V2I_KVCO_SEL(V2I_KVCO_SEL),
                        .V2I_PP_ICTRL(V2I_PP_ICTRL),
                        .V2I_PP_RES(V2I_PP_RES),
                        .CLKMUX_FB(CLKMUX_FB),
                        .SEL_FBK(SEL_FBK),
                        .DIV_DEL(DIV_DEL),
                        .PHASE_SEL_DEL(),
                        .PHASE_SEL_DEL_P1(),
                        .EXTERNAL_DIVIDE_FACTOR(),
                        .INTFBKDEL_SEL(INTFBKDEL_SEL),
                        .PMU_WAITFORLOCK(PMU_WAITFORLOCK),
                        .REF_OSC_CTRL(REF_OSC_CTRL),
                        .REF_COUNTS(REF_COUNTS),
                        .SIM_FLOAT_PRECISION(SIM_FLOAT_PRECISION)) u_PLL (/*AUTOINSTPARAM*/ // Parameters
                        //.FVCO                                  (FVCO),
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        /*AUTOINST*/ // Inputs
                        .DIR(phasedir_i),  // Templated
                        .DIRSEL(phasesel_i),  // Templated
                        .LOADREG(phaseloadreg_i),  // Templated
                        .DYNROTATE(phasestep_i),  // Templated
                        .LMMICLK(lmmi_clk_w),  // Templated
                        .LMMIRESET_N(lmmi_resetn_w),  // Templated
                        .LMMIREQUEST(lmmi_request_w),  // Templated
                        .LMMIWRRD_N(lmmi_wr_rdn_w),  // Templated
                        .LMMIOFFSET(lmmi_offset_w),  // Templated
                        .LMMIWDATA(lmmi_wdata_w),  // Templated
                        .PLLPOWERDOWN_N(pllpd_en_n_i),  // Templated
                        .REFCK(clki_w),  // Templated
                        .ENCLKOP(enclkop_i),  // Templated
                        .ENCLKOS(enclkos_i),  // Templated
                        .ENCLKOS2(enclkos2_i),  // Templated
                        .ENCLKOS3(enclkos3_i),  // Templated
                        .ENCLKOS4(enclkos4_i),  // Templated
                        .ENCLKOS5(enclkos5_i),  // Templated
                        .FBKCK(fbclk_w),  // Templated
                        .LEGACY(legacy_i),  // Templated
                        .PLLRESET(pllreset),  // Templated
                        .STDBY(1'b0),  // Templated
                        .ROTDEL(1'b0),  // Templated
                        .DIRDEL(1'b0),  // Templated
                        .ROTDELP1(1'b0),  // Templated
                        .GRAYTEST(5'b0),  // Templated
                        .BINTEST(2'b0),  // Templated
                        .DIRDELP1(1'b0),  // Templated
                        .GRAYACT(5'b0),  // Templated
                        .BINACT(2'b0),  // Templated
                        .REFDETRESET(refdetreset),  // Templated
                        // Outputs
                        .INTFBKOP(intclkop_w),  // Templated
                        .INTFBKOS(intclkos_w),  // Templated
                        .INTFBKOS2(intclkos2_w),  // Templated
                        .INTFBKOS3(intclkos3_w),  // Templated
                        .INTFBKOS4(intclkos4_w),  // Templated
                        .INTFBKOS5(intclkos5_w),  // Templated
                        .LMMIRDATA(lmmi_rdata_o),  // Templated
                        .LMMIRDATAVALID(lmmi_rdata_valid_o),  // Templated
                        .LMMIREADY(lmmi_ready_o),  // Templated
                        .CLKOP(clkop_o),  // Templated
                        .CLKOS(clkos_o),  // Templated
                        .CLKOS2(clkos2_o),  // Templated
                        .CLKOS3(clkos3_o),  // Templated
                        .CLKOS4(clkos4_o),  // Templated
                        .CLKOS5(clkos5_o),  // Templated
                        .INTLOCK(),  // Templated
                        .LEGRDYN(),  // Templated
                        .LOCK(lock_o),  // Templated
                        .PFDDN(),  // Templated
                        .PFDUP(),  // Templated
                        .REFMUXCK(),  // Templated
                        .REGQA(),  // Templated
                        .REGQB(),  // Templated
                        .REGQB1(),  // Templated
                        .CLKOUTDL(),  // Templated
                        .REFDETLOS(refdetlos)) ; // Templated
            end
        else
            begin : gen_no_refclk_mon
                /*PLL AUTO_TEMPLATE
    (
     .CLKOP_TRIM                            (CLKOP_TRIM),
     .CLKOS_TRIM                            (CLKOS_TRIM),
     .TRIMOP_BYPASS_N                       (TRIMOP_BYPASS_N),
     .TRIMOS_BYPASS_N                       (TRIMOS_BYPASS_N),
     .DEL\(.\)                              (DEL\1),
     .PHI\(.\)                              (PHI\1),
     .DIV\(.\)                              (DIV\1),
     .SEL_OUT\(.\)                          (SEL_OUT\1),
     .ENCLK_CLKO\(.*\)                      (ENCLK_CLKO\1),
     .DYN_SOURCE                            (DYN_SOURCE),
     .\(.*\)_INTEGER_MODE                   (\1_INTEGER_MODE),
     .\(.*\)_MASK                           (\1_MASK),
     .\(.*\)_MMD_DIG                        (\1_MMD_DIG),
     .\(.*\)_MMD_PULS_CTL                   (\1_MMD_PULS_CTL),
     .LDT_LOCK_SEL                          (LDT_LOCK_SEL),
     .LEGACY_ATT                            (LEGACY_ATT),
     .PLL\(.*\)                             (PLL\1),
     .SSC_\(.*\)                            (SSC_\1),
     .V2I_\(.*\)                            (V2I_\1),
     .SEL_FBK                               (SEL_FBK),
     .CLKMUX_FB                             (CLKMUX_FB),
     .KP_VCO                                (KP_VCO),
     .CSET                                  (CSET),
     .CRIPPLE                               (CRIPPLE),
     .IPP_CTRL                              (IPP_CTRL),
     .IPP_SEL                               (IPP_SEL),
     .BW_CTL_BIAS                           (BW_CTL_BIAS),
     .IPI_CMPN                              (IPI_CMPN),
     .IPI_CMP                               (IPI_CMP),
     .INTFBKDEL_SEL                         (INTFBKDEL_SEL),
     .PMU_WAITFORLOCK                       (PMU_WAITFORLOCK),
     .REF_OSC_CTRL                          (REF_OSC_CTRL),
     .SIM_FLOAT_PRECISION                   (SIM_FLOAT_PRECISION),
     .DIR                                   (phasedir_i),
     .DIRSEL                                (phasesel_i),
     .LOADREG                               (phaseloadreg_i),
     .DYNROTATE                             (phasestep_i),
     .LMMICLK                               (lmmi_clk_w),
     .LMMIRESET_N                           (lmmi_resetn_w),
     .LMMIREQUEST                           (lmmi_request_w),
     .LMMIWRRD_N                            (lmmi_wr_rdn_w),
     .LMMIOFFSET                            (lmmi_offset_w),
     .LMMIWDATA                             (lmmi_wdata_w),
     .PLLPOWERDOWN_N                        (pllpd_en_n_i),
     .REFCK                                 (clki_w),
     .ENCLKO\(.*\)                          (enclko\l\1_i),
     .FBKCK                                 (fbclk_w),
     .LEGACY                                (legacy_i),
     .PLLRESET                              (pllreset),
     .LOCK                                  (lock_o),
     .CLKO\(.\)                             (clko\l\1_o),
     .CLKOS\(.\)                            (clkos\l\1_o),
     .INTFBKO\(.*\)                         (intclko\l\1_w),
     .LMMIRDATA                             (lmmi_rdata_o),
     .LMMIRDATAVALID                        (lmmi_rdata_valid_o),
     .LMMIREADY                             (lmmi_ready_o),
     .STDBY                                 (1'b0),
     .ROTDEL                                (1'b0),
     .DIRDEL                                (1'b0),
     .ROTDELP1                              (1'b0),
     .GRAYTEST                              (5'b0),
     .BINTEST                               (2'b0),
     .DIRDELP1                              (1'b0),
     .GRAYACT                               (5'b0),
     .BINACT                                (2'b0),
     .INTLOCK                               (),
     .LEGRDYN                               (),
     .PFDDN                                 (),
     .PFDUP                                 (),
     .REFMUXCK                              (),
     .REGQA                                 (),
     .REGQB                                 (),
     .REGQB1                                (),
     .CLKOUTDL                              (),
     .\(.*\)                                (),
    );*/
                PLL #(.BW_CTL_BIAS(BW_CTL_BIAS),
                        .CLKOP_TRIM(CLKOP_TRIM),
                        .CLKOS_TRIM(CLKOS_TRIM),
                        .CLKOS2_TRIM(),
                        .CLKOS3_TRIM(),
                        .CLKOS4_TRIM(),
                        .CLKOS5_TRIM(),
                        .CRIPPLE(CRIPPLE),
                        .CSET(CSET),
                        .DELAY_CTRL(),
                        .DELA(DELA),
                        .DELB(DELB),
                        .DELC(DELC),
                        .DELD(DELD),
                        .DELE(DELE),
                        .DELF(DELF),
                        .DIRECTION(),
                        .DIVA(DIVA),
                        .DIVB(DIVB),
                        .DIVC(DIVC),
                        .DIVD(DIVD),
                        .DIVE(DIVE),
                        .DIVF(DIVF),
                        .DYN_SEL(),
                        .DYN_SOURCE(DYN_SOURCE),
                        .ENCLK_CLKOP(ENCLK_CLKOP),
                        .ENCLK_CLKOS(ENCLK_CLKOS),
                        .ENCLK_CLKOS2(ENCLK_CLKOS2),
                        .ENCLK_CLKOS3(ENCLK_CLKOS3),
                        .ENCLK_CLKOS4(ENCLK_CLKOS4),
                        .ENCLK_CLKOS5(ENCLK_CLKOS5),
                        .ENABLE_SYNC(),
                        .FAST_LOCK_EN(),
                        .V2I_1V_EN(V2I_1V_EN),
                        .FBK_CUR_BLE(),
                        .FBK_EDGE_SEL(),
                        .FBK_IF_TIMING_CTL(),
                        .FBK_INTEGER_MODE(FBK_INTEGER_MODE),
                        .FBK_MASK(FBK_MASK),
                        .FBK_MMD_DIG(FBK_MMD_DIG),
                        .FBK_MMD_PULS_CTL(FBK_MMD_PULS_CTL),
                        .FBK_MODE(),
                        .FBK_PI_BYPASS(),
                        .FBK_PI_RC(),
                        .FBK_PR_CC(),
                        .FBK_PR_IC(),
                        .FLOAT_CP(),
                        .FLOCK_CTRL(),
                        .FLOCK_EN(),
                        .FLOCK_SRC_SEL(),
                        .FORCE_FILTER(),
                        .I_CTRL(),
                        .IPI_CMP(IPI_CMP),
                        .IPI_CMPN(IPI_CMPN),
                        .IPI_COMP_EN(),
                        .IPP_CTRL(IPP_CTRL),
                        .IPP_SEL(IPP_SEL),
                        .KP_VCO(KP_VCO),
                        .LDT_INT_LOCK_STICKY(),
                        .LDT_LOCK(),
                        .LDT_LOCK_SEL(LDT_LOCK_SEL),
                        .LEGACY_ATT(LEGACY_ATT),
                        .LOAD_REG(),
                        .OPENLOOP_EN(),
                        .PHIA(PHIA),
                        .PHIB(PHIB),
                        .PHIC(PHIC),
                        .PHID(PHID),
                        .PHIE(PHIE),
                        .PHIF(PHIF),
                        .PLLPDN_EN(PLLPDN_EN),
                        .PLLPD_N(PLLPD_N),
                        .PLLRESET_ENA(PLLRESET_ENA),
                        .REF_INTEGER_MODE(REF_INTEGER_MODE),
                        .REF_MASK(REF_MASK),
                        .REF_MMD_DIG(REF_MMD_DIG),
                        .REF_MMD_IN(),
                        .REF_MMD_PULS_CTL(REF_MMD_PULS_CTL),
                        .REF_TIMING_CTL(),
                        .REFIN_RESET(),
                        .RESET_LF(),
                        .ROTATE(),
                        .SEL_OUTA(SEL_OUTA),
                        .SEL_OUTB(SEL_OUTB),
                        .SEL_OUTC(SEL_OUTC),
                        .SEL_OUTD(SEL_OUTD),
                        .SEL_OUTE(SEL_OUTE),
                        .SEL_OUTF(SEL_OUTF),
                        .SLEEP(),
                        .SSC_DITHER(SSC_DITHER),
                        .SSC_EN_CENTER_IN(SSC_EN_CENTER_IN),
                        .SSC_EN_SDM(SSC_EN_SDM),
                        .SSC_EN_SSC(SSC_EN_SSC),
                        .SSC_F_CODE(SSC_F_CODE),
                        .SSC_N_CODE(SSC_N_CODE),
                        .SSC_ORDER(SSC_ORDER),
                        .SSC_PI_BYPASS(SSC_PI_BYPASS),
                        .SSC_REG_WEIGHTING_SEL(SSC_REG_WEIGHTING_SEL),
                        .SSC_SQUARE_MODE(SSC_SQUARE_MODE),
                        .SSC_STEP_IN(SSC_STEP_IN),
                        .SSC_TBASE(SSC_TBASE),
                        .STDBY_ATT(),
                        .TRIMOP_BYPASS_N(TRIMOP_BYPASS_N),
                        .TRIMOS_BYPASS_N(TRIMOS_BYPASS_N),
                        .TRIMOS2_BYPASS_N(),
                        .TRIMOS3_BYPASS_N(),
                        .TRIMOS4_BYPASS_N(),
                        .TRIMOS5_BYPASS_N(),
                        .V2I_KVCO_SEL(V2I_KVCO_SEL),
                        .V2I_PP_ICTRL(V2I_PP_ICTRL),
                        .V2I_PP_RES(V2I_PP_RES),
                        .CLKMUX_FB(CLKMUX_FB),
                        .SEL_FBK(SEL_FBK),
                        .DIV_DEL(DIV_DEL),
                        .PHASE_SEL_DEL(),
                        .PHASE_SEL_DEL_P1(),
                        .EXTERNAL_DIVIDE_FACTOR(),
                        .INTFBKDEL_SEL(INTFBKDEL_SEL),
                        .PMU_WAITFORLOCK(PMU_WAITFORLOCK),
                        .REF_OSC_CTRL(REF_OSC_CTRL),
                        .SIM_FLOAT_PRECISION(SIM_FLOAT_PRECISION)) u_PLL (/*AUTOINSTPARAM*/ // Parameters
                        //.FVCO                                  (FVCO),
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        // Templated
                        /*AUTOINST*/ // Inputs
                        .DIR(phasedir_i),  // Templated
                        .DIRSEL(phasesel_i),  // Templated
                        .LOADREG(phaseloadreg_i),  // Templated
                        .DYNROTATE(phasestep_i),  // Templated
                        .LMMICLK(lmmi_clk_w),  // Templated
                        .LMMIRESET_N(lmmi_resetn_w),  // Templated
                        .LMMIREQUEST(lmmi_request_w),  // Templated
                        .LMMIWRRD_N(lmmi_wr_rdn_w),  // Templated
                        .LMMIOFFSET(lmmi_offset_w),  // Templated
                        .LMMIWDATA(lmmi_wdata_w),  // Templated
                        .PLLPOWERDOWN_N(pllpd_en_n_i),  // Templated
                        .REFCK(clki_w),  // Templated
                        .ENCLKOP(enclkop_i),  // Templated
                        .ENCLKOS(enclkos_i),  // Templated
                        .ENCLKOS2(enclkos2_i),  // Templated
                        .ENCLKOS3(enclkos3_i),  // Templated
                        .ENCLKOS4(enclkos4_i),  // Templated
                        .ENCLKOS5(enclkos5_i),  // Templated
                        .FBKCK(fbclk_w),  // Templated
                        .LEGACY(legacy_i),  // Templated
                        .PLLRESET(pllreset),  // Templated
                        .STDBY(1'b0),  // Templated
                        .ROTDEL(1'b0),  // Templated
                        .DIRDEL(1'b0),  // Templated
                        .ROTDELP1(1'b0),  // Templated
                        .GRAYTEST(5'b0),  // Templated
                        .BINTEST(2'b0),  // Templated
                        .DIRDELP1(1'b0),  // Templated
                        .GRAYACT(5'b0),  // Templated
                        .BINACT(2'b0),  // Templated
                        // Outputs
                        .INTFBKOP(intclkop_w),  // Templated
                        .INTFBKOS(intclkos_w),  // Templated
                        .INTFBKOS2(intclkos2_w),  // Templated
                        .INTFBKOS3(intclkos3_w),  // Templated
                        .INTFBKOS4(intclkos4_w),  // Templated
                        .INTFBKOS5(intclkos5_w),  // Templated
                        .LMMIRDATA(lmmi_rdata_o),  // Templated
                        .LMMIRDATAVALID(lmmi_rdata_valid_o),  // Templated
                        .LMMIREADY(lmmi_ready_o),  // Templated
                        .CLKOP(clkop_o),  // Templated
                        .CLKOS(clkos_o),  // Templated
                        .CLKOS2(clkos2_o),  // Templated
                        .CLKOS3(clkos3_o),  // Templated
                        .CLKOS4(clkos4_o),  // Templated
                        .CLKOS5(clkos5_o),  // Templated
                        .INTLOCK(),  // Templated
                        .LEGRDYN(),  // Templated
                        .LOCK(lock_o),  // Templated
                        .PFDDN(),  // Templated
                        .PFDUP(),  // Templated
                        .REFMUXCK(),  // Templated
                        .REGQA(),  // Templated
                        .REGQB(),  // Templated
                        .REGQB1(),  // Templated
                        .CLKOUTDL()) ; // Templated
            end
    endgenerate

//defparam u_PLL.SIM_FLOAT_PRECISION = SIM_FLOAT_PRECISION;
///*synthesis translate_off*/
//// For Simulation
//localparam FEEDBACK_FREQ = (FBK_MODE == "CLKOP"    )? CLKOP_FREQ_ACTUAL  :
//                           (FBK_MODE == "CLKOS"    )? CLKOS_FREQ_ACTUAL  :
//                           (FBK_MODE == "CLKOS2"   )? CLKOS2_FREQ_ACTUAL :
//                           (FBK_MODE == "CLKOS3"   )? CLKOS3_FREQ_ACTUAL :
//                           (FBK_MODE == "CLKOS4"   )? CLKOS4_FREQ_ACTUAL :
//                           (FBK_MODE == "CLKOS5"   )? CLKOS5_FREQ_ACTUAL :
//                           (FBK_MODE == "INTCLKOP" )? CLKOP_FREQ_ACTUAL  :
//                           (FBK_MODE == "INTCLKOS" )? CLKOS_FREQ_ACTUAL  :
//                           (FBK_MODE == "INTCLKOS2")? CLKOS2_FREQ_ACTUAL :
//                           (FBK_MODE == "INTCLKOS3")? CLKOS3_FREQ_ACTUAL :
//                           (FBK_MODE == "INTCLKOS4")? CLKOS4_FREQ_ACTUAL :
//                           (FBK_MODE == "INTCLKOS5")? CLKOS5_FREQ_ACTUAL :
//                                                      CLKOP_FREQ_ACTUAL;
//localparam FLOAT_PRECISION_ACTUAL  = (SIM_FLOAT_PRECISION == "0.0001")? (0.2/FEEDBACK_FREQ) : SIM_FLOAT_PRECISION;
//defparam u_PLL.SIM_FLOAT_PRECISION = FLOAT_PRECISION_ACTUAL;
///*synthesis translate_on*/
//--lscc_pll--
endmodule



`timescale 100fs/100fs
// __RTL_MODULE__LSCC_PLL__
//==========================================================================
// Module : lscc_apb2lmmi
//==========================================================================
module ddr_rx_ipgen_lscc_apb2lmmi #(parameter DATA_WIDTH = 32, 
        parameter ADDR_WIDTH = 16, 
        parameter REG_OUTPUT = 1) (
    //--begin_param--
    //----------------------------
    // Parameters
    //----------------------------
    // Data width
    // Address width
    // enable registered output
    //--end_param--
    //--begin_ports--
    //----------------------------
    // Global Signals (Clock and Reset)
    //----------------------------
    input clk_i,  // apb clock
    input rst_n_i,  // active low reset
    //----------------------------
    // APB Interface
    //----------------------------
    input apb_penable_i,  // apb enable
    input apb_psel_i,  // apb slave select
    input apb_pwrite_i,  // apb write 1, read 0
    input [(ADDR_WIDTH - 1):0] apb_paddr_i,  // apb address
    input [(DATA_WIDTH - 1):0] apb_pwdata_i,  // apb write data
    output reg apb_pready_o,  // apb ready
    output reg apb_pslverr_o,  // apb slave error
    output reg [(DATA_WIDTH - 1):0] apb_prdata_o,  // apb read data
    //----------------------------
    // LMMI-Extended Interface
    //----------------------------
    input lmmi_ready_i,  // slave is ready to start new transaction
    input lmmi_rdata_valid_i,  // read transaction is complete
    input lmmi_error_i,  // error indicator
    input [(DATA_WIDTH - 1):0] lmmi_rdata_i,  // read data
    output reg lmmi_request_o,  // start transaction
    output reg lmmi_wr_rdn_o,  // write 1, read 0
    output reg [(ADDR_WIDTH - 1):0] lmmi_offset_o,  // address/offset
    output reg [(DATA_WIDTH - 1):0] lmmi_wdata_o,  // write data
    output wire lmmi_resetn_o // reset to LMMI inteface
        ) ;
    //--end_ports--
    //--------------------------------------------------------------------------
    //--- Local Parameters/Defines ---
    //--------------------------------------------------------------------------
    localparam ST_BUS_IDLE = 4'b0001 ; 
    localparam ST_BUS_REQ = 4'b0010 ; // APB_SETUP
    localparam ST_BUS_DAT = 4'b0100 ; // APB_ACCESS
    localparam ST_BUS_WAIT = 4'b1000 ; 
    localparam SM_WIDTH = 4 ; 
    //--------------------------------------------------------------------------
    //--- Combinational Wire/Reg ---
    //--------------------------------------------------------------------------
    //--------------------------------------------------------------------------
    //--- Registers ---
    //--------------------------------------------------------------------------
    reg [(SM_WIDTH - 1):0] bus_sm_ns ; 
    reg [(SM_WIDTH - 1):0] bus_sm_cs ; 
    assign lmmi_resetn_o = rst_n_i ; 
    generate
        if (REG_OUTPUT) 
            begin : genblk1
                reg lmmi_request_nxt ; 
                reg lmmi_wr_rdn_nxt ; 
                reg [(ADDR_WIDTH - 1):0] lmmi_offset_nxt ; 
                reg [(DATA_WIDTH - 1):0] lmmi_wdata_nxt ; 
                reg apb_pready_nxt ; 
                reg apb_pslverr_nxt ; 
                reg [(DATA_WIDTH - 1):0] apb_prdata_nxt ; 
                //--------------------------------------------
                //-- Bus Statemachine --
                //--------------------------------------------
                always
                    @(*)
                    begin
                        bus_sm_ns = bus_sm_cs ;
                        case (bus_sm_cs)
                        ST_BUS_REQ : 
                            begin
                                if (lmmi_ready_i) 
                                    begin
                                        if (lmmi_wr_rdn_o) 
                                            begin
                                                bus_sm_ns = ST_BUS_WAIT ;
                                            end
                                        else
                                            begin
                                                if (lmmi_rdata_valid_i) 
                                                    bus_sm_ns = ST_BUS_WAIT ;
                                                else
                                                    bus_sm_ns = ST_BUS_DAT ;
                                            end
                                    end
                                else
                                    begin
                                        bus_sm_ns = ST_BUS_REQ ;
                                    end
                            end
                        ST_BUS_DAT : 
                            begin
                                if (lmmi_rdata_valid_i) 
                                    bus_sm_ns = ST_BUS_WAIT ;
                                else
                                    bus_sm_ns = ST_BUS_DAT ;
                            end
                        ST_BUS_WAIT : 
                            begin
                                bus_sm_ns = ST_BUS_IDLE ;
                            end
                        default : 
                            begin
                                if (apb_psel_i) 
                                    bus_sm_ns = ST_BUS_REQ ;
                                else
                                    bus_sm_ns = ST_BUS_IDLE ;
                            end
                        endcase 
                    end//--always @*--
                //--------------------------------------------
                //-- APB to LMMI conversion --
                //--------------------------------------------
                always
                    @(*)
                    begin
                        lmmi_request_nxt = lmmi_request_o ;
                        lmmi_wr_rdn_nxt = lmmi_wr_rdn_o ;
                        lmmi_offset_nxt = lmmi_offset_o ;
                        lmmi_wdata_nxt = lmmi_wdata_o ;
                        apb_pready_nxt = apb_pready_o ;
                        apb_pslverr_nxt = 1'b0 ;
                        apb_prdata_nxt = apb_prdata_o ;
                        case (bus_sm_cs)
                        ST_BUS_REQ : 
                            begin
                                if (lmmi_ready_i) 
                                    begin
                                        lmmi_request_nxt = 1'b0 ;
                                        lmmi_wr_rdn_nxt = 1'b0 ;
                                        if (lmmi_wr_rdn_o) 
                                            begin
                                                apb_pready_nxt = 1'b1 ;
                                            end
                                        else
                                            begin
                                                if (lmmi_rdata_valid_i) 
                                                    begin
                                                        apb_pready_nxt = 1'b1 ;
                                                        apb_prdata_nxt = lmmi_rdata_i ;
                                                        apb_pslverr_nxt = lmmi_error_i ;
                                                    end
                                            end
                                    end
                            end
                        ST_BUS_DAT : 
                            begin
                                if (lmmi_rdata_valid_i) 
                                    begin
                                        apb_pready_nxt = 1'b1 ;
                                        apb_prdata_nxt = lmmi_rdata_i ;
                                        apb_pslverr_nxt = lmmi_error_i ;
                                    end
                            end
                        ST_BUS_WAIT : 
                            begin
                                apb_pready_nxt = 1'b0 ;
                            end
                        default : 
                            begin
                                apb_pready_nxt = 1'b0 ;
                                if (apb_psel_i) 
                                    begin
                                        lmmi_request_nxt = 1'b1 ;
                                        lmmi_wr_rdn_nxt = apb_pwrite_i ;
                                        lmmi_offset_nxt = apb_paddr_i ;
                                        lmmi_wdata_nxt = apb_pwdata_i ;
                                    end
                                else
                                    begin
                                        lmmi_request_nxt = 1'b0 ;
                                        lmmi_wr_rdn_nxt = 1'b0 ;
                                    end
                            end
                        endcase 
                    end//--always @*--
                //--------------------------------------------
                //-- Sequential block --
                //--------------------------------------------
                always
                    @(posedge clk_i or 
                        negedge rst_n_i)
                    begin
                        if ((~rst_n_i)) 
                            begin
                                bus_sm_cs <=  ST_BUS_IDLE ;
                                /*AUTORESET*/
                                // Beginning of autoreset for uninitialized flops
                                apb_prdata_o <=  {DATA_WIDTH{1'b0}} ;
                                apb_pready_o <=  1'h0 ;
                                apb_pslverr_o <=  1'h0 ;
                                lmmi_offset_o <=  {ADDR_WIDTH{1'b0}} ;
                                lmmi_request_o <=  1'h0 ;
                                lmmi_wdata_o <=  {DATA_WIDTH{1'b0}} ;
                                lmmi_wr_rdn_o <=  1'h0 ;
                                // End of automatics
                            end
                        else
                            begin
                                bus_sm_cs <=  bus_sm_ns ;
                                lmmi_request_o <=  lmmi_request_nxt ;
                                lmmi_wr_rdn_o <=  lmmi_wr_rdn_nxt ;
                                lmmi_offset_o <=  lmmi_offset_nxt ;
                                lmmi_wdata_o <=  lmmi_wdata_nxt ;
                                apb_pready_o <=  apb_pready_nxt ;
                                apb_pslverr_o <=  apb_pslverr_nxt ;
                                apb_prdata_o <=  apb_prdata_nxt ;
                            end
                    end//--always @(posedge clk_i or negedge rst_n_i)--
            end
        else
            begin : genblk1
                // REG_OUTPUT == 0
                //--------------------------------------------
                //-- Bus Statemachine --
                //--------------------------------------------
                always
                    @(*)
                    begin
                        bus_sm_ns = bus_sm_cs ;
                        case (bus_sm_cs)
                        ST_BUS_IDLE : 
                            begin
                                if (apb_psel_i) 
                                    bus_sm_ns = ST_BUS_REQ ;
                                else
                                    bus_sm_ns = ST_BUS_IDLE ;
                            end
                        ST_BUS_REQ : 
                            begin
                                if (lmmi_ready_i) 
                                    if (((~apb_pwrite_i) && (~lmmi_rdata_valid_i))) 
                                        bus_sm_ns = ST_BUS_DAT ;
                                    else
                                        // Write access will go to IDLE when ready
                                        bus_sm_ns = ST_BUS_IDLE ;
                                else
                                    bus_sm_ns = ST_BUS_REQ ;
                            end
                        ST_BUS_DAT : 
                            begin
                                if ((apb_penable_i && ((~apb_pwrite_i) && lmmi_rdata_valid_i))) 
                                    bus_sm_ns = ST_BUS_IDLE ;
                                else
                                    bus_sm_ns = ST_BUS_DAT ;
                            end
                        default : 
                            begin
                                bus_sm_ns = ST_BUS_IDLE ;
                            end
                        endcase 
                    end//--always @*--
                //--------------------------------------------
                //-- LMMI request --
                //--------------------------------------------
                always
                    @(*)
                    begin
                        lmmi_request_o = (bus_sm_ns == ST_BUS_REQ) ;
                        lmmi_wr_rdn_o = apb_pwrite_i ;
                        lmmi_offset_o = apb_paddr_i ;
                        lmmi_wdata_o = apb_pwdata_i ;
                    end//--always @*--
                //--------------------------------------------
                //-- APB outputs --
                //--------------------------------------------
                always
                    @(*)
                    begin
                        apb_prdata_o = lmmi_rdata_i ;
                        apb_pslverr_o = (lmmi_rdata_valid_i && lmmi_error_i) ;
                        if (apb_pwrite_i) 
                            begin
                                apb_pready_o = lmmi_ready_i ;
                            end
                        else
                            begin
                                apb_pready_o = (lmmi_ready_i && lmmi_rdata_valid_i) ;
                            end
                    end//--always @*--
                //--------------------------------------------
                //-- Sequential block --
                //--------------------------------------------
                always
                    @(posedge clk_i or 
                        negedge rst_n_i)
                    begin
                        if ((~rst_n_i)) 
                            begin
                                bus_sm_cs <=  ST_BUS_IDLE ;
                            end
                        else
                            begin
                                bus_sm_cs <=  bus_sm_ns ;
                            end
                    end//--always @(posedge clk_i or negedge rst_n_i)--
            end
    endgenerate

//--------------------------------------------------------------------------
//--- Module Instantiation ---
//--------------------------------------------------------------------------
//--lscc_apb2lmmi--
endmodule



`timescale 100fs/100fs
//--------------------------------------------------------------------------
// Local Variables:
// verilog-library-directories: ("." "C:/lscc/radiant/2.2/cae_library/simulation/verilog/lifcl")
// verilog-library-files: ("C:/lscc/radiant/2.2/cae_library/synthesis/verilog/lifcl.v")
// End:
//--------------------------------------------------------------------------
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : 
// File                  : gddr_sync.v
// Title                 : 
// Dependencies          :
// Description           : 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 03.20.2018
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_centered_dynamic_pll #(parameter IO_TYPE = 0, 
        parameter BUS_WIDTH = 0, 
        parameter GEARING = 0, 
        parameter DATA_PATH_DELAY = 0, 
        parameter DATA_DELAY_ADJUSTMENT = 0, 
        parameter DATA_FINE_DELAY_VALUE = 0, 
        parameter DATA_COARSE_DELAY_VALUE = 0, 
        parameter FVCO = 800.0, 
        parameter CLKI_FREQ = 100.0, 
        parameter CLKOP_FREQ_ACTUAL = 100.0, 
        parameter CLKOS_FREQ_ACTUAL = 100.0, 
        parameter CLKOS2_FREQ_ACTUAL = 100.0, 
        parameter CLKOS3_FREQ_ACTUAL = 100.0, 
        parameter CLKOS4_FREQ_ACTUAL = 100.0, 
        parameter CLKOS5_FREQ_ACTUAL = 100.0, 
        parameter CLKOP_PHASE_ACTUAL = 0.0, 
        parameter CLKOS_PHASE_ACTUAL = 0.0, 
        parameter CLKOS2_PHASE_ACTUAL = 0.0, 
        parameter CLKOS3_PHASE_ACTUAL = 0.0, 
        parameter CLKOS4_PHASE_ACTUAL = 0.0, 
        parameter CLKOS5_PHASE_ACTUAL = 0.0, 
        parameter CLKOS_EN = 0, 
        parameter CLKOS2_EN = 0, 
        parameter CLKOS3_EN = 0, 
        parameter CLKOS4_EN = 0, 
        parameter CLKOS5_EN = 0, 
        parameter CLKOP_BYPASS = 0, 
        parameter CLKOS_BYPASS = 0, 
        parameter CLKOS2_BYPASS = 0, 
        parameter CLKOS3_BYPASS = 0, 
        parameter CLKOS4_BYPASS = 0, 
        parameter CLKOS5_BYPASS = 0, 
        parameter ENCLKOP_EN = 0, 
        parameter ENCLKOS_EN = 0, 
        parameter ENCLKOS2_EN = 0, 
        parameter ENCLKOS3_EN = 0, 
        parameter ENCLKOS4_EN = 0, 
        parameter ENCLKOS5_EN = 0, 
        parameter FRAC_N_EN = 0, 
        parameter SS_EN = 0, 
        parameter DYN_PORTS_EN = 0, 
        parameter PLL_RST = 0, 
        parameter LOCK_EN = 0, 
        parameter PLL_LOCK_STICKY = 0, 
        parameter LEGACY_EN = 0, 
        parameter LMMI_EN = 0, 
        parameter APB_EN = 0, 
        parameter POWERDOWN_EN = 0, 
        parameter TRIM_EN_P = 0, 
        parameter TRIM_EN_S = 0, 
        parameter PLL_REFCLK_FROM_PIN = 0, 
        parameter REF_CLK_IO_TYPE = "LVDS", 
        parameter CLKOP_TRIM_MODE = "Falling", 
        parameter CLKOS_TRIM_MODE = "Falling", 
        parameter CLKOP_TRIM = "0b0000", 
        parameter CLKOS_TRIM = "0b0000", 
        parameter FBK_MODE = "CLKOP", 
        parameter CLKI_DIVIDER_ACTUAL_STR = "1", 
        parameter FBCLK_DIVIDER_ACTUAL_STR = "1", 
        parameter DIVOP_ACTUAL_STR = "1", 
        parameter DIVOS_ACTUAL_STR = "1", 
        parameter DIVOS2_ACTUAL_STR = "1", 
        parameter DIVOS3_ACTUAL_STR = "1", 
        parameter DIVOS4_ACTUAL_STR = "1", 
        parameter DIVOS5_ACTUAL_STR = "1", 
        parameter SSC_N_CODE_STR = "0b000010100", 
        parameter SSC_F_CODE_STR = "0b000000000000000", 
        parameter SSC_PROFILE = "DOWN", 
        parameter SSC_TBASE_STR = "0b000000000000", 
        parameter SSC_STEP_IN_STR = "0b0000000", 
        parameter SSC_REG_WEIGHTING_SEL_STR = "0b000", 
        parameter DELA = "0", 
        parameter DELB = "0", 
        parameter DELC = "0", 
        parameter DELD = "0", 
        parameter DELE = "0", 
        parameter DELF = "0", 
        parameter PHIA = "0", 
        parameter PHIB = "0", 
        parameter PHIC = "0", 
        parameter PHID = "0", 
        parameter PHIE = "0", 
        parameter PHIF = "0", 
        parameter EN_REFCLK_MON = 0, 
        parameter REF_COUNTS = "0000", 
        parameter INTFBKDEL_SEL = "DISABLED", 
        parameter PMU_WAITFORLOCK = "ENABLED", 
        parameter REF_OSC_CTRL = "3P2", 
        parameter SIM_FLOAT_PRECISION = "0.1", 
        parameter IPI_CMP = "0b1000", 
        parameter CSET = "40P", 
        parameter CRIPPLE = "5P", 
        parameter IPP_CTRL = "0b1000", 
        parameter IPP_SEL = "0b1111", 
        parameter BW_CTL_BIAS = "0b0101", 
        parameter V2I_PP_RES = "10K", 
        parameter KP_VCO = "0b00011", 
        parameter V2I_KVCO_SEL = "60", 
        parameter V2I_1V_EN = "ENABLED") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // PLL parameters
    // For simulation only
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input [((2 * BUS_WIDTH) - 1):0] data_coarse_dly_i, 
    input [1:0] clk_coarse_dly_i, 
    input [(BUS_WIDTH - 1):0] data_move_i, 
    input clk_move_i, 
    input [(BUS_WIDTH - 1):0] data_loadn_i, 
    input clk_loadn_i, 
    input [(BUS_WIDTH - 1):0] data_direction_i, 
    input clk_direction_i, 
    output [(BUS_WIDTH - 1):0] data_cflag_o, 
    output clk_cflag_o, 
    input [(((GEARING * BUS_WIDTH) * 2) - 1):0] data_i, 
    input sync_clk_i, 
    input sync_rst_i, 
    output ready_o, 
    output [(BUS_WIDTH - 1):0] data_o, 
    output clk_o, 
    output sclk_o, 
    input pll_clki_i, 
    input pll_rstn_i, 
    // LMMI bus
    input wire lmmi_clk_i, 
    input wire lmmi_resetn_i, 
    input wire lmmi_request_i, 
    input wire lmmi_wr_rdn_i, 
    input wire [6:0] lmmi_offset_i, 
    input wire [7:0] lmmi_wdata_i, 
    output wire lmmi_ready_o, 
    output wire lmmi_rdata_valid_o, 
    output wire [7:0] lmmi_rdata_o, 
    // APB bus         
    input apb_pclk_i, 
    input apb_preset_n_i, 
    input wire apb_penable_i, 
    input wire apb_psel_i, 
    input wire apb_pwrite_i, 
    input wire [6:0] apb_paddr_i, 
    input wire [7:0] apb_pwdata_i, 
    output wire apb_pready_o, 
    output wire apb_pslverr_o, 
    output wire [7:0] apb_prdata_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam GEARING_STR = ((GEARING == 5) ? "5" : ((GEARING == 4) ? "4" : "2")) ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire clkop_w ; //PLL CLKOP output
    wire clkos_w ; //PLL CLKOS output
    wire lock_w ; //PLL LOCK output
    wire eclkout_w ; 
    wire rst_w ; 
    wire stop_w ; 
    wire del_clk_o_w ; 
    wire [(BUS_WIDTH - 1):0] del_data_o_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKDIV #(.ECLK_DIV(GEARING_STR),
            .GSR("DISABLED")) u0_ECLKDIV (.DIVOUT(sclk_o), 
                .DIVRST(rst_w), 
                .ECLKIN(eclkout_w), 
                .SLIP(1'b0)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKSYNC #(.STOP_EN("ENABLE")) u0_ECLKSYNC (.ECLKIN(clkop_w), 
                .ECLKOUT(eclkout_w), 
                .STOP(stop_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_gddr_sync u1_gddr_sync (.rst(sync_rst_i), 
                .sync_clk(sync_clk_i), 
                .start(lock_w), 
                .stop(stop_w), 
                .ddr_reset(rst_w), 
                .ready(ready_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_lscc_pll #(.FVCO(FVCO),
            .CLKI_FREQ(CLKI_FREQ),
            .CLKOP_FREQ_ACTUAL(CLKOP_FREQ_ACTUAL),
            .CLKOS_FREQ_ACTUAL(CLKOS_FREQ_ACTUAL),
            .CLKOS2_FREQ_ACTUAL(CLKOS2_FREQ_ACTUAL),
            .CLKOS3_FREQ_ACTUAL(CLKOS3_FREQ_ACTUAL),
            .CLKOS4_FREQ_ACTUAL(CLKOS4_FREQ_ACTUAL),
            .CLKOS5_FREQ_ACTUAL(CLKOS5_FREQ_ACTUAL),
            .CLKOP_PHASE_ACTUAL(CLKOP_PHASE_ACTUAL),
            .CLKOS_PHASE_ACTUAL(CLKOS_PHASE_ACTUAL),
            .CLKOS2_PHASE_ACTUAL(CLKOS2_PHASE_ACTUAL),
            .CLKOS3_PHASE_ACTUAL(CLKOS3_PHASE_ACTUAL),
            .CLKOS4_PHASE_ACTUAL(CLKOS4_PHASE_ACTUAL),
            .CLKOS5_PHASE_ACTUAL(CLKOS5_PHASE_ACTUAL),
            .CLKOS_EN(CLKOS_EN),
            .CLKOS2_EN(CLKOS2_EN),
            .CLKOS3_EN(CLKOS3_EN),
            .CLKOS4_EN(CLKOS4_EN),
            .CLKOS5_EN(CLKOS5_EN),
            .CLKOP_BYPASS(CLKOP_BYPASS),
            .CLKOS_BYPASS(CLKOS_BYPASS),
            .CLKOS2_BYPASS(CLKOS2_BYPASS),
            .CLKOS3_BYPASS(CLKOS3_BYPASS),
            .CLKOS4_BYPASS(CLKOS4_BYPASS),
            .CLKOS5_BYPASS(CLKOS5_BYPASS),
            .ENCLKOP_EN(ENCLKOP_EN),
            .ENCLKOS_EN(ENCLKOS_EN),
            .ENCLKOS2_EN(ENCLKOS2_EN),
            .ENCLKOS3_EN(ENCLKOS3_EN),
            .ENCLKOS4_EN(ENCLKOS4_EN),
            .ENCLKOS5_EN(ENCLKOS5_EN),
            .FRAC_N_EN(FRAC_N_EN),
            .SS_EN(SS_EN),
            .DYN_PORTS_EN(DYN_PORTS_EN),
            .PLL_RST(PLL_RST),
            .LOCK_EN(LOCK_EN),
            .PLL_LOCK_STICKY(PLL_LOCK_STICKY),
            .LEGACY_EN(LEGACY_EN),
            .LMMI_EN(LMMI_EN),
            .APB_EN(APB_EN),
            .POWERDOWN_EN(POWERDOWN_EN),
            .TRIM_EN_P(TRIM_EN_P),
            .TRIM_EN_S(TRIM_EN_S),
            .PLL_REFCLK_FROM_PIN(PLL_REFCLK_FROM_PIN),
            .REF_CLK_IO_TYPE(REF_CLK_IO_TYPE),
            .CLKOP_TRIM_MODE(CLKOP_TRIM_MODE),
            .CLKOS_TRIM_MODE(CLKOS_TRIM_MODE),
            .CLKOP_TRIM(CLKOP_TRIM),
            .CLKOS_TRIM(CLKOS_TRIM),
            .FBK_MODE(FBK_MODE),
            .CLKI_DIVIDER_ACTUAL_STR(CLKI_DIVIDER_ACTUAL_STR),
            .FBCLK_DIVIDER_ACTUAL_STR(FBCLK_DIVIDER_ACTUAL_STR),
            .DIVOP_ACTUAL_STR(DIVOP_ACTUAL_STR),
            .DIVOS_ACTUAL_STR(DIVOS_ACTUAL_STR),
            .DIVOS2_ACTUAL_STR(DIVOS2_ACTUAL_STR),
            .DIVOS3_ACTUAL_STR(DIVOS3_ACTUAL_STR),
            .DIVOS4_ACTUAL_STR(DIVOS4_ACTUAL_STR),
            .DIVOS5_ACTUAL_STR(DIVOS5_ACTUAL_STR),
            .SSC_N_CODE_STR(SSC_N_CODE_STR),
            .SSC_F_CODE_STR(SSC_F_CODE_STR),
            .SSC_PROFILE(SSC_PROFILE),
            .SSC_TBASE_STR(SSC_TBASE_STR),
            .SSC_STEP_IN_STR(SSC_STEP_IN_STR),
            .SSC_REG_WEIGHTING_SEL_STR(SSC_REG_WEIGHTING_SEL_STR),
            .DELA(DELA),
            .DELB(DELB),
            .DELC(DELC),
            .DELD(DELD),
            .DELE(DELE),
            .DELF(DELF),
            .PHIA(PHIA),
            .PHIB(PHIB),
            .PHIC(PHIC),
            .PHID(PHID),
            .PHIE(PHIE),
            .PHIF(PHIF),
            .IPI_CMP(IPI_CMP),
            .CSET(CSET),
            .CRIPPLE(CRIPPLE),
            .IPP_CTRL(IPP_CTRL),
            .IPP_SEL(IPP_SEL),
            .BW_CTL_BIAS(BW_CTL_BIAS),
            .V2I_PP_RES(V2I_PP_RES),
            .KP_VCO(KP_VCO),
            .V2I_KVCO_SEL(V2I_KVCO_SEL),
            .V2I_1V_EN(V2I_1V_EN),
            .REF_COUNTS(REF_COUNTS),
            .INTFBKDEL_SEL(INTFBKDEL_SEL),
            .PMU_WAITFORLOCK(PMU_WAITFORLOCK),
            .EN_REFCLK_MON(EN_REFCLK_MON),
            .REF_OSC_CTRL(REF_OSC_CTRL),
            .SIM_FLOAT_PRECISION(SIM_FLOAT_PRECISION)) u_lscc_pll_inst (.rstn_i(pll_rstn_i), 
                .clki_i(pll_clki_i), 
                .usr_fbclk_i(1'h0), 
                .phasedir_i(1'h1), 
                .phasestep_i(1'h1), 
                .phaseloadreg_i(1'h1), 
                .phasesel_i(3'h7), 
                .refdetreset(1'h0), 
                .enclkop_i(1'h1), 
                .enclkos_i(1'h1), 
                .enclkos2_i(1'h0), 
                .enclkos3_i(1'h0), 
                .enclkos4_i(1'h0), 
                .enclkos5_i(1'h0), 
                .clkop_o(clkop_w), 
                .clkos_o(clkos_w), 
                .clkos2_o(), 
                .clkos3_o(), 
                .clkos4_o(), 
                .clkos5_o(), 
                .lock_o(lock_w), 
                .refdetlos(), 
                .pllpd_en_n_i(1'h0), 
                .legacy_i(1'h1), 
                .lmmi_clk_i(lmmi_clk_i), 
                .lmmi_resetn_i(lmmi_resetn_i), 
                .lmmi_request_i(lmmi_request_i), 
                .lmmi_wr_rdn_i(lmmi_wr_rdn_i), 
                .lmmi_offset_i(lmmi_offset_i), 
                .lmmi_wdata_i(lmmi_wdata_i), 
                .lmmi_ready_o(lmmi_ready_o), 
                .lmmi_rdata_valid_o(lmmi_rdata_valid_o), 
                .lmmi_rdata_o(lmmi_rdata_o), 
                .apb_pclk_i(apb_pclk_i), 
                .apb_preset_n_i(apb_preset_n_i), 
                .apb_penable_i(apb_penable_i), 
                .apb_psel_i(apb_psel_i), 
                .apb_pwrite_i(apb_pwrite_i), 
                .apb_paddr_i(apb_paddr_i), 
                .apb_pwdata_i(apb_pwdata_i), 
                .apb_pready_o(apb_pready_o), 
                .apb_pslverr_o(apb_pslverr_o), 
                .apb_prdata_o(apb_prdata_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        // DELAYA
        DELAYA #(.COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                .EDGE_MONITOR("DISABLED"),
                .WAIT_FOR_EDGE("DISABLED"),
                .DEL_MODE("USER_DEFINED"),
                .COARSE_DELAY_MODE("DYNAMIC")) u_clock_DELAYA (// Inputs
                .A(del_clk_o_w), 
                    .LOAD_N(clk_loadn_i), 
                    .MOVE(clk_move_i), 
                    .DIRECTION(clk_direction_i), 
                    .COARSE0(clk_coarse_dly_i[0]), 
                    .COARSE1(clk_coarse_dly_i[1]), 
                    .RANKENABLE(1'b0), 
                    .RANKSELECT(1'b0), 
                    .RANK0UPDATE(1'b0), 
                    .RANK1UPDATE(1'b0), 
                    // Outputs                
                .Z(clk_o), 
                    .EDETERR(), 
                    .CFLAG(clk_cflag_o)) ; 
        if ((GEARING == 2)) 
            begin : genblk1
                // ODDRX2
                ODDRX2 u_clock_ODDRX2 (// Inputs
                        .D0(1'h1), 
                            .D1(1'h0), 
                            .D2(1'h1), 
                            .D3(1'h0), 
                            .RST(rst_w), 
                            .ECLK(clkos_w), 
                            .SCLK(sclk_o), 
                            // Outputs
                        .Q(del_clk_o_w)) ; 
            end
        else
            if ((GEARING == 4)) 
                begin : genblk1
                    // ODDRX4
                    ODDRX4 u_clock_ODDRX4 (// Inputs
                            .D0(1'h1), 
                                .D1(1'h0), 
                                .D2(1'h1), 
                                .D3(1'h0), 
                                .D4(1'h1), 
                                .D5(1'h0), 
                                .D6(1'h1), 
                                .D7(1'h0), 
                                .RST(rst_w), 
                                .ECLK(clkos_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_clk_o_w)) ; 
                end
            else
                if ((GEARING == 5)) 
                    begin : genblk1
                        // ODDRX5
                        ODDRX5 u_clock_ODDRX5 (// Inputs
                                .D0(1'h1), 
                                    .D1(1'h0), 
                                    .D2(1'h1), 
                                    .D3(1'h0), 
                                    .D4(1'h1), 
                                    .D5(1'h0), 
                                    .D6(1'h1), 
                                    .D7(1'h0), 
                                    .D8(1'h1), 
                                    .D9(1'h0), 
                                    .RST(rst_w), 
                                    .ECLK(clkos_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_clk_o_w)) ; 
                    end
    endgenerate
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // DELAYA
            DELAYA #(.COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .EDGE_MONITOR("DISABLED"),
                    .WAIT_FOR_EDGE("DISABLED"),
                    .DEL_MODE("USER_DEFINED"),
                    .COARSE_DELAY_MODE("DYNAMIC")) u_data_DELAYA (// Inputs
                    .A(del_data_o_w[i]), 
                        .LOAD_N(data_loadn_i[i]), 
                        .MOVE(data_move_i[i]), 
                        .DIRECTION(data_direction_i[i]), 
                        .COARSE0(data_coarse_dly_i[((i * 2) + 0)]), 
                        .COARSE1(data_coarse_dly_i[((i * 2) + 1)]), 
                        .RANKENABLE(1'b0), 
                        .RANKSELECT(1'b0), 
                        .RANK0UPDATE(1'b0), 
                        .RANK1UPDATE(1'b0), 
                        // Outputs
                    .Z(data_o[i]), 
                        .EDETERR(), 
                        .CFLAG(data_cflag_o[i])) ; 
            if ((GEARING == 2)) 
                begin : genblk1
                    // ODDRX2
                    ODDRX2 u_data_ODDRX2 (// Inputs
                            .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                .RST(rst_w), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_data_o_w[i])) ; 
                end
            else
                if ((GEARING == 4)) 
                    begin : genblk1
                        // ODDRX4
                        ODDRX4 u_data_ODDRX4 (// Inputs
                                .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                    .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                    .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                    .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                    .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                    .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                    .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                    .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                    .RST(rst_w), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_data_o_w[i])) ; 
                    end
                else
                    if ((GEARING == 5)) 
                        begin : genblk1
                            // ODDRX5
                            ODDRX5 u_data_ODDRX5 (// Inputs
                                    .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                        .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                        .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                        .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                        .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                        .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                        .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                        .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                        .D8(data_i[(i + (BUS_WIDTH * 8))]), 
                                        .D9(data_i[(i + (BUS_WIDTH * 9))]), 
                                        .RST(rst_w), 
                                        .ECLK(eclkout_w), 
                                        .SCLK(sclk_o), 
                                        // Outputs
                                    .Q(del_data_o_w[i])) ; 
                        end
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddrx2_4_5_tx_eclk_centered_dynamic_pll.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddrx2_4_5_tx_eclk_centered_static_bypass_pll.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : 
// File                  : gddr_sync.v
// Title                 : 
// Dependencies          :
// Description           : 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 03.20.2018
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
// __RTL_MODULE__LSCC_PLL__
//--------------------------------------------------------------------------
// Local Variables:
// verilog-library-directories: ("." "C:/lscc/radiant/2.2/cae_library/simulation/verilog/lifcl")
// verilog-library-files: ("C:/lscc/radiant/2.2/cae_library/synthesis/verilog/lifcl.v")
// End:
//--------------------------------------------------------------------------
module ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_centered_static_bypass_pll #(parameter IO_TYPE = 0, 
        parameter BUS_WIDTH = 0, 
        parameter GEARING = 0, 
        parameter DATA_PATH_DELAY = 0, 
        parameter DATA_DELAY_ADJUSTMENT = 0, 
        parameter DATA_FINE_DELAY_VALUE = 0, 
        parameter DATA_COARSE_DELAY_VALUE = 0, 
        parameter FVCO = 800.0, 
        parameter CLKI_FREQ = 100.0, 
        parameter CLKOP_FREQ_ACTUAL = 100.0, 
        parameter CLKOS_FREQ_ACTUAL = 100.0, 
        parameter CLKOS2_FREQ_ACTUAL = 100.0, 
        parameter CLKOS3_FREQ_ACTUAL = 100.0, 
        parameter CLKOS4_FREQ_ACTUAL = 100.0, 
        parameter CLKOS5_FREQ_ACTUAL = 100.0, 
        parameter CLKOP_PHASE_ACTUAL = 0.0, 
        parameter CLKOS_PHASE_ACTUAL = 0.0, 
        parameter CLKOS2_PHASE_ACTUAL = 0.0, 
        parameter CLKOS3_PHASE_ACTUAL = 0.0, 
        parameter CLKOS4_PHASE_ACTUAL = 0.0, 
        parameter CLKOS5_PHASE_ACTUAL = 0.0, 
        parameter CLKOS_EN = 0, 
        parameter CLKOS2_EN = 0, 
        parameter CLKOS3_EN = 0, 
        parameter CLKOS4_EN = 0, 
        parameter CLKOS5_EN = 0, 
        parameter CLKOP_BYPASS = 0, 
        parameter CLKOS_BYPASS = 0, 
        parameter CLKOS2_BYPASS = 0, 
        parameter CLKOS3_BYPASS = 0, 
        parameter CLKOS4_BYPASS = 0, 
        parameter CLKOS5_BYPASS = 0, 
        parameter ENCLKOP_EN = 0, 
        parameter ENCLKOS_EN = 0, 
        parameter ENCLKOS2_EN = 0, 
        parameter ENCLKOS3_EN = 0, 
        parameter ENCLKOS4_EN = 0, 
        parameter ENCLKOS5_EN = 0, 
        parameter FRAC_N_EN = 0, 
        parameter SS_EN = 0, 
        parameter DYN_PORTS_EN = 0, 
        parameter PLL_RST = 0, 
        parameter LOCK_EN = 0, 
        parameter PLL_LOCK_STICKY = 0, 
        parameter LEGACY_EN = 0, 
        parameter LMMI_EN = 0, 
        parameter APB_EN = 0, 
        parameter POWERDOWN_EN = 0, 
        parameter TRIM_EN_P = 0, 
        parameter TRIM_EN_S = 0, 
        parameter PLL_REFCLK_FROM_PIN = 0, 
        parameter REF_CLK_IO_TYPE = "LVDS", 
        parameter CLKOP_TRIM_MODE = "Falling", 
        parameter CLKOS_TRIM_MODE = "Falling", 
        parameter CLKOP_TRIM = "0b0000", 
        parameter CLKOS_TRIM = "0b0000", 
        parameter FBK_MODE = "CLKOP", 
        parameter CLKI_DIVIDER_ACTUAL_STR = "1", 
        parameter FBCLK_DIVIDER_ACTUAL_STR = "1", 
        parameter DIVOP_ACTUAL_STR = "1", 
        parameter DIVOS_ACTUAL_STR = "1", 
        parameter DIVOS2_ACTUAL_STR = "1", 
        parameter DIVOS3_ACTUAL_STR = "1", 
        parameter DIVOS4_ACTUAL_STR = "1", 
        parameter DIVOS5_ACTUAL_STR = "1", 
        parameter SSC_N_CODE_STR = "0b000010100", 
        parameter SSC_F_CODE_STR = "0b000000000000000", 
        parameter SSC_PROFILE = "DOWN", 
        parameter SSC_TBASE_STR = "0b000000000000", 
        parameter SSC_STEP_IN_STR = "0b0000000", 
        parameter SSC_REG_WEIGHTING_SEL_STR = "0b000", 
        parameter DELA = "0", 
        parameter DELB = "0", 
        parameter DELC = "0", 
        parameter DELD = "0", 
        parameter DELE = "0", 
        parameter DELF = "0", 
        parameter PHIA = "0", 
        parameter PHIB = "0", 
        parameter PHIC = "0", 
        parameter PHID = "0", 
        parameter PHIE = "0", 
        parameter PHIF = "0", 
        parameter EN_REFCLK_MON = 0, 
        parameter REF_COUNTS = "0000", 
        parameter INTFBKDEL_SEL = "DISABLED", 
        parameter PMU_WAITFORLOCK = "ENABLED", 
        parameter REF_OSC_CTRL = "3P2", 
        parameter SIM_FLOAT_PRECISION = "0.1", 
        parameter IPI_CMP = "0b1000", 
        parameter CSET = "40P", 
        parameter CRIPPLE = "5P", 
        parameter IPP_CTRL = "0b1000", 
        parameter IPP_SEL = "0b1111", 
        parameter BW_CTL_BIAS = "0b0101", 
        parameter V2I_PP_RES = "10K", 
        parameter KP_VCO = "0b00011", 
        parameter V2I_KVCO_SEL = "60", 
        parameter V2I_1V_EN = "ENABLED") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // PLL parameters
    // For simulation only
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input sync_clk_i, 
    input sync_rst_i, 
    output ready_o, 
    input [(((GEARING * BUS_WIDTH) * 2) - 1):0] data_i, 
    output [(BUS_WIDTH - 1):0] data_o, 
    output clk_o, 
    output sclk_o, 
    input pll_clki_i, 
    input pll_rstn_i, 
    // LMMI bus
    input wire lmmi_clk_i, 
    input wire lmmi_resetn_i, 
    input wire lmmi_request_i, 
    input wire lmmi_wr_rdn_i, 
    input wire [6:0] lmmi_offset_i, 
    input wire [7:0] lmmi_wdata_i, 
    output wire lmmi_ready_o, 
    output wire lmmi_rdata_valid_o, 
    output wire [7:0] lmmi_rdata_o, 
    // APB bus 
    input apb_pclk_i, 
    input apb_preset_n_i, 
    input wire apb_penable_i, 
    input wire apb_psel_i, 
    input wire apb_pwrite_i, 
    input wire [6:0] apb_paddr_i, 
    input wire [7:0] apb_pwdata_i, 
    output wire apb_pready_o, 
    output wire apb_pslverr_o, 
    output wire [7:0] apb_prdata_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam DEL_MODE = ((DATA_DELAY_ADJUSTMENT == "DEFAULT") ? "ECLK_CENTERED" : "USER_DEFINED") ; 
    localparam GEARING_STR = ((GEARING == 5) ? "5" : ((GEARING == 4) ? "4" : "2")) ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire clkop_w ; //PLL CLKOP output
    wire clkos_w ; //PLL CLKOS output
    wire lock_w ; //PLL LOCK  output
    wire eclkout_w ; 
    wire rst_w ; 
    wire stop_w ; 
    wire del_clk_o_w ; 
    wire [(BUS_WIDTH - 1):0] del_data_o_w ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKDIV #(.ECLK_DIV(GEARING_STR),
            .GSR("DISABLED")) u0_ECLKDIV (.DIVOUT(sclk_o), 
                .DIVRST(rst_w), 
                .ECLKIN(eclkout_w), 
                .SLIP(1'b0)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKSYNC #(.STOP_EN("ENABLE")) u0_ECLKSYNC (.ECLKIN(clkop_w), 
                .ECLKOUT(eclkout_w), 
                .STOP(stop_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_gddr_sync u1_gddr_sync (.rst(sync_rst_i), 
                .sync_clk(sync_clk_i), 
                .start(lock_w), 
                .stop(stop_w), 
                .ddr_reset(rst_w), 
                .ready(ready_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_lscc_pll #(.FVCO(FVCO),
            .CLKI_FREQ(CLKI_FREQ),
            .CLKOP_FREQ_ACTUAL(CLKOP_FREQ_ACTUAL),
            .CLKOS_FREQ_ACTUAL(CLKOS_FREQ_ACTUAL),
            .CLKOS2_FREQ_ACTUAL(CLKOS2_FREQ_ACTUAL),
            .CLKOS3_FREQ_ACTUAL(CLKOS3_FREQ_ACTUAL),
            .CLKOS4_FREQ_ACTUAL(CLKOS4_FREQ_ACTUAL),
            .CLKOS5_FREQ_ACTUAL(CLKOS5_FREQ_ACTUAL),
            .CLKOP_PHASE_ACTUAL(CLKOP_PHASE_ACTUAL),
            .CLKOS_PHASE_ACTUAL(CLKOS_PHASE_ACTUAL),
            .CLKOS2_PHASE_ACTUAL(CLKOS2_PHASE_ACTUAL),
            .CLKOS3_PHASE_ACTUAL(CLKOS3_PHASE_ACTUAL),
            .CLKOS4_PHASE_ACTUAL(CLKOS4_PHASE_ACTUAL),
            .CLKOS5_PHASE_ACTUAL(CLKOS5_PHASE_ACTUAL),
            .CLKOS_EN(CLKOS_EN),
            .CLKOS2_EN(CLKOS2_EN),
            .CLKOS3_EN(CLKOS3_EN),
            .CLKOS4_EN(CLKOS4_EN),
            .CLKOS5_EN(CLKOS5_EN),
            .CLKOP_BYPASS(CLKOP_BYPASS),
            .CLKOS_BYPASS(CLKOS_BYPASS),
            .CLKOS2_BYPASS(CLKOS2_BYPASS),
            .CLKOS3_BYPASS(CLKOS3_BYPASS),
            .CLKOS4_BYPASS(CLKOS4_BYPASS),
            .CLKOS5_BYPASS(CLKOS5_BYPASS),
            .ENCLKOP_EN(ENCLKOP_EN),
            .ENCLKOS_EN(ENCLKOS_EN),
            .ENCLKOS2_EN(ENCLKOS2_EN),
            .ENCLKOS3_EN(ENCLKOS3_EN),
            .ENCLKOS4_EN(ENCLKOS4_EN),
            .ENCLKOS5_EN(ENCLKOS5_EN),
            .FRAC_N_EN(FRAC_N_EN),
            .SS_EN(SS_EN),
            .DYN_PORTS_EN(DYN_PORTS_EN),
            .PLL_RST(PLL_RST),
            .LOCK_EN(LOCK_EN),
            .PLL_LOCK_STICKY(PLL_LOCK_STICKY),
            .LEGACY_EN(LEGACY_EN),
            .LMMI_EN(LMMI_EN),
            .APB_EN(APB_EN),
            .POWERDOWN_EN(POWERDOWN_EN),
            .TRIM_EN_P(TRIM_EN_P),
            .TRIM_EN_S(TRIM_EN_S),
            .PLL_REFCLK_FROM_PIN(PLL_REFCLK_FROM_PIN),
            .REF_CLK_IO_TYPE(REF_CLK_IO_TYPE),
            .CLKOP_TRIM_MODE(CLKOP_TRIM_MODE),
            .CLKOS_TRIM_MODE(CLKOS_TRIM_MODE),
            .CLKOP_TRIM(CLKOP_TRIM),
            .CLKOS_TRIM(CLKOS_TRIM),
            .FBK_MODE(FBK_MODE),
            .CLKI_DIVIDER_ACTUAL_STR(CLKI_DIVIDER_ACTUAL_STR),
            .FBCLK_DIVIDER_ACTUAL_STR(FBCLK_DIVIDER_ACTUAL_STR),
            .DIVOP_ACTUAL_STR(DIVOP_ACTUAL_STR),
            .DIVOS_ACTUAL_STR(DIVOS_ACTUAL_STR),
            .DIVOS2_ACTUAL_STR(DIVOS2_ACTUAL_STR),
            .DIVOS3_ACTUAL_STR(DIVOS3_ACTUAL_STR),
            .DIVOS4_ACTUAL_STR(DIVOS4_ACTUAL_STR),
            .DIVOS5_ACTUAL_STR(DIVOS5_ACTUAL_STR),
            .SSC_N_CODE_STR(SSC_N_CODE_STR),
            .SSC_F_CODE_STR(SSC_F_CODE_STR),
            .SSC_PROFILE(SSC_PROFILE),
            .SSC_TBASE_STR(SSC_TBASE_STR),
            .SSC_STEP_IN_STR(SSC_STEP_IN_STR),
            .SSC_REG_WEIGHTING_SEL_STR(SSC_REG_WEIGHTING_SEL_STR),
            .DELA(DELA),
            .DELB(DELB),
            .DELC(DELC),
            .DELD(DELD),
            .DELE(DELE),
            .DELF(DELF),
            .PHIA(PHIA),
            .PHIB(PHIB),
            .PHIC(PHIC),
            .PHID(PHID),
            .PHIE(PHIE),
            .PHIF(PHIF),
            .IPI_CMP(IPI_CMP),
            .CSET(CSET),
            .CRIPPLE(CRIPPLE),
            .IPP_CTRL(IPP_CTRL),
            .IPP_SEL(IPP_SEL),
            .BW_CTL_BIAS(BW_CTL_BIAS),
            .V2I_PP_RES(V2I_PP_RES),
            .KP_VCO(KP_VCO),
            .V2I_KVCO_SEL(V2I_KVCO_SEL),
            .V2I_1V_EN(V2I_1V_EN),
            .REF_COUNTS(REF_COUNTS),
            .INTFBKDEL_SEL(INTFBKDEL_SEL),
            .PMU_WAITFORLOCK(PMU_WAITFORLOCK),
            .EN_REFCLK_MON(EN_REFCLK_MON),
            .REF_OSC_CTRL(REF_OSC_CTRL),
            .SIM_FLOAT_PRECISION(SIM_FLOAT_PRECISION)) u_lscc_pll_inst (.rstn_i(pll_rstn_i), 
                .clki_i(pll_clki_i), 
                .usr_fbclk_i(1'h0), 
                .phasedir_i(1'h1), 
                .phasestep_i(1'h1), 
                .phaseloadreg_i(1'h1), 
                .phasesel_i(3'h7), 
                .refdetreset(1'h0), 
                .enclkop_i(1'h1), 
                .enclkos_i(1'h1), 
                .enclkos2_i(1'h0), 
                .enclkos3_i(1'h0), 
                .enclkos4_i(1'h0), 
                .enclkos5_i(1'h0), 
                .clkop_o(clkop_w), 
                .clkos_o(clkos_w), 
                .clkos2_o(), 
                .clkos3_o(), 
                .clkos4_o(), 
                .clkos5_o(), 
                .lock_o(lock_w), 
                .refdetlos(), 
                .pllpd_en_n_i(1'h0), 
                .legacy_i(1'h1), 
                .lmmi_clk_i(lmmi_clk_i), 
                .lmmi_resetn_i(lmmi_resetn_i), 
                .lmmi_request_i(lmmi_request_i), 
                .lmmi_wr_rdn_i(lmmi_wr_rdn_i), 
                .lmmi_offset_i(lmmi_offset_i), 
                .lmmi_wdata_i(lmmi_wdata_i), 
                .lmmi_ready_o(lmmi_ready_o), 
                .lmmi_rdata_valid_o(lmmi_rdata_valid_o), 
                .lmmi_rdata_o(lmmi_rdata_o), 
                .apb_pclk_i(apb_pclk_i), 
                .apb_preset_n_i(apb_preset_n_i), 
                .apb_penable_i(apb_penable_i), 
                .apb_psel_i(apb_psel_i), 
                .apb_pwrite_i(apb_pwrite_i), 
                .apb_paddr_i(apb_paddr_i), 
                .apb_pwdata_i(apb_pwdata_i), 
                .apb_pready_o(apb_pready_o), 
                .apb_pslverr_o(apb_pslverr_o), 
                .apb_prdata_o(apb_prdata_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        if ((DATA_PATH_DELAY == "BYPASS")) 
            begin : CLOCK_DEL_BYPASS
                assign clk_o = del_clk_o_w ; 
            end
        else
            begin : CLOCK_DEL_STATIC
                // DELAYB
                DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                        .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                        .DEL_MODE(DEL_MODE)) u_clock_DELAYB (// Always "USER_DEFINED".
                        .A(del_clk_o_w), 
                            .Z(clk_o)) ; 
            end
        if ((GEARING == 2)) 
            begin : genblk2
                // ODDRX2
                ODDRX2 u_clock_ODDRX2 (// Inputs
                        .D0(1'h1), 
                            .D1(1'h0), 
                            .D2(1'h1), 
                            .D3(1'h0), 
                            .RST(rst_w), 
                            .ECLK(clkos_w), 
                            .SCLK(sclk_o), 
                            // Outputs
                        .Q(del_clk_o_w)) ; 
            end
        else
            if ((GEARING == 4)) 
                begin : genblk2
                    // ODDRX4
                    ODDRX4 u_clock_ODDRX4 (// Inputs
                            .D0(1'h1), 
                                .D1(1'h0), 
                                .D2(1'h1), 
                                .D3(1'h0), 
                                .D4(1'h1), 
                                .D5(1'h0), 
                                .D6(1'h1), 
                                .D7(1'h0), 
                                .RST(rst_w), 
                                .ECLK(clkos_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_clk_o_w)) ; 
                end
            else
                if ((GEARING == 5)) 
                    begin : genblk2
                        // ODDRX5
                        ODDRX5 u_clock_ODDRX5 (// Inputs
                                .D0(1'h1), 
                                    .D1(1'h0), 
                                    .D2(1'h1), 
                                    .D3(1'h0), 
                                    .D4(1'h1), 
                                    .D5(1'h0), 
                                    .D6(1'h1), 
                                    .D7(1'h0), 
                                    .D8(1'h1), 
                                    .D9(1'h0), 
                                    .RST(rst_w), 
                                    .ECLK(clkos_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_clk_o_w)) ; 
                    end
    endgenerate
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            if ((DATA_PATH_DELAY == "BYPASS")) 
                begin : DATA_DEL_BYPASS
                    assign data_o[i] = del_data_o_w[i] ; 
                end
            else
                begin : DATA_DEL_STATIC
                    // DELAYB
                    DELAYB #(.DEL_VALUE(DATA_FINE_DELAY_VALUE),
                            .COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                            .DEL_MODE(DEL_MODE)) u_data_DELAYB (// Always "USER_DEFINED".
                            .A(del_data_o_w[i]), 
                                .Z(data_o[i])) ; 
                end
            if ((GEARING == 2)) 
                begin : genblk2
                    // ODDRX2
                    ODDRX2 u_data_ODDRX2 (// Inputs
                            .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                .RST(rst_w), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_data_o_w[i])) ; 
                end
            else
                if ((GEARING == 4)) 
                    begin : genblk2
                        // ODDRX4
                        ODDRX4 u_data_ODDRX4 (// Inputs
                                .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                    .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                    .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                    .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                    .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                    .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                    .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                    .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                    .RST(rst_w), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_data_o_w[i])) ; 
                    end
                else
                    if ((GEARING == 5)) 
                        begin : genblk2
                            // ODDRX5
                            ODDRX5 u_data_ODDRX5 (// Inputs
                                    .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                        .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                        .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                        .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                        .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                        .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                        .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                        .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                        .D8(data_i[(i + (BUS_WIDTH * 8))]), 
                                        .D9(data_i[(i + (BUS_WIDTH * 9))]), 
                                        .RST(rst_w), 
                                        .ECLK(eclkout_w), 
                                        .SCLK(sclk_o), 
                                        // Outputs
                                    .Q(del_data_o_w[i])) ; 
                        end
        end
    endgenerate

// 4Nu
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddrx2_4_5_tx_eclk_centered_static_bypass_pll.v
//==============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               :
// File                  : lscc_gddrx2_4_5_tx_eclk_centered_dynamic_tri_state_control_pll.v
// Title                 :
// Dependencies          :
// Description           :
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 
// Changes Made          : Initial release.
// =============================================================================
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
// __RTL_MODULE__LSCC_PLL__
//--------------------------------------------------------------------------
// Local Variables:
// verilog-library-directories: ("." "C:/lscc/radiant/2.2/cae_library/simulation/verilog/lifcl")
// verilog-library-files: ("C:/lscc/radiant/2.2/cae_library/synthesis/verilog/lifcl.v")
// End:
//--------------------------------------------------------------------------
// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2022 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement. 
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02 
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS         
// Project               : 
// File                  : gddr_sync.v
// Title                 : 
// Dependencies          :
// Description           : 
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             : 
// Mod. Date             : 03.20.2018
// Changes Made          : Initial release.
// =============================================================================
module ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_centered_dynamic_tri_state_control_pll #(parameter IO_TYPE = 0, 
        parameter BUS_WIDTH = 0, 
        parameter GEARING = 0, 
        parameter DATA_PATH_DELAY = 0, 
        parameter DATA_DELAY_ADJUSTMENT = 0, 
        parameter DATA_FINE_DELAY_VALUE = 0, 
        parameter DATA_COARSE_DELAY_VALUE = 0, 
        parameter FVCO = 800.0, 
        parameter CLKI_FREQ = 100.0, 
        parameter CLKOP_FREQ_ACTUAL = 100.0, 
        parameter CLKOS_FREQ_ACTUAL = 100.0, 
        parameter CLKOS2_FREQ_ACTUAL = 100.0, 
        parameter CLKOS3_FREQ_ACTUAL = 100.0, 
        parameter CLKOS4_FREQ_ACTUAL = 100.0, 
        parameter CLKOS5_FREQ_ACTUAL = 100.0, 
        parameter CLKOP_PHASE_ACTUAL = 0.0, 
        parameter CLKOS_PHASE_ACTUAL = 0.0, 
        parameter CLKOS2_PHASE_ACTUAL = 0.0, 
        parameter CLKOS3_PHASE_ACTUAL = 0.0, 
        parameter CLKOS4_PHASE_ACTUAL = 0.0, 
        parameter CLKOS5_PHASE_ACTUAL = 0.0, 
        parameter CLKOS_EN = 0, 
        parameter CLKOS2_EN = 0, 
        parameter CLKOS3_EN = 0, 
        parameter CLKOS4_EN = 0, 
        parameter CLKOS5_EN = 0, 
        parameter CLKOP_BYPASS = 0, 
        parameter CLKOS_BYPASS = 0, 
        parameter CLKOS2_BYPASS = 0, 
        parameter CLKOS3_BYPASS = 0, 
        parameter CLKOS4_BYPASS = 0, 
        parameter CLKOS5_BYPASS = 0, 
        parameter ENCLKOP_EN = 0, 
        parameter ENCLKOS_EN = 0, 
        parameter ENCLKOS2_EN = 0, 
        parameter ENCLKOS3_EN = 0, 
        parameter ENCLKOS4_EN = 0, 
        parameter ENCLKOS5_EN = 0, 
        parameter FRAC_N_EN = 0, 
        parameter SS_EN = 0, 
        parameter DYN_PORTS_EN = 0, 
        parameter PLL_RST = 0, 
        parameter LOCK_EN = 0, 
        parameter PLL_LOCK_STICKY = 0, 
        parameter LEGACY_EN = 0, 
        parameter LMMI_EN = 0, 
        parameter APB_EN = 0, 
        parameter POWERDOWN_EN = 0, 
        parameter TRIM_EN_P = 0, 
        parameter TRIM_EN_S = 0, 
        parameter PLL_REFCLK_FROM_PIN = 0, 
        parameter REF_CLK_IO_TYPE = "LVDS", 
        parameter CLKOP_TRIM_MODE = "Falling", 
        parameter CLKOS_TRIM_MODE = "Falling", 
        parameter CLKOP_TRIM = "0b0000", 
        parameter CLKOS_TRIM = "0b0000", 
        parameter FBK_MODE = "CLKOP", 
        parameter CLKI_DIVIDER_ACTUAL_STR = "1", 
        parameter FBCLK_DIVIDER_ACTUAL_STR = "1", 
        parameter DIVOP_ACTUAL_STR = "1", 
        parameter DIVOS_ACTUAL_STR = "1", 
        parameter DIVOS2_ACTUAL_STR = "1", 
        parameter DIVOS3_ACTUAL_STR = "1", 
        parameter DIVOS4_ACTUAL_STR = "1", 
        parameter DIVOS5_ACTUAL_STR = "1", 
        parameter SSC_N_CODE_STR = "0b000010100", 
        parameter SSC_F_CODE_STR = "0b000000000000000", 
        parameter SSC_PROFILE = "DOWN", 
        parameter SSC_TBASE_STR = "0b000000000000", 
        parameter SSC_STEP_IN_STR = "0b0000000", 
        parameter SSC_REG_WEIGHTING_SEL_STR = "0b000", 
        parameter DELA = "0", 
        parameter DELB = "0", 
        parameter DELC = "0", 
        parameter DELD = "0", 
        parameter DELE = "0", 
        parameter DELF = "0", 
        parameter PHIA = "0", 
        parameter PHIB = "0", 
        parameter PHIC = "0", 
        parameter PHID = "0", 
        parameter PHIE = "0", 
        parameter PHIF = "0", 
        parameter EN_REFCLK_MON = 0, 
        parameter REF_COUNTS = "0000", 
        parameter INTFBKDEL_SEL = "DISABLED", 
        parameter PMU_WAITFORLOCK = "ENABLED", 
        parameter REF_OSC_CTRL = "3P2", 
        parameter SIM_FLOAT_PRECISION = "0.1", 
        parameter IPI_CMP = "0b1000", 
        parameter CSET = "40P", 
        parameter CRIPPLE = "5P", 
        parameter IPP_CTRL = "0b1000", 
        parameter IPP_SEL = "0b1111", 
        parameter BW_CTL_BIAS = "0b0101", 
        parameter V2I_PP_RES = "10K", 
        parameter KP_VCO = "0b00011", 
        parameter V2I_KVCO_SEL = "60", 
        parameter V2I_1V_EN = "ENABLED") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // PLL parameters
    // For simulation only
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input [((2 * BUS_WIDTH) - 1):0] data_coarse_dly_i, 
    input [1:0] clk_coarse_dly_i, 
    input [(BUS_WIDTH - 1):0] data_move_i, 
    input clk_move_i, 
    input [(BUS_WIDTH - 1):0] data_loadn_i, 
    input clk_loadn_i, 
    input [(BUS_WIDTH - 1):0] data_direction_i, 
    input clk_direction_i, 
    output [(BUS_WIDTH - 1):0] data_cflag_o, 
    output clk_cflag_o, 
    input outen_n_i, 
    input [(((GEARING * BUS_WIDTH) * 2) - 1):0] data_i, 
    input sync_clk_i, 
    input sync_rst_i, 
    output ready_o, 
    output [(BUS_WIDTH - 1):0] data_o, 
    output clk_o, 
    output sclk_o, 
    input pll_clki_i, 
    input pll_rstn_i, 
    // LMMI bus
    input wire lmmi_clk_i, 
    input wire lmmi_resetn_i, 
    input wire lmmi_request_i, 
    input wire lmmi_wr_rdn_i, 
    input wire [6:0] lmmi_offset_i, 
    input wire [7:0] lmmi_wdata_i, 
    output wire lmmi_ready_o, 
    output wire lmmi_rdata_valid_o, 
    output wire [7:0] lmmi_rdata_o, 
    // APB bus 
    input apb_pclk_i, 
    input apb_preset_n_i, 
    input wire apb_penable_i, 
    input wire apb_psel_i, 
    input wire apb_pwrite_i, 
    input wire [6:0] apb_paddr_i, 
    input wire [7:0] apb_pwdata_i, 
    output wire apb_pready_o, 
    output wire apb_pslverr_o, 
    output wire [7:0] apb_prdata_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    localparam GEARING_STR = ((GEARING == 5) ? "5" : ((GEARING == 4) ? "4" : "2")) ; 
    // -----------------------------------------------------------------------------
    // Wire Declarations
    // -----------------------------------------------------------------------------
    wire [(BUS_WIDTH - 1):0] data_q_obz_i_w ; 
    wire clock_q_obz_i_w ; 
    wire outen_n_i_w ; 
    wire clkop_w ; //PLL CLKOP output
    wire clkos_w ; //PLL CLKOS output
    wire lock_w ; //PLL LOCK output
    wire eclkout_w ; 
    wire rst_w ; 
    wire stop_w ; 
    wire [(BUS_WIDTH - 1):0] outen_n_w ; 
    wire outen_n_clk_w ; 
    wire del_clk_o_w ; 
    wire [(BUS_WIDTH - 1):0] del_data_o_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKDIV #(.ECLK_DIV(GEARING_STR),
            .GSR("DISABLED")) u0_ECLKDIV (.DIVOUT(sclk_o), 
                .DIVRST(rst_w), 
                .ECLKIN(eclkout_w), 
                .SLIP(1'b0)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ECLKSYNC #(.STOP_EN("ENABLE")) u0_ECLKSYNC (.ECLKIN(clkop_w), 
                .ECLKOUT(eclkout_w), 
                .STOP(stop_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_gddr_sync u1_gddr_sync (.rst(sync_rst_i), 
                .sync_clk(sync_clk_i), 
                .start(lock_w), 
                .stop(stop_w), 
                .ddr_reset(rst_w), 
                .ready(ready_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    ddr_rx_ipgen_lscc_pll #(.FVCO(FVCO),
            .CLKI_FREQ(CLKI_FREQ),
            .CLKOP_FREQ_ACTUAL(CLKOP_FREQ_ACTUAL),
            .CLKOS_FREQ_ACTUAL(CLKOS_FREQ_ACTUAL),
            .CLKOS2_FREQ_ACTUAL(CLKOS2_FREQ_ACTUAL),
            .CLKOS3_FREQ_ACTUAL(CLKOS3_FREQ_ACTUAL),
            .CLKOS4_FREQ_ACTUAL(CLKOS4_FREQ_ACTUAL),
            .CLKOS5_FREQ_ACTUAL(CLKOS5_FREQ_ACTUAL),
            .CLKOP_PHASE_ACTUAL(CLKOP_PHASE_ACTUAL),
            .CLKOS_PHASE_ACTUAL(CLKOS_PHASE_ACTUAL),
            .CLKOS2_PHASE_ACTUAL(CLKOS2_PHASE_ACTUAL),
            .CLKOS3_PHASE_ACTUAL(CLKOS3_PHASE_ACTUAL),
            .CLKOS4_PHASE_ACTUAL(CLKOS4_PHASE_ACTUAL),
            .CLKOS5_PHASE_ACTUAL(CLKOS5_PHASE_ACTUAL),
            .CLKOS_EN(CLKOS_EN),
            .CLKOS2_EN(CLKOS2_EN),
            .CLKOS3_EN(CLKOS3_EN),
            .CLKOS4_EN(CLKOS4_EN),
            .CLKOS5_EN(CLKOS5_EN),
            .CLKOP_BYPASS(CLKOP_BYPASS),
            .CLKOS_BYPASS(CLKOS_BYPASS),
            .CLKOS2_BYPASS(CLKOS2_BYPASS),
            .CLKOS3_BYPASS(CLKOS3_BYPASS),
            .CLKOS4_BYPASS(CLKOS4_BYPASS),
            .CLKOS5_BYPASS(CLKOS5_BYPASS),
            .ENCLKOP_EN(ENCLKOP_EN),
            .ENCLKOS_EN(ENCLKOS_EN),
            .ENCLKOS2_EN(ENCLKOS2_EN),
            .ENCLKOS3_EN(ENCLKOS3_EN),
            .ENCLKOS4_EN(ENCLKOS4_EN),
            .ENCLKOS5_EN(ENCLKOS5_EN),
            .FRAC_N_EN(FRAC_N_EN),
            .SS_EN(SS_EN),
            .DYN_PORTS_EN(DYN_PORTS_EN),
            .PLL_RST(PLL_RST),
            .LOCK_EN(LOCK_EN),
            .PLL_LOCK_STICKY(PLL_LOCK_STICKY),
            .LEGACY_EN(LEGACY_EN),
            .LMMI_EN(LMMI_EN),
            .APB_EN(APB_EN),
            .POWERDOWN_EN(POWERDOWN_EN),
            .TRIM_EN_P(TRIM_EN_P),
            .TRIM_EN_S(TRIM_EN_S),
            .PLL_REFCLK_FROM_PIN(PLL_REFCLK_FROM_PIN),
            .REF_CLK_IO_TYPE(REF_CLK_IO_TYPE),
            .CLKOP_TRIM_MODE(CLKOP_TRIM_MODE),
            .CLKOS_TRIM_MODE(CLKOS_TRIM_MODE),
            .CLKOP_TRIM(CLKOP_TRIM),
            .CLKOS_TRIM(CLKOS_TRIM),
            .FBK_MODE(FBK_MODE),
            .CLKI_DIVIDER_ACTUAL_STR(CLKI_DIVIDER_ACTUAL_STR),
            .FBCLK_DIVIDER_ACTUAL_STR(FBCLK_DIVIDER_ACTUAL_STR),
            .DIVOP_ACTUAL_STR(DIVOP_ACTUAL_STR),
            .DIVOS_ACTUAL_STR(DIVOS_ACTUAL_STR),
            .DIVOS2_ACTUAL_STR(DIVOS2_ACTUAL_STR),
            .DIVOS3_ACTUAL_STR(DIVOS3_ACTUAL_STR),
            .DIVOS4_ACTUAL_STR(DIVOS4_ACTUAL_STR),
            .DIVOS5_ACTUAL_STR(DIVOS5_ACTUAL_STR),
            .SSC_N_CODE_STR(SSC_N_CODE_STR),
            .SSC_F_CODE_STR(SSC_F_CODE_STR),
            .SSC_PROFILE(SSC_PROFILE),
            .SSC_TBASE_STR(SSC_TBASE_STR),
            .SSC_STEP_IN_STR(SSC_STEP_IN_STR),
            .SSC_REG_WEIGHTING_SEL_STR(SSC_REG_WEIGHTING_SEL_STR),
            .DELA(DELA),
            .DELB(DELB),
            .DELC(DELC),
            .DELD(DELD),
            .DELE(DELE),
            .DELF(DELF),
            .PHIA(PHIA),
            .PHIB(PHIB),
            .PHIC(PHIC),
            .PHID(PHID),
            .PHIE(PHIE),
            .PHIF(PHIF),
            .IPI_CMP(IPI_CMP),
            .CSET(CSET),
            .CRIPPLE(CRIPPLE),
            .IPP_CTRL(IPP_CTRL),
            .IPP_SEL(IPP_SEL),
            .BW_CTL_BIAS(BW_CTL_BIAS),
            .V2I_PP_RES(V2I_PP_RES),
            .KP_VCO(KP_VCO),
            .V2I_KVCO_SEL(V2I_KVCO_SEL),
            .V2I_1V_EN(V2I_1V_EN),
            .REF_COUNTS(REF_COUNTS),
            .INTFBKDEL_SEL(INTFBKDEL_SEL),
            .PMU_WAITFORLOCK(PMU_WAITFORLOCK),
            .EN_REFCLK_MON(EN_REFCLK_MON),
            .REF_OSC_CTRL(REF_OSC_CTRL),
            .SIM_FLOAT_PRECISION(SIM_FLOAT_PRECISION)) u_lscc_pll_inst (.rstn_i(pll_rstn_i), 
                .clki_i(pll_clki_i), 
                .usr_fbclk_i(1'h0), 
                .phasedir_i(1'h1), 
                .phasestep_i(1'h1), 
                .phaseloadreg_i(1'h1), 
                .phasesel_i(3'h7), 
                .refdetreset(1'h0), 
                .enclkop_i(1'h1), 
                .enclkos_i(1'h1), 
                .enclkos2_i(1'h0), 
                .enclkos3_i(1'h0), 
                .enclkos4_i(1'h0), 
                .enclkos5_i(1'h0), 
                .clkop_o(clkop_w), 
                .clkos_o(clkos_w), 
                .clkos2_o(), 
                .clkos3_o(), 
                .clkos4_o(), 
                .clkos5_o(), 
                .lock_o(lock_w), 
                .refdetlos(), 
                .pllpd_en_n_i(1'h0), 
                .legacy_i(1'h1), 
                .lmmi_clk_i(lmmi_clk_i), 
                .lmmi_resetn_i(lmmi_resetn_i), 
                .lmmi_request_i(lmmi_request_i), 
                .lmmi_wr_rdn_i(lmmi_wr_rdn_i), 
                .lmmi_offset_i(lmmi_offset_i), 
                .lmmi_wdata_i(lmmi_wdata_i), 
                .lmmi_ready_o(lmmi_ready_o), 
                .lmmi_rdata_valid_o(lmmi_rdata_valid_o), 
                .lmmi_rdata_o(lmmi_rdata_o), 
                .apb_pclk_i(apb_pclk_i), 
                .apb_preset_n_i(apb_preset_n_i), 
                .apb_penable_i(apb_penable_i), 
                .apb_psel_i(apb_psel_i), 
                .apb_pwrite_i(apb_pwrite_i), 
                .apb_paddr_i(apb_paddr_i), 
                .apb_pwdata_i(apb_pwdata_i), 
                .apb_pready_o(apb_pready_o), 
                .apb_pslverr_o(apb_pslverr_o), 
                .apb_prdata_o(apb_prdata_o)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    // FD1P3BX
    FD1P3BX #(.GSR("ENABLED")) u_data_FD1P3BX (// Inputs
            .D(outen_n_i), 
                .CK(sclk_o), 
                .SP(1'h1), 
                .PD(rst_w), 
                // Outputs
            .Q(outen_n_i_w)) ; 
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        // OBZ
        OBZ u_clock_OBZ (.I(clock_q_obz_i_w), 
                    .T(outen_n_i_w), 
                    .O(clk_o)) ; 
        // DELAYA
        DELAYA #(.COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                .EDGE_MONITOR("DISABLED"),
                .WAIT_FOR_EDGE("DISABLED"),
                .DEL_MODE("USER_DEFINED"),
                .COARSE_DELAY_MODE("DYNAMIC")) u_clock_DELAYA (// Inputs
                .A(del_clk_o_w), 
                    .LOAD_N(clk_loadn_i), 
                    .MOVE(clk_move_i), 
                    .DIRECTION(clk_direction_i), 
                    .COARSE0(clk_coarse_dly_i[0]), 
                    .COARSE1(clk_coarse_dly_i[1]), 
                    .RANKENABLE(1'b0), 
                    .RANKSELECT(1'b0), 
                    .RANK0UPDATE(1'b0), 
                    .RANK1UPDATE(1'b0), 
                    // Outputs                
                .Z(clock_q_obz_i_w), 
                    .EDETERR(), 
                    .CFLAG(clk_cflag_o)) ; 
        if ((GEARING == 2)) 
            begin : genblk1
                // ODDRX2
                ODDRX2 u_clock_ODDRX2 (// Inputs
                        .D0(1'h1), 
                            .D1(1'h0), 
                            .D2(1'h1), 
                            .D3(1'h0), 
                            .RST(rst_w), 
                            .ECLK(clkos_w), 
                            .SCLK(sclk_o), 
                            // Outputs
                        .Q(del_clk_o_w)) ; 
            end
        else
            if ((GEARING == 4)) 
                begin : genblk1
                    // ODDRX4
                    ODDRX4 u_clock_ODDRX4 (// Inputs
                            .D0(1'h1), 
                                .D1(1'h0), 
                                .D2(1'h1), 
                                .D3(1'h0), 
                                .D4(1'h1), 
                                .D5(1'h0), 
                                .D6(1'h1), 
                                .D7(1'h0), 
                                .RST(rst_w), 
                                .ECLK(clkos_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_clk_o_w)) ; 
                end
            else
                if ((GEARING == 5)) 
                    begin : genblk1
                        // ODDRX5
                        ODDRX5 u_clock_ODDRX5 (// Inputs
                                .D0(1'h1), 
                                    .D1(1'h0), 
                                    .D2(1'h1), 
                                    .D3(1'h0), 
                                    .D4(1'h1), 
                                    .D5(1'h0), 
                                    .D6(1'h1), 
                                    .D7(1'h0), 
                                    .D8(1'h1), 
                                    .D9(1'h0), 
                                    .RST(rst_w), 
                                    .ECLK(clkos_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_clk_o_w)) ; 
                    end
    endgenerate
    // -----------------------------------------------------------------------------
    // Submodule Instantiations
    // -----------------------------------------------------------------------------
    generate
        for (i = 0;(i < BUS_WIDTH);i = (i + 1))
        begin : Data
            // OBZ
            OBZ u_data_OBZ (.I(data_q_obz_i_w[i]), 
                        .T(outen_n_i_w), 
                        .O(data_o[i])) ; 
            // DELAYA
            DELAYA #(.COARSE_DELAY(DATA_COARSE_DELAY_VALUE),
                    .DEL_VALUE(DATA_FINE_DELAY_VALUE),
                    .EDGE_MONITOR("DISABLED"),
                    .WAIT_FOR_EDGE("DISABLED"),
                    .DEL_MODE("USER_DEFINED"),
                    .COARSE_DELAY_MODE("DYNAMIC")) u_data_DELAYA (// Inputs
                    .A(del_data_o_w[i]), 
                        .LOAD_N(data_loadn_i[i]), 
                        .MOVE(data_move_i[i]), 
                        .DIRECTION(data_direction_i[i]), 
                        .COARSE0(data_coarse_dly_i[((i * 2) + 0)]), 
                        .COARSE1(data_coarse_dly_i[((i * 2) + 1)]), 
                        .RANKENABLE(1'b0), 
                        .RANKSELECT(1'b0), 
                        .RANK0UPDATE(1'b0), 
                        .RANK1UPDATE(1'b0), 
                        // Outputs
                    .Z(data_q_obz_i_w[i]), 
                        .EDETERR(), 
                        .CFLAG(data_cflag_o[i])) ; 
            if ((GEARING == 2)) 
                begin : genblk1
                    // ODDRX2
                    ODDRX2 u_data_ODDRX2 (// Inputs
                            .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                .RST(rst_w), 
                                .ECLK(eclkout_w), 
                                .SCLK(sclk_o), 
                                // Outputs
                            .Q(del_data_o_w[i])) ; 
                end
            else
                if ((GEARING == 4)) 
                    begin : genblk1
                        // ODDRX4
                        ODDRX4 u_data_ODDRX4 (// Inputs
                                .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                    .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                    .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                    .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                    .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                    .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                    .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                    .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                    .RST(rst_w), 
                                    .ECLK(eclkout_w), 
                                    .SCLK(sclk_o), 
                                    // Outputs
                                .Q(del_data_o_w[i])) ; 
                    end
                else
                    if ((GEARING == 5)) 
                        begin : genblk1
                            // ODDRX5
                            ODDRX5 u_data_ODDRX5 (// Inputs
                                    .D0(data_i[(i + (BUS_WIDTH * 0))]), 
                                        .D1(data_i[(i + (BUS_WIDTH * 1))]), 
                                        .D2(data_i[(i + (BUS_WIDTH * 2))]), 
                                        .D3(data_i[(i + (BUS_WIDTH * 3))]), 
                                        .D4(data_i[(i + (BUS_WIDTH * 4))]), 
                                        .D5(data_i[(i + (BUS_WIDTH * 5))]), 
                                        .D6(data_i[(i + (BUS_WIDTH * 6))]), 
                                        .D7(data_i[(i + (BUS_WIDTH * 7))]), 
                                        .D8(data_i[(i + (BUS_WIDTH * 8))]), 
                                        .D9(data_i[(i + (BUS_WIDTH * 9))]), 
                                        .RST(rst_w), 
                                        .ECLK(eclkout_w), 
                                        .SCLK(sclk_o), 
                                        // Outputs
                                    .Q(del_data_o_w[i])) ; 
                        end
        end
    endgenerate
endmodule



`timescale 100fs/100fs
//==============================================================================
// lscc_gddrx2_4_5_tx_eclk_centered_dynamic_tri_state_control_pll.v
//==============================================================================
module ddr_rx_ipgen_lscc_gddr #(parameter INTERFACE_TYPE = 0, 
        parameter IO_TYPE = 0, 
        parameter BUS_WIDTH = 0, 
        parameter GEARING = 0, 
        parameter OUT_WIDTH = 0, 
        parameter IN_WIDTH = 0, 
        parameter CLK_FREQ = 0, 
        parameter DATA_PATH_DELAY = 0, 
        parameter CLOCK_PATH_DELAY = 0, 
        parameter DATA_DELAY_ADJUSTMENT = 0, 
        parameter DATA_FINE_DELAY_VALUE = 0, 
        parameter D_FINE_DEL_INPUT = 0, 
        parameter DATA_COARSE_DELAY_VALUE = 0, 
        parameter CLOCK_DATA_RELATION = 0, 
        parameter INCLUDE_GDDR_SYNC = 0, 
        parameter TRISTATE_EN = 0, 
        parameter PLL_ENABLE = 0, 
        parameter FVCO = 800.0, 
        parameter CLKI_FREQ = 100.0, 
        parameter CLKOP_FREQ_ACTUAL = 100.0, 
        parameter CLKOS_FREQ_ACTUAL = 100.0, 
        parameter CLKOS2_FREQ_ACTUAL = 100.0, 
        parameter CLKOS3_FREQ_ACTUAL = 100.0, 
        parameter CLKOS4_FREQ_ACTUAL = 100.0, 
        parameter CLKOS5_FREQ_ACTUAL = 100.0, 
        parameter CLKOP_PHASE_ACTUAL = 0.0, 
        parameter CLKOS_PHASE_ACTUAL = 0.0, 
        parameter CLKOS2_PHASE_ACTUAL = 0.0, 
        parameter CLKOS3_PHASE_ACTUAL = 0.0, 
        parameter CLKOS4_PHASE_ACTUAL = 0.0, 
        parameter CLKOS5_PHASE_ACTUAL = 0.0, 
        parameter CLKOS_EN = 0, 
        parameter CLKOS2_EN = 0, 
        parameter CLKOS3_EN = 0, 
        parameter CLKOS4_EN = 0, 
        parameter CLKOS5_EN = 0, 
        parameter CLKOP_BYPASS = 0, 
        parameter CLKOS_BYPASS = 0, 
        parameter CLKOS2_BYPASS = 0, 
        parameter CLKOS3_BYPASS = 0, 
        parameter CLKOS4_BYPASS = 0, 
        parameter CLKOS5_BYPASS = 0, 
        parameter ENCLKOP_EN = 0, 
        parameter ENCLKOS_EN = 0, 
        parameter ENCLKOS2_EN = 0, 
        parameter ENCLKOS3_EN = 0, 
        parameter ENCLKOS4_EN = 0, 
        parameter ENCLKOS5_EN = 0, 
        parameter FRAC_N_EN = 0, 
        parameter SS_EN = 0, 
        parameter DYN_PORTS_EN = 0, 
        parameter PLL_RST = 0, 
        parameter LOCK_EN = 0, 
        parameter PLL_LOCK_STICKY = 0, 
        parameter LEGACY_EN = 0, 
        parameter LMMI_EN = 0, 
        parameter APB_EN = 0, 
        parameter POWERDOWN_EN = 0, 
        parameter TRIM_EN_P = 0, 
        parameter TRIM_EN_S = 0, 
        parameter PLL_REFCLK_FROM_PIN = 0, 
        parameter REF_CLK_IO_TYPE = "LVDS", 
        parameter CLKOP_TRIM_MODE = "Falling", 
        parameter CLKOS_TRIM_MODE = "Falling", 
        parameter CLKOP_TRIM = "0b0000", 
        parameter CLKOS_TRIM = "0b0000", 
        parameter FBK_MODE = "CLKOP", 
        parameter CLKI_DIVIDER_ACTUAL_STR = "1", 
        parameter FBCLK_DIVIDER_ACTUAL_STR = "1", 
        parameter DIVOP_ACTUAL_STR = "1", 
        parameter DIVOS_ACTUAL_STR = "1", 
        parameter DIVOS2_ACTUAL_STR = "1", 
        parameter DIVOS3_ACTUAL_STR = "1", 
        parameter DIVOS4_ACTUAL_STR = "1", 
        parameter DIVOS5_ACTUAL_STR = "1", 
        parameter SSC_N_CODE_STR = "0b000010100", 
        parameter SSC_F_CODE_STR = "0b000000000000000", 
        parameter SSC_PROFILE = "DOWN", 
        parameter SSC_TBASE_STR = "0b000000000000", 
        parameter SSC_STEP_IN_STR = "0b0000000", 
        parameter SSC_REG_WEIGHTING_SEL_STR = "0b000", 
        parameter DELA = "0", 
        parameter DELB = "0", 
        parameter DELC = "0", 
        parameter DELD = "0", 
        parameter DELE = "0", 
        parameter DELF = "0", 
        parameter PHIA = "0", 
        parameter PHIB = "0", 
        parameter PHIC = "0", 
        parameter PHID = "0", 
        parameter PHIE = "0", 
        parameter PHIF = "0", 
        parameter EN_REFCLK_MON = 0, 
        parameter REF_COUNTS = "0000", 
        parameter INTFBKDEL_SEL = "DISABLED", 
        parameter PMU_WAITFORLOCK = "ENABLED", 
        parameter REF_OSC_CTRL = "3P2", 
        parameter SIM_FLOAT_PRECISION = "0.1", 
        parameter IPI_CMP = "0b1000", 
        parameter CSET = "40P", 
        parameter CRIPPLE = "5P", 
        parameter IPP_CTRL = "0b1000", 
        parameter IPP_SEL = "0b1111", 
        parameter BW_CTL_BIAS = "0b0101", 
        parameter V2I_PP_RES = "10K", 
        parameter KP_VCO = "0b00011", 
        parameter V2I_KVCO_SEL = "60", 
        parameter V2I_1V_EN = "ENABLED") (
    // -----------------------------------------------------------------------------
    // Module Parameters
    // -----------------------------------------------------------------------------
    // Default 0 means the parameter should be overwritten.
    // If parameter is not overwritten, we'll get compilation errors at once.
    // Used only in TB.
    //PLL Parameters
    // For simulation only
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input rst_i, 
    input [(BUS_WIDTH - 1):0] data_move_i, 
    input clk_move_i, 
    input [(BUS_WIDTH - 1):0] data_direction_i, 
    input clk_direction_i, 
    input [((2 * BUS_WIDTH) - 1):0] data_coarse_dly_i, 
    input [1:0] clk_coarse_dly_i, 
    input [(BUS_WIDTH - 1):0] data_loadn_i, 
    input clk_loadn_i, 
    input sync_clk_i, 
    input sync_rst_i, 
    input sync_update_i, 
    input sync_start_i, 
    input clk_i, 
    input clk90_i, 
    input eclk_i, 
    input eclk90_i, 
    input alignwd_i, 
    input outen_n_i, 
    input [IN_WIDTH:0] data_i, 
    input pll_clki_i, 
    input pll_rstn_i, 
    output [OUT_WIDTH:0] data_o, 
    output sclk_o, 
    output clk_o, 
    output clk_cflag_o, 
    output ready_o, 
    output [(BUS_WIDTH - 1):0] data_cflag_o, 
    output [8:0] dcntl_o, 
    // LMMI bus
    input wire lmmi_clk_i, 
    input wire lmmi_resetn_i, 
    input wire lmmi_request_i, 
    input wire lmmi_wr_rdn_i, 
    input wire [6:0] lmmi_offset_i, 
    input wire [7:0] lmmi_wdata_i, 
    output wire lmmi_ready_o, 
    output wire lmmi_rdata_valid_o, 
    output wire [7:0] lmmi_rdata_o, 
    // APB bus
    input apb_pclk_i, 
    input apb_preset_n_i, 
    input wire apb_penable_i, 
    input wire apb_psel_i, 
    input wire apb_pwrite_i, 
    input wire [6:0] apb_paddr_i, 
    input wire [7:0] apb_pwdata_i, 
    output wire apb_pready_o, 
    output wire apb_pslverr_o, 
    output wire [7:0] apb_prdata_o) ;
    wire [(((2 * GEARING) * BUS_WIDTH) - 1):0] data_o_w ; 
    // -----------------------------------------------------------------------------
    // Generate Variables
    // -----------------------------------------------------------------------------
    genvar i ; 
    genvar j ; 
    generate
        if ((INTERFACE_TYPE == "RECEIVE")) 
            begin : genblk1
                for (i = 0;(i < BUS_WIDTH);i = (i + 1))
                begin : genblk1
                    for (j = 0;(j < (2 * GEARING));j = (j + 1))
                    begin : genblk1
                        assign data_o[((j * BUS_WIDTH) + i)] = data_o_w[(((i * 2) * GEARING) + j)] ; 
                    end
                end
            end
    endgenerate
    // -----------------------------------------------------------------------------
    // Receiver side instances 
    // -----------------------------------------------------------------------------
    generate
        if ((((((INTERFACE_TYPE == "RECEIVE") && (CLOCK_DATA_RELATION == "CENTERED")) && (DATA_PATH_DELAY != "DYNAMIC")) && (CLOCK_PATH_DELAY != "DYNAMIC")) && (GEARING == 1))) 
            begin : RX_SCLK_CENTERED_STATIC_BYPASS
                ddr_rx_ipgen_lscc_gddr_rx_sclk_centered_static_bypass #(.IO_TYPE(IO_TYPE),
                        .BUS_WIDTH(BUS_WIDTH),
                        .DATA_PATH_DELAY(DATA_PATH_DELAY),
                        .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                        .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                        .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddr_rx_sclk_centered_static_bypass (.rst_i(rst_i), 
                            .clk_i(clk_i), 
                            .data_i(data_i), 
                            .data_o(data_o_w), 
                            .sclk_o(sclk_o)) ; 
            end
        else
            if ((((((INTERFACE_TYPE == "RECEIVE") && (CLOCK_DATA_RELATION == "CENTERED")) && (DATA_PATH_DELAY == "DYNAMIC")) && (CLOCK_PATH_DELAY != "DYNAMIC")) && (GEARING == 1))) 
                begin : RX_SCLK_CENTERED_DYNAMIC
                    ddr_rx_ipgen_lscc_gddr_rx_sclk_centered_dynamic #(.IO_TYPE(IO_TYPE),
                            .BUS_WIDTH(BUS_WIDTH),
                            .DATA_PATH_DELAY(DATA_PATH_DELAY),
                            .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                            .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                            .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddr_rx_sclk_centered_dynamic (.rst_i(rst_i), 
                                .clk_i(clk_i), 
                                .data_i(data_i), 
                                .data_o(data_o_w), 
                                .sclk_o(sclk_o), 
                                .data_move_i(data_move_i), 
                                .data_direction_i(data_direction_i), 
                                .data_loadn_i(data_loadn_i), 
                                .data_coarse_dly_i(data_coarse_dly_i), 
                                .data_cflag_o(data_cflag_o)) ; 
                end
            else
                if ((((((INTERFACE_TYPE == "RECEIVE") && (CLOCK_DATA_RELATION == "ALIGNED")) && (DATA_PATH_DELAY != "DYNAMIC")) && (CLOCK_PATH_DELAY != "DYNAMIC")) && (GEARING == 1))) 
                    begin : RX_SCLK_ALIGNED_STATIC_BYPASS
                        ddr_rx_ipgen_lscc_gddr_rx_sclk_aligned_static_bypass #(.IO_TYPE(IO_TYPE),
                                .BUS_WIDTH(BUS_WIDTH),
                                .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddr_rx_sclk_aligned_static_bypass (.sync_rst_i(sync_rst_i), 
                                    .sync_clk_i(sync_clk_i), 
                                    .sync_update_i(sync_update_i), 
                                    .clk_i(clk_i), 
                                    .data_i(data_i), 
                                    .data_o(data_o_w), 
                                    .sclk_o(sclk_o), 
                                    .ready_o(ready_o), 
                                    .dcntl_o(dcntl_o)) ; 
                    end
                else
                    if ((((((INTERFACE_TYPE == "RECEIVE") && (CLOCK_DATA_RELATION == "ALIGNED")) && (CLOCK_PATH_DELAY == "DYNAMIC")) && (DATA_PATH_DELAY != "DYNAMIC")) && (GEARING == 1))) 
                        begin : RX_SCLK_ALIGNED_DYNAMIC_CLOCK
                            ddr_rx_ipgen_lscc_gddr_rx_sclk_aligned_dynamic_clock #(.IO_TYPE(IO_TYPE),
                                    .BUS_WIDTH(BUS_WIDTH),
                                    .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                    .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                    .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                    .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddr_rx_sclk_aligned_dynamic_clock (.sync_rst_i(sync_rst_i), 
                                        .sync_clk_i(sync_clk_i), 
                                        .sync_update_i(sync_update_i), 
                                        .clk_i(clk_i), 
                                        .data_i(data_i), 
                                        .data_o(data_o_w), 
                                        .sclk_o(sclk_o), 
                                        .ready_o(ready_o), 
                                        .clk_move_i(clk_move_i), 
                                        .clk_direction_i(clk_direction_i), 
                                        .clk_loadn_i(clk_loadn_i), 
                                        .clk_cflag_o(clk_cflag_o), 
                                        .dcntl_o(dcntl_o)) ; 
                        end
                    else
                        if ((((((INTERFACE_TYPE == "RECEIVE") && (CLOCK_DATA_RELATION == "ALIGNED")) && (DATA_PATH_DELAY == "DYNAMIC")) && (CLOCK_PATH_DELAY == "DYNAMIC")) && (GEARING == 1))) 
                            begin : RX_SCLK_ALIGNED_DYNAMIC_CLOCK_DATA
                                ddr_rx_ipgen_lscc_gddr_rx_sclk_aligned_dynamic_clock_data #(.IO_TYPE(IO_TYPE),
                                        .BUS_WIDTH(BUS_WIDTH),
                                        .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                        .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                        .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                        .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddr_rx_sclk_aligned_dynamic_clock_data (.sync_rst_i(sync_rst_i), 
                                            .sync_clk_i(sync_clk_i), 
                                            .sync_update_i(sync_update_i), 
                                            .clk_i(clk_i), 
                                            .data_i(data_i), 
                                            .data_o(data_o_w), 
                                            .sclk_o(sclk_o), 
                                            .ready_o(ready_o), 
                                            .clk_move_i(clk_move_i), 
                                            .clk_direction_i(clk_direction_i), 
                                            .clk_loadn_i(clk_loadn_i), 
                                            .clk_cflag_o(clk_cflag_o), 
                                            .data_move_i(data_move_i), 
                                            .data_direction_i(data_direction_i), 
                                            .data_loadn_i(data_loadn_i), 
                                            .data_coarse_dly_i(data_coarse_dly_i), 
                                            .data_cflag_o(data_cflag_o), 
                                            .dcntl_o(dcntl_o)) ; 
                            end
                        else
                            if (((((((INTERFACE_TYPE == "RECEIVE") && (CLOCK_DATA_RELATION == "CENTERED")) && (DATA_PATH_DELAY != "DYNAMIC")) && (CLOCK_PATH_DELAY != "DYNAMIC")) && (INCLUDE_GDDR_SYNC == 0)) && (GEARING > 1))) 
                                begin : RX_ECLK_CENTERED_STATIC_BYPASS
                                    ddr_rx_ipgen_lscc_gddrx2_4_5_rx_eclk_centered_static_bypass #(.IO_TYPE(IO_TYPE),
                                            .GEARING(GEARING),
                                            .BUS_WIDTH(BUS_WIDTH),
                                            .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                            .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                            .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                            .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddrx2_4_5_rx_eclk_centered_static_bypass (.clk_i(clk_i), 
                                                .rst_i(rst_i), 
                                                .data_i(data_i), 
                                                .data_o(data_o_w), 
                                                .sclk_o(sclk_o), 
                                                .alignwd_i(alignwd_i)) ; 
                                end
                            else
                                if (((((((INTERFACE_TYPE == "RECEIVE") && (CLOCK_DATA_RELATION == "CENTERED")) && (DATA_PATH_DELAY != "DYNAMIC")) && (CLOCK_PATH_DELAY != "DYNAMIC")) && (INCLUDE_GDDR_SYNC == 1)) && (GEARING > 1))) 
                                    begin : RX_ECLK_CENTERED_STATIC_BYPASS_GDDR_SYNC
                                        ddr_rx_ipgen_lscc_gddrx2_4_5_rx_eclk_centered_static_bypass_gddr_sync #(.IO_TYPE(IO_TYPE),
                                                .GEARING(GEARING),
                                                .BUS_WIDTH(BUS_WIDTH),
                                                .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddrx2_4_5_rx_eclk_centered_static_bypass_gddr_sync (.sync_clk_i(sync_clk_i), 
                                                    .sync_rst_i(sync_rst_i), 
                                                    .sync_start_i(sync_start_i), 
                                                    .ready_o(ready_o), 
                                                    .data_i(data_i), 
                                                    .clk_i(clk_i), 
                                                    .data_o(data_o_w), 
                                                    .sclk_o(sclk_o), 
                                                    .alignwd_i(alignwd_i)) ; 
                                    end
                                else
                                    if (((((((INTERFACE_TYPE == "RECEIVE") && (CLOCK_DATA_RELATION == "CENTERED")) && (DATA_PATH_DELAY == "DYNAMIC")) && (INCLUDE_GDDR_SYNC == 0)) && (CLOCK_PATH_DELAY != "DYNAMIC")) && (GEARING > 1))) 
                                        begin : RX_ECLK_CENTERED_DYNAMIC
                                            ddr_rx_ipgen_lscc_gddrx2_4_5_rx_eclk_centered_dynamic #(.IO_TYPE(IO_TYPE),
                                                    .GEARING(GEARING),
                                                    .BUS_WIDTH(BUS_WIDTH),
                                                    .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                    .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                    .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                    .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddrx2_4_5_rx_eclk_centered_dynamic (.clk_i(clk_i), 
                                                        .rst_i(rst_i), 
                                                        .data_i(data_i), 
                                                        .data_o(data_o_w), 
                                                        .sclk_o(sclk_o), 
                                                        .alignwd_i(alignwd_i), 
                                                        .data_move_i(data_move_i), 
                                                        .data_direction_i(data_direction_i), 
                                                        .data_loadn_i(data_loadn_i), 
                                                        .data_coarse_dly_i(data_coarse_dly_i), 
                                                        .data_cflag_o(data_cflag_o)) ; 
                                        end
                                    else
                                        if ((((((INTERFACE_TYPE == "RECEIVE") && (CLOCK_DATA_RELATION == "ALIGNED")) && (DATA_PATH_DELAY != "DYNAMIC")) && (CLOCK_PATH_DELAY != "DYNAMIC")) && (GEARING > 1))) 
                                            begin : RX_ECLK_ALIGNED_STATIC_BYPASS
                                                ddr_rx_ipgen_lscc_gddrx2_4_5_rx_eclk_aligned_static_bypass #(.IO_TYPE(IO_TYPE),
                                                        .GEARING(GEARING),
                                                        .BUS_WIDTH(BUS_WIDTH),
                                                        .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                        .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                        .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                        .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddrx2_4_5_rx_eclk_aligned_static_bypass (.clk_i(clk_i), 
                                                            .data_i(data_i), 
                                                            .data_o(data_o_w), 
                                                            .sclk_o(sclk_o), 
                                                            .alignwd_i(alignwd_i), 
                                                            .sync_rst_i(sync_rst_i), 
                                                            .sync_clk_i(sync_clk_i), 
                                                            .ready_o(ready_o), 
                                                            .dcntl_o(dcntl_o), 
                                                            .sync_update_i(sync_update_i)) ; 
                                            end
                                        else
                                            if ((((((INTERFACE_TYPE == "RECEIVE") && (CLOCK_DATA_RELATION == "ALIGNED")) && (DATA_PATH_DELAY == "DYNAMIC")) && (CLOCK_PATH_DELAY == "DYNAMIC")) && (GEARING > 1))) 
                                                begin : RX_ECLK_ALIGNED_DYNAMIC
                                                    ddr_rx_ipgen_lscc_gddrx2_4_5_rx_eclk_aligned_dynamic #(.IO_TYPE(IO_TYPE),
                                                            .GEARING(GEARING),
                                                            .BUS_WIDTH(BUS_WIDTH),
                                                            .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                            .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                            .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                            .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddrx2_4_5_rx_eclk_aligned_dynamic (.sync_rst_i(sync_rst_i), 
                                                                .sync_clk_i(sync_clk_i), 
                                                                .sync_update_i(sync_update_i), 
                                                                .ready_o(ready_o), 
                                                                .clk_i(clk_i), 
                                                                .data_i(data_i), 
                                                                .data_o(data_o_w), 
                                                                .sclk_o(sclk_o), 
                                                                .alignwd_i(alignwd_i), 
                                                                .clk_move_i(clk_move_i), 
                                                                .clk_direction_i(clk_direction_i), 
                                                                .clk_loadn_i(clk_loadn_i), 
                                                                .clk_cflag_o(clk_cflag_o), 
                                                                .data_move_i(data_move_i), 
                                                                .data_direction_i(data_direction_i), 
                                                                .data_loadn_i(data_loadn_i), 
                                                                .data_coarse_dly_i(data_coarse_dly_i), 
                                                                .data_cflag_o(data_cflag_o), 
                                                                .dcntl_o(dcntl_o)) ; 
                                                end
                                            else
                                                // -----------------------------------------------------------------------------
                                                // Transmitter side instances 
                                                // -----------------------------------------------------------------------------
                                                if ((((((INTERFACE_TYPE == "TRANSMIT") && (CLOCK_DATA_RELATION == "CENTERED")) && (DATA_PATH_DELAY != "DYNAMIC")) && (CLOCK_PATH_DELAY != "DYNAMIC")) && (GEARING == 1))) 
                                                    begin : TX_SCLK_CENTERED_STATIC_BYPASS
                                                        ddr_rx_ipgen_lscc_gddr_tx_sclk_centered_static_bypass #(.IO_TYPE(IO_TYPE),
                                                                .BUS_WIDTH(BUS_WIDTH),
                                                                .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                                .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                                .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                                .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddr_tx_sclk_centered_static_bypass (.rst_i(rst_i), 
                                                                    .clk_i(clk_i), 
                                                                    .data_i(data_i), 
                                                                    .data_o(data_o), 
                                                                    .clk_o(clk_o), 
                                                                    .clk90_i(clk90_i)) ; 
                                                    end
                                                else
                                                    if (((((INTERFACE_TYPE == "TRANSMIT") && (CLOCK_DATA_RELATION == "CENTERED")) && (DATA_PATH_DELAY == "DYNAMIC")) && (GEARING == 1))) 
                                                        begin : TX_SCLK_CENTERED_DYNAMIC
                                                            ddr_rx_ipgen_lscc_gddr_tx_sclk_centered_dynamic #(.IO_TYPE(IO_TYPE),
                                                                    .BUS_WIDTH(BUS_WIDTH),
                                                                    .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                                    .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                                    .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                                    .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddr_tx_sclk_centered_dynamic (.rst_i(rst_i), 
                                                                        .clk_i(clk_i), 
                                                                        .data_i(data_i), 
                                                                        .data_o(data_o), 
                                                                        .clk_o(clk_o), 
                                                                        .clk90_i(clk90_i), 
                                                                        .data_move_i(data_move_i), 
                                                                        .data_direction_i(data_direction_i), 
                                                                        .data_loadn_i(data_loadn_i), 
                                                                        .data_coarse_dly_i(data_coarse_dly_i), 
                                                                        .data_cflag_o(data_cflag_o)) ; 
                                                        end
                                                    else
                                                        if ((((((INTERFACE_TYPE == "TRANSMIT") && (CLOCK_DATA_RELATION == "ALIGNED")) && (DATA_PATH_DELAY != "DYNAMIC")) && (CLOCK_PATH_DELAY != "DYNAMIC")) && (GEARING == 1))) 
                                                            begin : TX_SCLK_ALIGNED_STATIC_BYPASS
                                                                ddr_rx_ipgen_lscc_gddr_tx_sclk_aligned_static_bypass #(.IO_TYPE(IO_TYPE),
                                                                        .BUS_WIDTH(BUS_WIDTH),
                                                                        .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                                        .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                                        .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                                        .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddr_tx_sclk_aligned_static_bypass (.rst_i(rst_i), 
                                                                            .clk_i(clk_i), 
                                                                            .data_i(data_i), 
                                                                            .data_o(data_o), 
                                                                            .clk_o(clk_o)) ; 
                                                            end
                                                        else
                                                            if ((((((INTERFACE_TYPE == "TRANSMIT") && (CLOCK_DATA_RELATION == "ALIGNED")) && (DATA_PATH_DELAY == "DYNAMIC")) && (CLOCK_PATH_DELAY != "DYNAMIC")) && (GEARING == 1))) 
                                                                begin : TX_SCLK_ALIGNED_DYNAMIC
                                                                    ddr_rx_ipgen_lscc_gddr_tx_sclk_aligned_dynamic #(.IO_TYPE(IO_TYPE),
                                                                            .BUS_WIDTH(BUS_WIDTH),
                                                                            .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                                            .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                                            .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                                            .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddr_tx_sclk_aligned_dynamic (.rst_i(rst_i), 
                                                                                .clk_i(clk_i), 
                                                                                .data_i(data_i), 
                                                                                .data_o(data_o), 
                                                                                .clk_o(clk_o), 
                                                                                .data_move_i(data_move_i), 
                                                                                .data_direction_i(data_direction_i), 
                                                                                .data_loadn_i(data_loadn_i), 
                                                                                .data_coarse_dly_i(data_coarse_dly_i), 
                                                                                .data_cflag_o(data_cflag_o)) ; 
                                                                end
                                                            else
                                                                if (((((((((INTERFACE_TYPE == "TRANSMIT") && (CLOCK_DATA_RELATION == "CENTERED")) && (DATA_PATH_DELAY != "DYNAMIC")) && (CLOCK_PATH_DELAY != "DYNAMIC")) && (INCLUDE_GDDR_SYNC == 1)) && (TRISTATE_EN == 0)) && (PLL_ENABLE == 0)) && (GEARING > 1))) 
                                                                    begin : TX_ECLK_CENTERED_STATIC_BYPASS
                                                                        ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_centered_static_bypass #(.IO_TYPE(IO_TYPE),
                                                                                .GEARING(GEARING),
                                                                                .BUS_WIDTH(BUS_WIDTH),
                                                                                .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                                                .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                                                .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                                                .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddrx2_4_5_tx_eclk_centered_static_bypass (.eclk_i(eclk_i), 
                                                                                .eclk90_i(eclk90_i), 
                                                                                .data_i(data_i), 
                                                                                .data_o(data_o), 
                                                                                .sclk_o(sclk_o), 
                                                                                .clk_o(clk_o), 
                                                                                .sync_rst_i(sync_rst_i), 
                                                                                .sync_clk_i(sync_clk_i), 
                                                                                .sync_start_i(sync_start_i), 
                                                                                .ready_o(ready_o)) ; 
                                                                    end
                                                                else
                                                                    if (((((((((INTERFACE_TYPE == "TRANSMIT") && (CLOCK_DATA_RELATION == "CENTERED")) && (TRISTATE_EN == 0)) && (INCLUDE_GDDR_SYNC == 1)) && (DATA_PATH_DELAY != "DYNAMIC")) && (CLOCK_PATH_DELAY != "DYNAMIC")) && (PLL_ENABLE == 1)) && (GEARING > 1))) 
                                                                        begin : TX_ECLK_CENTERED_STATIC_BYPASS_PLL
                                                                            ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_centered_static_bypass_pll #(.IO_TYPE(IO_TYPE),
                                                                                .GEARING(GEARING),
                                                                                .BUS_WIDTH(BUS_WIDTH),
                                                                                .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                                                .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                                                .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                                                .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE),
                                                                                .FVCO(FVCO),
                                                                                .CLKI_FREQ(CLKI_FREQ),
                                                                                .CLKOP_FREQ_ACTUAL(CLKOP_FREQ_ACTUAL),
                                                                                .CLKOS_FREQ_ACTUAL(CLKOS_FREQ_ACTUAL),
                                                                                .CLKOS2_FREQ_ACTUAL(CLKOS2_FREQ_ACTUAL),
                                                                                .CLKOS3_FREQ_ACTUAL(CLKOS3_FREQ_ACTUAL),
                                                                                .CLKOS4_FREQ_ACTUAL(CLKOS4_FREQ_ACTUAL),
                                                                                .CLKOS5_FREQ_ACTUAL(CLKOS5_FREQ_ACTUAL),
                                                                                .CLKOP_PHASE_ACTUAL(CLKOP_PHASE_ACTUAL),
                                                                                .CLKOS_PHASE_ACTUAL(CLKOS_PHASE_ACTUAL),
                                                                                .CLKOS2_PHASE_ACTUAL(CLKOS2_PHASE_ACTUAL),
                                                                                .CLKOS3_PHASE_ACTUAL(CLKOS3_PHASE_ACTUAL),
                                                                                .CLKOS4_PHASE_ACTUAL(CLKOS4_PHASE_ACTUAL),
                                                                                .CLKOS5_PHASE_ACTUAL(CLKOS5_PHASE_ACTUAL),
                                                                                .CLKOS_EN(CLKOS_EN),
                                                                                .CLKOS2_EN(CLKOS2_EN),
                                                                                .CLKOS3_EN(CLKOS3_EN),
                                                                                .CLKOS4_EN(CLKOS4_EN),
                                                                                .CLKOS5_EN(CLKOS5_EN),
                                                                                .CLKOP_BYPASS(CLKOP_BYPASS),
                                                                                .CLKOS_BYPASS(CLKOS_BYPASS),
                                                                                .CLKOS2_BYPASS(CLKOS2_BYPASS),
                                                                                .CLKOS3_BYPASS(CLKOS3_BYPASS),
                                                                                .CLKOS4_BYPASS(CLKOS4_BYPASS),
                                                                                .CLKOS5_BYPASS(CLKOS5_BYPASS),
                                                                                .ENCLKOP_EN(ENCLKOP_EN),
                                                                                .ENCLKOS_EN(ENCLKOS_EN),
                                                                                .ENCLKOS2_EN(ENCLKOS2_EN),
                                                                                .ENCLKOS3_EN(ENCLKOS3_EN),
                                                                                .ENCLKOS4_EN(ENCLKOS4_EN),
                                                                                .ENCLKOS5_EN(ENCLKOS5_EN),
                                                                                .FRAC_N_EN(FRAC_N_EN),
                                                                                .SS_EN(SS_EN),
                                                                                .DYN_PORTS_EN(DYN_PORTS_EN),
                                                                                .PLL_RST(PLL_RST),
                                                                                .LOCK_EN(LOCK_EN),
                                                                                .PLL_LOCK_STICKY(PLL_LOCK_STICKY),
                                                                                .LEGACY_EN(LEGACY_EN),
                                                                                .LMMI_EN(LMMI_EN),
                                                                                .APB_EN(APB_EN),
                                                                                .POWERDOWN_EN(POWERDOWN_EN),
                                                                                .TRIM_EN_P(TRIM_EN_P),
                                                                                .TRIM_EN_S(TRIM_EN_S),
                                                                                .PLL_REFCLK_FROM_PIN(PLL_REFCLK_FROM_PIN),
                                                                                .REF_CLK_IO_TYPE(REF_CLK_IO_TYPE),
                                                                                .CLKOP_TRIM_MODE(CLKOP_TRIM_MODE),
                                                                                .CLKOS_TRIM_MODE(CLKOS_TRIM_MODE),
                                                                                .CLKOP_TRIM(CLKOP_TRIM),
                                                                                .CLKOS_TRIM(CLKOS_TRIM),
                                                                                .FBK_MODE(FBK_MODE),
                                                                                .CLKI_DIVIDER_ACTUAL_STR(CLKI_DIVIDER_ACTUAL_STR),
                                                                                .FBCLK_DIVIDER_ACTUAL_STR(FBCLK_DIVIDER_ACTUAL_STR),
                                                                                .DIVOP_ACTUAL_STR(DIVOP_ACTUAL_STR),
                                                                                .DIVOS_ACTUAL_STR(DIVOS_ACTUAL_STR),
                                                                                .DIVOS2_ACTUAL_STR(DIVOS2_ACTUAL_STR),
                                                                                .DIVOS3_ACTUAL_STR(DIVOS3_ACTUAL_STR),
                                                                                .DIVOS4_ACTUAL_STR(DIVOS4_ACTUAL_STR),
                                                                                .DIVOS5_ACTUAL_STR(DIVOS5_ACTUAL_STR),
                                                                                .SSC_N_CODE_STR(SSC_N_CODE_STR),
                                                                                .SSC_F_CODE_STR(SSC_F_CODE_STR),
                                                                                .SSC_PROFILE(SSC_PROFILE),
                                                                                .SSC_TBASE_STR(SSC_TBASE_STR),
                                                                                .SSC_STEP_IN_STR(SSC_STEP_IN_STR),
                                                                                .SSC_REG_WEIGHTING_SEL_STR(SSC_REG_WEIGHTING_SEL_STR),
                                                                                .DELA(DELA),
                                                                                .DELB(DELB),
                                                                                .DELC(DELC),
                                                                                .DELD(DELD),
                                                                                .DELE(DELE),
                                                                                .DELF(DELF),
                                                                                .PHIA(PHIA),
                                                                                .PHIB(PHIB),
                                                                                .PHIC(PHIC),
                                                                                .PHID(PHID),
                                                                                .PHIE(PHIE),
                                                                                .PHIF(PHIF),
                                                                                .IPI_CMP(IPI_CMP),
                                                                                .CSET(CSET),
                                                                                .CRIPPLE(CRIPPLE),
                                                                                .IPP_CTRL(IPP_CTRL),
                                                                                .IPP_SEL(IPP_SEL),
                                                                                .BW_CTL_BIAS(BW_CTL_BIAS),
                                                                                .V2I_PP_RES(V2I_PP_RES),
                                                                                .KP_VCO(KP_VCO),
                                                                                .V2I_KVCO_SEL(V2I_KVCO_SEL),
                                                                                .V2I_1V_EN(V2I_1V_EN),
                                                                                .REF_COUNTS(REF_COUNTS),
                                                                                .INTFBKDEL_SEL(INTFBKDEL_SEL),
                                                                                .PMU_WAITFORLOCK(PMU_WAITFORLOCK),
                                                                                .EN_REFCLK_MON(EN_REFCLK_MON),
                                                                                .REF_OSC_CTRL(REF_OSC_CTRL),
                                                                                .SIM_FLOAT_PRECISION(SIM_FLOAT_PRECISION)) u_lscc_gddrx2_4_5_tx_eclk_centered_static_bypass_pll (.sync_clk_i(sync_clk_i), 
                                                                                .sync_rst_i(sync_rst_i), 
                                                                                .ready_o(ready_o), 
                                                                                .data_i(data_i), 
                                                                                .data_o(data_o), 
                                                                                .clk_o(clk_o), 
                                                                                .sclk_o(sclk_o), 
                                                                                .pll_clki_i(pll_clki_i), 
                                                                                .pll_rstn_i(pll_rstn_i), 
                                                                                .lmmi_clk_i(lmmi_clk_i), 
                                                                                .lmmi_resetn_i(lmmi_resetn_i), 
                                                                                .lmmi_request_i(lmmi_request_i), 
                                                                                .lmmi_wr_rdn_i(lmmi_wr_rdn_i), 
                                                                                .lmmi_offset_i(lmmi_offset_i), 
                                                                                .lmmi_wdata_i(lmmi_wdata_i), 
                                                                                .lmmi_ready_o(lmmi_ready_o), 
                                                                                .lmmi_rdata_valid_o(lmmi_rdata_valid_o), 
                                                                                .lmmi_rdata_o(lmmi_rdata_o), 
                                                                                .apb_pclk_i(apb_pclk_i), 
                                                                                .apb_preset_n_i(apb_preset_n_i), 
                                                                                .apb_penable_i(apb_penable_i), 
                                                                                .apb_psel_i(apb_psel_i), 
                                                                                .apb_pwrite_i(apb_pwrite_i), 
                                                                                .apb_paddr_i(apb_paddr_i), 
                                                                                .apb_pwdata_i(apb_pwdata_i), 
                                                                                .apb_pready_o(apb_pready_o), 
                                                                                .apb_pslverr_o(apb_pslverr_o), 
                                                                                .apb_prdata_o(apb_prdata_o)) ; 
                                                                        end
                                                                    else
                                                                        if (((((((((INTERFACE_TYPE == "TRANSMIT") && (CLOCK_DATA_RELATION == "CENTERED")) && (DATA_PATH_DELAY == "DYNAMIC")) && (CLOCK_PATH_DELAY == "DYNAMIC")) && (TRISTATE_EN == 0)) && (PLL_ENABLE == 0)) && (INCLUDE_GDDR_SYNC == 1)) && (GEARING > 1))) 
                                                                            begin : TX_ECLK_CENTERED_DYNAMIC
                                                                                ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_centered_dynamic #(.IO_TYPE(IO_TYPE),
                                                                                .GEARING(GEARING),
                                                                                .BUS_WIDTH(BUS_WIDTH),
                                                                                .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                                                .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                                                .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                                                .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddrx2_4_5_tx_eclk_centered_dynamic (.eclk_i(eclk_i), 
                                                                                .eclk90_i(eclk90_i), 
                                                                                .data_i(data_i), 
                                                                                .data_o(data_o), 
                                                                                .sclk_o(sclk_o), 
                                                                                .clk_o(clk_o), 
                                                                                .sync_rst_i(sync_rst_i), 
                                                                                .sync_clk_i(sync_clk_i), 
                                                                                .sync_start_i(sync_start_i), 
                                                                                .ready_o(ready_o), 
                                                                                .data_move_i(data_move_i), 
                                                                                .data_direction_i(data_direction_i), 
                                                                                .data_loadn_i(data_loadn_i), 
                                                                                .data_coarse_dly_i(data_coarse_dly_i), 
                                                                                .data_cflag_o(data_cflag_o), 
                                                                                .clk_move_i(clk_move_i), 
                                                                                .clk_direction_i(clk_direction_i), 
                                                                                .clk_loadn_i(clk_loadn_i), 
                                                                                .clk_coarse_dly_i(clk_coarse_dly_i), 
                                                                                .clk_cflag_o(clk_cflag_o)) ; 
                                                                            end
                                                                        else
                                                                            if (((((((((INTERFACE_TYPE == "TRANSMIT") && (CLOCK_DATA_RELATION == "CENTERED")) && (DATA_PATH_DELAY == "DYNAMIC")) && (CLOCK_PATH_DELAY == "DYNAMIC")) && (INCLUDE_GDDR_SYNC == 1)) && (TRISTATE_EN == 0)) && (PLL_ENABLE == 1)) && (GEARING > 1))) 
                                                                                begin : TX_ECLK_CENTERED_DYNAMIC_PLL
                                                                                ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_centered_dynamic_pll #(.IO_TYPE(IO_TYPE),
                                                                                .GEARING(GEARING),
                                                                                .BUS_WIDTH(BUS_WIDTH),
                                                                                .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                                                .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                                                .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                                                .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE),
                                                                                .FVCO(FVCO),
                                                                                .CLKI_FREQ(CLKI_FREQ),
                                                                                .CLKOP_FREQ_ACTUAL(CLKOP_FREQ_ACTUAL),
                                                                                .CLKOS_FREQ_ACTUAL(CLKOS_FREQ_ACTUAL),
                                                                                .CLKOS2_FREQ_ACTUAL(CLKOS2_FREQ_ACTUAL),
                                                                                .CLKOS3_FREQ_ACTUAL(CLKOS3_FREQ_ACTUAL),
                                                                                .CLKOS4_FREQ_ACTUAL(CLKOS4_FREQ_ACTUAL),
                                                                                .CLKOS5_FREQ_ACTUAL(CLKOS5_FREQ_ACTUAL),
                                                                                .CLKOP_PHASE_ACTUAL(CLKOP_PHASE_ACTUAL),
                                                                                .CLKOS_PHASE_ACTUAL(CLKOS_PHASE_ACTUAL),
                                                                                .CLKOS2_PHASE_ACTUAL(CLKOS2_PHASE_ACTUAL),
                                                                                .CLKOS3_PHASE_ACTUAL(CLKOS3_PHASE_ACTUAL),
                                                                                .CLKOS4_PHASE_ACTUAL(CLKOS4_PHASE_ACTUAL),
                                                                                .CLKOS5_PHASE_ACTUAL(CLKOS5_PHASE_ACTUAL),
                                                                                .CLKOS_EN(CLKOS_EN),
                                                                                .CLKOS2_EN(CLKOS2_EN),
                                                                                .CLKOS3_EN(CLKOS3_EN),
                                                                                .CLKOS4_EN(CLKOS4_EN),
                                                                                .CLKOS5_EN(CLKOS5_EN),
                                                                                .CLKOP_BYPASS(CLKOP_BYPASS),
                                                                                .CLKOS_BYPASS(CLKOS_BYPASS),
                                                                                .CLKOS2_BYPASS(CLKOS2_BYPASS),
                                                                                .CLKOS3_BYPASS(CLKOS3_BYPASS),
                                                                                .CLKOS4_BYPASS(CLKOS4_BYPASS),
                                                                                .CLKOS5_BYPASS(CLKOS5_BYPASS),
                                                                                .ENCLKOP_EN(ENCLKOP_EN),
                                                                                .ENCLKOS_EN(ENCLKOS_EN),
                                                                                .ENCLKOS2_EN(ENCLKOS2_EN),
                                                                                .ENCLKOS3_EN(ENCLKOS3_EN),
                                                                                .ENCLKOS4_EN(ENCLKOS4_EN),
                                                                                .ENCLKOS5_EN(ENCLKOS5_EN),
                                                                                .FRAC_N_EN(FRAC_N_EN),
                                                                                .SS_EN(SS_EN),
                                                                                .DYN_PORTS_EN(DYN_PORTS_EN),
                                                                                .PLL_RST(PLL_RST),
                                                                                .LOCK_EN(LOCK_EN),
                                                                                .PLL_LOCK_STICKY(PLL_LOCK_STICKY),
                                                                                .LEGACY_EN(LEGACY_EN),
                                                                                .LMMI_EN(LMMI_EN),
                                                                                .APB_EN(APB_EN),
                                                                                .POWERDOWN_EN(POWERDOWN_EN),
                                                                                .TRIM_EN_P(TRIM_EN_P),
                                                                                .TRIM_EN_S(TRIM_EN_S),
                                                                                .PLL_REFCLK_FROM_PIN(PLL_REFCLK_FROM_PIN),
                                                                                .REF_CLK_IO_TYPE(REF_CLK_IO_TYPE),
                                                                                .CLKOP_TRIM_MODE(CLKOP_TRIM_MODE),
                                                                                .CLKOS_TRIM_MODE(CLKOS_TRIM_MODE),
                                                                                .CLKOP_TRIM(CLKOP_TRIM),
                                                                                .CLKOS_TRIM(CLKOS_TRIM),
                                                                                .FBK_MODE(FBK_MODE),
                                                                                .CLKI_DIVIDER_ACTUAL_STR(CLKI_DIVIDER_ACTUAL_STR),
                                                                                .FBCLK_DIVIDER_ACTUAL_STR(FBCLK_DIVIDER_ACTUAL_STR),
                                                                                .DIVOP_ACTUAL_STR(DIVOP_ACTUAL_STR),
                                                                                .DIVOS_ACTUAL_STR(DIVOS_ACTUAL_STR),
                                                                                .DIVOS2_ACTUAL_STR(DIVOS2_ACTUAL_STR),
                                                                                .DIVOS3_ACTUAL_STR(DIVOS3_ACTUAL_STR),
                                                                                .DIVOS4_ACTUAL_STR(DIVOS4_ACTUAL_STR),
                                                                                .DIVOS5_ACTUAL_STR(DIVOS5_ACTUAL_STR),
                                                                                .SSC_N_CODE_STR(SSC_N_CODE_STR),
                                                                                .SSC_F_CODE_STR(SSC_F_CODE_STR),
                                                                                .SSC_PROFILE(SSC_PROFILE),
                                                                                .SSC_TBASE_STR(SSC_TBASE_STR),
                                                                                .SSC_STEP_IN_STR(SSC_STEP_IN_STR),
                                                                                .SSC_REG_WEIGHTING_SEL_STR(SSC_REG_WEIGHTING_SEL_STR),
                                                                                .DELA(DELA),
                                                                                .DELB(DELB),
                                                                                .DELC(DELC),
                                                                                .DELD(DELD),
                                                                                .DELE(DELE),
                                                                                .DELF(DELF),
                                                                                .PHIA(PHIA),
                                                                                .PHIB(PHIB),
                                                                                .PHIC(PHIC),
                                                                                .PHID(PHID),
                                                                                .PHIE(PHIE),
                                                                                .PHIF(PHIF),
                                                                                .IPI_CMP(IPI_CMP),
                                                                                .CSET(CSET),
                                                                                .CRIPPLE(CRIPPLE),
                                                                                .IPP_CTRL(IPP_CTRL),
                                                                                .IPP_SEL(IPP_SEL),
                                                                                .BW_CTL_BIAS(BW_CTL_BIAS),
                                                                                .V2I_PP_RES(V2I_PP_RES),
                                                                                .KP_VCO(KP_VCO),
                                                                                .V2I_KVCO_SEL(V2I_KVCO_SEL),
                                                                                .V2I_1V_EN(V2I_1V_EN),
                                                                                .REF_COUNTS(REF_COUNTS),
                                                                                .INTFBKDEL_SEL(INTFBKDEL_SEL),
                                                                                .PMU_WAITFORLOCK(PMU_WAITFORLOCK),
                                                                                .EN_REFCLK_MON(EN_REFCLK_MON),
                                                                                .REF_OSC_CTRL(REF_OSC_CTRL),
                                                                                .SIM_FLOAT_PRECISION(SIM_FLOAT_PRECISION)) lscc_gddrx2_4_5_tx_eclk_centered_dynamic_pll (.data_coarse_dly_i(data_coarse_dly_i), 
                                                                                .clk_coarse_dly_i(clk_coarse_dly_i), 
                                                                                .data_move_i(data_move_i), 
                                                                                .clk_move_i(clk_move_i), 
                                                                                .data_loadn_i(data_loadn_i), 
                                                                                .clk_loadn_i(clk_loadn_i), 
                                                                                .data_direction_i(data_direction_i), 
                                                                                .clk_direction_i(clk_direction_i), 
                                                                                .data_cflag_o(data_cflag_o), 
                                                                                .clk_cflag_o(clk_cflag_o), 
                                                                                .data_i(data_i), 
                                                                                .sync_clk_i(sync_clk_i), 
                                                                                .sync_rst_i(sync_rst_i), 
                                                                                .ready_o(ready_o), 
                                                                                .data_o(data_o), 
                                                                                .clk_o(clk_o), 
                                                                                .sclk_o(sclk_o), 
                                                                                .pll_clki_i(pll_clki_i), 
                                                                                .pll_rstn_i(pll_rstn_i), 
                                                                                .lmmi_clk_i(lmmi_clk_i), 
                                                                                .lmmi_resetn_i(lmmi_resetn_i), 
                                                                                .lmmi_request_i(lmmi_request_i), 
                                                                                .lmmi_wr_rdn_i(lmmi_wr_rdn_i), 
                                                                                .lmmi_offset_i(lmmi_offset_i), 
                                                                                .lmmi_wdata_i(lmmi_wdata_i), 
                                                                                .lmmi_ready_o(lmmi_ready_o), 
                                                                                .lmmi_rdata_valid_o(lmmi_rdata_valid_o), 
                                                                                .lmmi_rdata_o(lmmi_rdata_o), 
                                                                                .apb_pclk_i(apb_pclk_i), 
                                                                                .apb_preset_n_i(apb_preset_n_i), 
                                                                                .apb_penable_i(apb_penable_i), 
                                                                                .apb_psel_i(apb_psel_i), 
                                                                                .apb_pwrite_i(apb_pwrite_i), 
                                                                                .apb_paddr_i(apb_paddr_i), 
                                                                                .apb_pwdata_i(apb_pwdata_i), 
                                                                                .apb_pready_o(apb_pready_o), 
                                                                                .apb_pslverr_o(apb_pslverr_o), 
                                                                                .apb_prdata_o(apb_prdata_o)) ; 
                                                                                end
                                                                            else
                                                                                if (((((((((INTERFACE_TYPE == "TRANSMIT") && (CLOCK_DATA_RELATION == "CENTERED")) && (DATA_PATH_DELAY == "DYNAMIC")) && (CLOCK_PATH_DELAY == "DYNAMIC")) && (TRISTATE_EN == 1)) && (PLL_ENABLE == 0)) && (INCLUDE_GDDR_SYNC == 1)) && (GEARING > 1))) 
                                                                                begin : TX_ECLK_CENTERED_DYNAMIC_TRI_STATE_CONTROL
                                                                                ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_centered_dynamic_tri_state_control #(.IO_TYPE(IO_TYPE),
                                                                                .GEARING(GEARING),
                                                                                .BUS_WIDTH(BUS_WIDTH),
                                                                                .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                                                .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                                                .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                                                .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddrx2_4_5_tx_eclk_centered_dynamic_tri_state_control (.eclk_i(eclk_i), 
                                                                                .eclk90_i(eclk90_i), 
                                                                                .data_i(data_i), 
                                                                                .data_o(data_o), 
                                                                                .sclk_o(sclk_o), 
                                                                                .clk_o(clk_o), 
                                                                                .sync_rst_i(sync_rst_i), 
                                                                                .sync_clk_i(sync_clk_i), 
                                                                                .sync_start_i(sync_start_i), 
                                                                                .ready_o(ready_o), 
                                                                                .data_move_i(data_move_i), 
                                                                                .data_direction_i(data_direction_i), 
                                                                                .data_loadn_i(data_loadn_i), 
                                                                                .data_coarse_dly_i(data_coarse_dly_i), 
                                                                                .data_cflag_o(data_cflag_o), 
                                                                                .clk_move_i(clk_move_i), 
                                                                                .clk_direction_i(clk_direction_i), 
                                                                                .clk_loadn_i(clk_loadn_i), 
                                                                                .clk_coarse_dly_i(clk_coarse_dly_i), 
                                                                                .outen_n_i(outen_n_i), 
                                                                                .clk_cflag_o(clk_cflag_o)) ; 
                                                                                end
                                                                                else
                                                                                if (((((((((INTERFACE_TYPE == "TRANSMIT") && (CLOCK_DATA_RELATION == "CENTERED")) && (DATA_PATH_DELAY == "DYNAMIC")) && (CLOCK_PATH_DELAY == "DYNAMIC")) && (INCLUDE_GDDR_SYNC == 1)) && (TRISTATE_EN == 1)) && (PLL_ENABLE == 1)) && (GEARING > 1))) 
                                                                                begin : TX_ECLK_CENTERED_DYNAMIC_TRI_STATE_CONTROL_PLL
                                                                                ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_centered_dynamic_tri_state_control_pll #(.IO_TYPE(IO_TYPE),
                                                                                .GEARING(GEARING),
                                                                                .BUS_WIDTH(BUS_WIDTH),
                                                                                .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                                                .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                                                .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                                                .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE),
                                                                                .FVCO(FVCO),
                                                                                .CLKI_FREQ(CLKI_FREQ),
                                                                                .CLKOP_FREQ_ACTUAL(CLKOP_FREQ_ACTUAL),
                                                                                .CLKOS_FREQ_ACTUAL(CLKOS_FREQ_ACTUAL),
                                                                                .CLKOS2_FREQ_ACTUAL(CLKOS2_FREQ_ACTUAL),
                                                                                .CLKOS3_FREQ_ACTUAL(CLKOS3_FREQ_ACTUAL),
                                                                                .CLKOS4_FREQ_ACTUAL(CLKOS4_FREQ_ACTUAL),
                                                                                .CLKOS5_FREQ_ACTUAL(CLKOS5_FREQ_ACTUAL),
                                                                                .CLKOP_PHASE_ACTUAL(CLKOP_PHASE_ACTUAL),
                                                                                .CLKOS_PHASE_ACTUAL(CLKOS_PHASE_ACTUAL),
                                                                                .CLKOS2_PHASE_ACTUAL(CLKOS2_PHASE_ACTUAL),
                                                                                .CLKOS3_PHASE_ACTUAL(CLKOS3_PHASE_ACTUAL),
                                                                                .CLKOS4_PHASE_ACTUAL(CLKOS4_PHASE_ACTUAL),
                                                                                .CLKOS5_PHASE_ACTUAL(CLKOS5_PHASE_ACTUAL),
                                                                                .CLKOS_EN(CLKOS_EN),
                                                                                .CLKOS2_EN(CLKOS2_EN),
                                                                                .CLKOS3_EN(CLKOS3_EN),
                                                                                .CLKOS4_EN(CLKOS4_EN),
                                                                                .CLKOS5_EN(CLKOS5_EN),
                                                                                .CLKOP_BYPASS(CLKOP_BYPASS),
                                                                                .CLKOS_BYPASS(CLKOS_BYPASS),
                                                                                .CLKOS2_BYPASS(CLKOS2_BYPASS),
                                                                                .CLKOS3_BYPASS(CLKOS3_BYPASS),
                                                                                .CLKOS4_BYPASS(CLKOS4_BYPASS),
                                                                                .CLKOS5_BYPASS(CLKOS5_BYPASS),
                                                                                .ENCLKOP_EN(ENCLKOP_EN),
                                                                                .ENCLKOS_EN(ENCLKOS_EN),
                                                                                .ENCLKOS2_EN(ENCLKOS2_EN),
                                                                                .ENCLKOS3_EN(ENCLKOS3_EN),
                                                                                .ENCLKOS4_EN(ENCLKOS4_EN),
                                                                                .ENCLKOS5_EN(ENCLKOS5_EN),
                                                                                .FRAC_N_EN(FRAC_N_EN),
                                                                                .SS_EN(SS_EN),
                                                                                .DYN_PORTS_EN(DYN_PORTS_EN),
                                                                                .PLL_RST(PLL_RST),
                                                                                .LOCK_EN(LOCK_EN),
                                                                                .PLL_LOCK_STICKY(PLL_LOCK_STICKY),
                                                                                .LEGACY_EN(LEGACY_EN),
                                                                                .LMMI_EN(LMMI_EN),
                                                                                .APB_EN(APB_EN),
                                                                                .POWERDOWN_EN(POWERDOWN_EN),
                                                                                .TRIM_EN_P(TRIM_EN_P),
                                                                                .TRIM_EN_S(TRIM_EN_S),
                                                                                .PLL_REFCLK_FROM_PIN(PLL_REFCLK_FROM_PIN),
                                                                                .REF_CLK_IO_TYPE(REF_CLK_IO_TYPE),
                                                                                .CLKOP_TRIM_MODE(CLKOP_TRIM_MODE),
                                                                                .CLKOS_TRIM_MODE(CLKOS_TRIM_MODE),
                                                                                .CLKOP_TRIM(CLKOP_TRIM),
                                                                                .CLKOS_TRIM(CLKOS_TRIM),
                                                                                .FBK_MODE(FBK_MODE),
                                                                                .CLKI_DIVIDER_ACTUAL_STR(CLKI_DIVIDER_ACTUAL_STR),
                                                                                .FBCLK_DIVIDER_ACTUAL_STR(FBCLK_DIVIDER_ACTUAL_STR),
                                                                                .DIVOP_ACTUAL_STR(DIVOP_ACTUAL_STR),
                                                                                .DIVOS_ACTUAL_STR(DIVOS_ACTUAL_STR),
                                                                                .DIVOS2_ACTUAL_STR(DIVOS2_ACTUAL_STR),
                                                                                .DIVOS3_ACTUAL_STR(DIVOS3_ACTUAL_STR),
                                                                                .DIVOS4_ACTUAL_STR(DIVOS4_ACTUAL_STR),
                                                                                .DIVOS5_ACTUAL_STR(DIVOS5_ACTUAL_STR),
                                                                                .SSC_N_CODE_STR(SSC_N_CODE_STR),
                                                                                .SSC_F_CODE_STR(SSC_F_CODE_STR),
                                                                                .SSC_PROFILE(SSC_PROFILE),
                                                                                .SSC_TBASE_STR(SSC_TBASE_STR),
                                                                                .SSC_STEP_IN_STR(SSC_STEP_IN_STR),
                                                                                .SSC_REG_WEIGHTING_SEL_STR(SSC_REG_WEIGHTING_SEL_STR),
                                                                                .DELA(DELA),
                                                                                .DELB(DELB),
                                                                                .DELC(DELC),
                                                                                .DELD(DELD),
                                                                                .DELE(DELE),
                                                                                .DELF(DELF),
                                                                                .PHIA(PHIA),
                                                                                .PHIB(PHIB),
                                                                                .PHIC(PHIC),
                                                                                .PHID(PHID),
                                                                                .PHIE(PHIE),
                                                                                .PHIF(PHIF),
                                                                                .IPI_CMP(IPI_CMP),
                                                                                .CSET(CSET),
                                                                                .CRIPPLE(CRIPPLE),
                                                                                .IPP_CTRL(IPP_CTRL),
                                                                                .IPP_SEL(IPP_SEL),
                                                                                .BW_CTL_BIAS(BW_CTL_BIAS),
                                                                                .V2I_PP_RES(V2I_PP_RES),
                                                                                .KP_VCO(KP_VCO),
                                                                                .V2I_KVCO_SEL(V2I_KVCO_SEL),
                                                                                .V2I_1V_EN(V2I_1V_EN),
                                                                                .REF_COUNTS(REF_COUNTS),
                                                                                .INTFBKDEL_SEL(INTFBKDEL_SEL),
                                                                                .PMU_WAITFORLOCK(PMU_WAITFORLOCK),
                                                                                .EN_REFCLK_MON(EN_REFCLK_MON),
                                                                                .REF_OSC_CTRL(REF_OSC_CTRL),
                                                                                .SIM_FLOAT_PRECISION(SIM_FLOAT_PRECISION)) lscc_gddrx2_4_5_tx_eclk_centered_dynamic_tri_state_control_pll (.data_coarse_dly_i(data_coarse_dly_i), 
                                                                                .clk_coarse_dly_i(clk_coarse_dly_i), 
                                                                                .data_move_i(data_move_i), 
                                                                                .clk_move_i(clk_move_i), 
                                                                                .data_loadn_i(data_loadn_i), 
                                                                                .clk_loadn_i(clk_loadn_i), 
                                                                                .data_direction_i(data_direction_i), 
                                                                                .clk_direction_i(clk_direction_i), 
                                                                                .data_cflag_o(data_cflag_o), 
                                                                                .clk_cflag_o(clk_cflag_o), 
                                                                                .data_i(data_i), 
                                                                                .sync_clk_i(sync_clk_i), 
                                                                                .sync_rst_i(sync_rst_i), 
                                                                                .ready_o(ready_o), 
                                                                                .outen_n_i(outen_n_i), 
                                                                                .data_o(data_o), 
                                                                                .clk_o(clk_o), 
                                                                                .sclk_o(sclk_o), 
                                                                                .pll_clki_i(pll_clki_i), 
                                                                                .pll_rstn_i(pll_rstn_i), 
                                                                                .lmmi_clk_i(lmmi_clk_i), 
                                                                                .lmmi_resetn_i(lmmi_resetn_i), 
                                                                                .lmmi_request_i(lmmi_request_i), 
                                                                                .lmmi_wr_rdn_i(lmmi_wr_rdn_i), 
                                                                                .lmmi_offset_i(lmmi_offset_i), 
                                                                                .lmmi_wdata_i(lmmi_wdata_i), 
                                                                                .lmmi_ready_o(lmmi_ready_o), 
                                                                                .lmmi_rdata_valid_o(lmmi_rdata_valid_o), 
                                                                                .lmmi_rdata_o(lmmi_rdata_o), 
                                                                                .apb_pclk_i(apb_pclk_i), 
                                                                                .apb_preset_n_i(apb_preset_n_i), 
                                                                                .apb_penable_i(apb_penable_i), 
                                                                                .apb_psel_i(apb_psel_i), 
                                                                                .apb_pwrite_i(apb_pwrite_i), 
                                                                                .apb_paddr_i(apb_paddr_i), 
                                                                                .apb_pwdata_i(apb_pwdata_i), 
                                                                                .apb_pready_o(apb_pready_o), 
                                                                                .apb_pslverr_o(apb_pslverr_o), 
                                                                                .apb_prdata_o(apb_prdata_o)) ; 
                                                                                end
                                                                                else
                                                                                if ((((((((INTERFACE_TYPE == "TRANSMIT") && (CLOCK_DATA_RELATION == "ALIGNED")) && (DATA_PATH_DELAY != "DYNAMIC")) && (CLOCK_PATH_DELAY != "DYNAMIC")) && (INCLUDE_GDDR_SYNC == 1)) && (TRISTATE_EN == 0)) && (GEARING > 1))) 
                                                                                begin : TX_ECLK_ALIGNED_STATIC_BYPASS
                                                                                ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_aligned_static_bypass #(.IO_TYPE(IO_TYPE),
                                                                                .GEARING(GEARING),
                                                                                .BUS_WIDTH(BUS_WIDTH),
                                                                                .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                                                .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                                                .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                                                .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddrx2_4_5_tx_eclk_aligned_static_bypass (.clk_i(clk_i), 
                                                                                .data_i(data_i), 
                                                                                .data_o(data_o), 
                                                                                .sclk_o(sclk_o), 
                                                                                .clk_o(clk_o), 
                                                                                .sync_rst_i(sync_rst_i), 
                                                                                .sync_clk_i(sync_clk_i), 
                                                                                .sync_start_i(sync_start_i), 
                                                                                .ready_o(ready_o)) ; 
                                                                                end
                                                                                else
                                                                                if ((((((((INTERFACE_TYPE == "TRANSMIT") && (CLOCK_DATA_RELATION == "ALIGNED")) && (DATA_PATH_DELAY == "DYNAMIC")) && (CLOCK_PATH_DELAY == "DYNAMIC")) && (INCLUDE_GDDR_SYNC == 0)) && (TRISTATE_EN == 1)) && (GEARING > 1))) 
                                                                                begin : TX_ECLK_ALIGNED_DYNAMIC
                                                                                ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_aligned_dynamic #(.IO_TYPE(IO_TYPE),
                                                                                .GEARING(GEARING),
                                                                                .BUS_WIDTH(BUS_WIDTH),
                                                                                .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                                                .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                                                .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                                                .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddrx2_4_5_tx_eclk_aligned_dynamic (.clk_i(clk_i), 
                                                                                .data_i(data_i), 
                                                                                .outen_n_i(outen_n_i), 
                                                                                .data_o(data_o), 
                                                                                .sclk_o(sclk_o), 
                                                                                .clk_o(clk_o), 
                                                                                .rst_i(rst_i), 
                                                                                .data_move_i(data_move_i), 
                                                                                .data_direction_i(data_direction_i), 
                                                                                .data_loadn_i(data_loadn_i), 
                                                                                .data_coarse_dly_i(data_coarse_dly_i), 
                                                                                .data_cflag_o(data_cflag_o), 
                                                                                .clk_move_i(clk_move_i), 
                                                                                .clk_direction_i(clk_direction_i), 
                                                                                .clk_loadn_i(clk_loadn_i), 
                                                                                .clk_coarse_dly_i(clk_coarse_dly_i), 
                                                                                .clk_cflag_o(clk_cflag_o)) ; 
                                                                                end
                                                                                else
                                                                                if ((((((((INTERFACE_TYPE == "TRANSMIT") && (CLOCK_DATA_RELATION == "ALIGNED")) && (DATA_PATH_DELAY != "DYNAMIC")) && (CLOCK_PATH_DELAY != "DYNAMIC")) && (TRISTATE_EN == 1)) && (INCLUDE_GDDR_SYNC == 0)) && (GEARING > 1))) 
                                                                                begin : TX_ECLK_ALIGNED_STATIC_BYPASS_TRI_STATE_CONTROL
                                                                                ddr_rx_ipgen_lscc_gddrx2_4_5_tx_eclk_aligned_static_bypass_tri_state_control #(.IO_TYPE(IO_TYPE),
                                                                                .GEARING(GEARING),
                                                                                .BUS_WIDTH(BUS_WIDTH),
                                                                                .DATA_PATH_DELAY(DATA_PATH_DELAY),
                                                                                .DATA_DELAY_ADJUSTMENT(DATA_DELAY_ADJUSTMENT),
                                                                                .DATA_FINE_DELAY_VALUE(DATA_FINE_DELAY_VALUE),
                                                                                .DATA_COARSE_DELAY_VALUE(DATA_COARSE_DELAY_VALUE)) u_lscc_gddrx2_4_5_tx_eclk_aligned_static_bypass_tri_state_control (.clk_i(clk_i), 
                                                                                .data_i(data_i), 
                                                                                .data_o(data_o), 
                                                                                .sclk_o(sclk_o), 
                                                                                .clk_o(clk_o), 
                                                                                .rst_i(rst_i), 
                                                                                .outen_n_i(outen_n_i)) ; 
                                                                                end
    endgenerate

// 4Nu
endmodule


