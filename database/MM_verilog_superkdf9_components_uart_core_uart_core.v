// This program was cloned from: https://github.com/Canaan-Creative/MM
// License: The Unlicense

//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED 
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.  
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user’s design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// File         : uart_core.v
// Title        : UART Component -- Top level
// Code type    : Register Transfer Level
// Dependencies : 
// Description:   TOP verilog file for the UART design
//
//    <Global reset and clock>
//      RESET     : Master reset
//      CLK       : Master clock
//
//    <wishbone interface >
//      UART_ADR_I     : Address bus
//      UART_DAT_I     : Data bus input
//      UART_DAT_O     : Data but output
//      UART_STB_I     : strobe output, used to indicate a valid data transfer cycle
//      UART_CYC_I     : cycle signal, indicate whether a valid bus cycle is in process 
//      UART_WE_I      : write enable output, used to indicate whether the current cycle is a READ or Write
//      UART_SEL_I     : output array select signal, used to indicate where valid data is expected
//      UART_ACK_O     : acknowledge, indicate the nomal termination of a bus cycle
//      INTR           : Interrupt
//      UART_CTI_I     : cycle type identifier, 
//      UART_BTE_I     : burst type extension
//    <Receiver interface>
//      SIN    : Receiver serial input
//      RXRDY_N : Receiver ready, low active when RBR data is available
//
//    <Transmitter interface>
//      SOUT   : Transmitter serial output
//      TXRDY_N : Transmitter ready, low active when THR is empty
//
//    <Modem interface>
//      DCD_N   : Data Carrier Detect
//      CTS_N   : Clear To Send
//      DSR_N   : Data Set Ready
//      RI_N    : Ring Indicator
//      DTR_N   : Data Terminal Ready
//      RTS_N   : Request To Send
//
// =============================================================================
//                        REVISION HISTORY
// Version      : 1.0
// Changes Made : Initial Creation
//
// Version      : 7.0SP2
// Changes Made : No Change
//
// Version      : 7.1, 3.0
// Changes Made : Use CPU clock for the MSR update
//
// Version      : 3.1
// Changes Made : Baudrate Generation is modified. RX and TX path of the UART is 
//                updated to faster clock. 16-entry deep FIFO is implemented 
//                when FIFO option is selected
//
// Version      : 3.2
// Changes Made : UART driver is modified for TX/RX FIFO for FIFO mode of UART.
//
// Version      : 3.3
// Changes Made : UART optionally gives two additional output ports (RXRDY_N and
//                TXRDY_N) when defined in the UART GUI.
//
// Version      : 3.4
// Changes Made : Added support to print characters transmitted by UART when 
//                doing functional RTL simulation
//
// Version      : 3.5
// Changes Made : WISHBONE Address Bus is 3 bits and Data Bus is 8 bits or 32 
//                bits. All UART registers occupy a byte instead of 4 bytes 
//                (i.e. registers are accessible using 3 bits only instead 
//                of original 5 bits). UART LCR register has default value 
//                (8'b0000_0011).
//
// Version      : 3.6
// Changes Made : Add support for MICO 8
//
// Version      : 3.7
// Changes Made : Bug fixed for the TX FIFO cannot accept new data if TX FIFO is 
//                not empty. New FIFO supports Transmitter Hold Register Ready bit 
//                instead of Tranmitter Hold Register Empty bit.
// 
// Version      : 3.8
// Changes Made : Removed unused signal sel_i
// =============================================================================

`ifndef UART_CORE_FILE
`define UART_CORE_FILE
`include "system_conf.v"
`include "intface.v"
`include "rxcver.v"
`include "txmitt.v"
`ifdef MODEM
  `include "modem.v"
`endif
module uart_core
  #(parameter CLK_IN_MHZ = 25,
    parameter UART_WB_ADR_WIDTH = 4,
    parameter UART_WB_DAT_WIDTH = 8,
    parameter BAUD_RATE = 115200,
    parameter FIFO = 0,
    parameter LCR_DATA_BITS = 8,
    parameter LCR_STOP_BITS = 1,
    parameter LCR_PARITY_ENABLE = 0,
    parameter LCR_PARITY_ODD = 0,
    parameter LCR_PARITY_STICK = 0,
    parameter LCR_SET_BREAK = 0,
    parameter STDOUT_SIM = 0,
    parameter STDOUT_SIMFAST = 0
    )
   (
    // system clock and reset
    input RESET,
    input CLK,
    
    // wishbone interface signals
    input UART_CYC_I,
    input UART_STB_I,
    input UART_WE_I,
    input UART_LOCK_I,
    input [2:0] UART_CTI_I,
    input [1:0] UART_BTE_I,
    input [UART_WB_ADR_WIDTH-1:0] UART_ADR_I,
    input [UART_WB_DAT_WIDTH-1:0] UART_DAT_I,
    input [UART_WB_DAT_WIDTH/8-1:0] UART_SEL_I,
    output UART_ACK_O,
    output UART_RTY_O,
    output UART_ERR_O,
    output [UART_WB_DAT_WIDTH-1:0] UART_DAT_O,
    
    output INTR,
    
    // Receiver interface
    input SIN,
`ifdef RXRDY_ENABLE
    output RXRDY_N,
`endif
   
    // Modem interface
`ifdef MODEM
    input DCD_N,
    input CTS_N,
    input DSR_N,
    input RI_N,
    output DTR_N,
    output RTS_N,
`endif
   
    // Transmitter interface
`ifdef TXRDY_ENABLE
    output TXRDY_N,
`endif
    output SOUT     
    );

`ifdef MODEM          
   wire [UART_WB_DAT_WIDTH-1:0] MSR;
   wire [1:0] 		   MCR;  
`endif
   
`ifndef RXRDY_ENABLE 
   wire 		   RXRDY_N;
`endif
`ifndef TXRDY_ENABLE
   wire 		   TXRDY_N;
`endif
   
   wire [UART_WB_DAT_WIDTH-1:0] RBR_FIFO;
   wire [UART_WB_DAT_WIDTH-1:0] RBR;
   wire [UART_WB_DAT_WIDTH-1:0] THR;
   wire [1:0] 		   databits;
   wire [1:0] 		   stopbits;
   wire 		   parity_en;
   wire 		   parity_stick;
   wire 		   tx_break;
   wire 		   thr_wr;
   wire 		   rbr_rd;
   wire 		   lsr_rd;
   wire 		   rx_rdy;
   wire 		   parity_err;
   wire 		   frame_err;
   wire 		   overrun_err;
   wire 		   break_int;
   wire 		   THRR;
   wire 		   TEMT; 
   
   wire 		   fifo_empty;
   wire 		   fifo_empty_thr;
   wire			   fifo_full_thr;
   wire 		   thr_rd;
   wire 		   fifo_almost_full;
   
   wire [15:0] 		   divisor;

   assign               UART_RTY_O = 1'b0;
   assign               UART_ERR_O = 1'b0;
   
   intface  #(.CLK_IN_MHZ(CLK_IN_MHZ),
              .BAUD_RATE(BAUD_RATE),
              .UART_WB_ADR_WIDTH(UART_WB_ADR_WIDTH),
              .UART_WB_DAT_WIDTH(UART_WB_DAT_WIDTH),
              .FIFO(FIFO),
	      .LCR_DATA_BITS(LCR_DATA_BITS),
	      .LCR_STOP_BITS(LCR_STOP_BITS),
	      .LCR_PARITY_ENABLE(LCR_PARITY_ENABLE),
	      .LCR_PARITY_ODD(LCR_PARITY_ODD),
	      .LCR_PARITY_STICK(LCR_PARITY_STICK),
	      .LCR_SET_BREAK(LCR_SET_BREAK),
	      .STDOUT_SIM(STDOUT_SIM),
	      .STDOUT_SIMFAST(STDOUT_SIMFAST)) 
   u_intface (
              .reset            (RESET       ),
              .clk              (CLK         ),
              .adr_i            (UART_ADR_I  ),
              .dat_i            (UART_DAT_I  ),
              .dat_o            (UART_DAT_O  ),
              .stb_i            (UART_STB_I  ),
              .cyc_i            (UART_CYC_I  ),
              .we_i             (UART_WE_I   ),
              .cti_i            (UART_CTI_I  ),
              .bte_i            (UART_BTE_I  ),
              .ack_o            (UART_ACK_O  ),
              .intr             (intr        ),
              .rbr              (RBR         ),
	      .rbr_fifo         (RBR_FIFO    ),
              .thr              (THR         ),
              .rbr_rd           (rbr_rd      ),
              .thr_wr           (thr_wr      ),
              .lsr_rd           (lsr_rd      ),
 `ifdef MODEM
              .msr_rd           (msr_rd      ),
              .msr              (MSR         ),
              .mcr              (MCR         ),
 `endif
              .databits         (databits    ),
              .stopbits         (stopbits    ),
              .parity_en        (parity_en   ),
              .parity_even      (parity_even ),
              .parity_stick     (parity_stick),
              .tx_break         (tx_break    ),
              .rx_rdy           (rx_rdy      ),
              .overrun_err      (overrun_err ),
              .parity_err       (parity_err  ),
              .frame_err        (frame_err   ),
              .break_int        (break_int   ),
              .thrr             (THRR        ),
              .temt             (TEMT        ),
	      .fifo_empty       (fifo_empty  ),
	      .fifo_empty_thr   (fifo_empty_thr),
		  .fifo_full_thr    (fifo_full_thr),
	      .thr_rd           (thr_rd),
	      .fifo_almost_full (fifo_almost_full),
	      .divisor          (divisor)
	      );
   
   rxcver #(.UART_WB_DAT_WIDTH(UART_WB_DAT_WIDTH),
            .FIFO(FIFO)) 
   u_rxcver (
             .reset            (RESET         ),
             .clk              (CLK          ),
             .rbr              (RBR           ),
	     .rbr_fifo         (RBR_FIFO      ),
             .rbr_rd           (rbr_rd        ),
             .lsr_rd           (lsr_rd        ),
             .sin              (SIN           ),
             .databits         (databits      ),   
             .parity_en        (parity_en     ),
             .parity_even      (parity_even   ),
             .parity_stick     (parity_stick  ),
             .rx_rdy           (rx_rdy        ),
             .overrun_err      (overrun_err   ),
             .parity_err       (parity_err    ),
             .frame_err        (frame_err     ),
             .break_int        (break_int     ),
	     .fifo_empty       (fifo_empty    ),
	     .fifo_almost_full (fifo_almost_full),
	     .divisor          (divisor       )
	     ); 
   
   txmitt #(.UART_WB_DAT_WIDTH(UART_WB_DAT_WIDTH),
            .FIFO(FIFO))
   u_txmitt (
	     .reset          (RESET         ),
	     .clk            (CLK           ),
	     .thr            (THR           ),
	     .thr_wr         (thr_wr        ),
	     .sout           (sout          ),
	     .databits       (databits      ),
	     .stopbits       (stopbits      ),
	     .parity_en      (parity_en     ),
	     .parity_even    (parity_even   ),
	     .parity_stick   (parity_stick  ),
	     .tx_break       (tx_break      ),
	     .thrr           (THRR          ),
	     .temt           (TEMT          ),
	     .fifo_empty_thr (fifo_empty_thr),
		 .fifo_full_thr  (fifo_full_thr),
	     .thr_rd         (thr_rd),
	     .divisor        (divisor)
	     );
   
`ifdef MODEM
   modem 
     #(.UART_WB_DAT_WIDTH(UART_WB_DAT_WIDTH))
   u_modem (
            .reset        (RESET         ), 
            .clk          (CLK           ), 
            .msr          (MSR           ), 
            .mcr          (MCR           ),
            .msr_rd       (msr_rd        ), 
            .dcd_n        (DCD_N         ), 
            .cts_n        (CTS_N         ), 
            .dsr_n        (DSR_N         ), 
            .ri_n         (RI_N          ), 
            .dtr_n        (dtr_n         ), 
            .rts_n        (rts_n         )  
	    );
`endif
   
   // TXRDY_N, RXRDY_N is low active output
   assign #5 TXRDY_N = ~THRR;
   assign #5 RXRDY_N = ~rx_rdy; 
   assign #5 INTR    = intr;
   assign #5 SOUT    = sout;
`ifdef MODEM
   assign #5 DTR_N   = dtr_n;
   assign #5 RTS_N   = rts_n;
`endif 
endmodule
`endif // UART_CORE_FILE
