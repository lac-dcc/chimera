// This program was cloned from: https://github.com/buncram/cram-soc
// License: CERN Open Hardware Licence Version 2 - Weakly Reciprocal

//------------------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- RobustVerilog version 1.2 (limited free version)
//-- Invoked Mon Feb 06 01:29:27 2023
//-- Source file: axi2ahb_wr_fifo.v
//-- Parent file: axi2ahb.v
//-- Run directory: F:/largework/rust-win/code/robust_axi2ahb/
//-- Target directory: out/
//-- Command flags: .\src\base\axi2ahb.v -od out -I .\src\gen\ -list list.txt -listpath -header
//-- www.provartec.com/edatools ... info@provartec.com
//------------------------------------------------------------------





module axi2ahb_wr_fifo (clk,
                        reset,
                        WID,
                        WDATA,
                        WSTRB,
                        WLAST,
                        WVALID,
                        WREADY,
                        BID,
                        BRESP,
                        BVALID,
                        BREADY,
                        HWDATA,
                        HREADY,
                        HTRANS,
                        HRESP,
                        cmd_err,
                        wdata_phase,
                        wdata_ready,
                        data_last);

    parameter              FIFO_LINES  = 32; //double buffer of max burst
    parameter              RESP_SLVERR = 2'b10;

    input                  clk;
    input                  reset;

    input [3:0]            WID;
    input [31:0]           WDATA;
    input [32/8-1:0]       WSTRB;
    input                  WLAST;
    input                  WVALID;
    output                 WREADY;
    output [3:0]           BID;
    output [1:0]           BRESP;
    output                 BVALID;
    input                  BREADY;
    output [32-1:0] HWDATA;
    input                  HREADY;
    input [1:0]            HTRANS;
    input                  HRESP;

    input                  cmd_err;
    input                  wdata_phase;
    output                 wdata_ready;
    input                  data_last;


    wire                   data_push;
    wire                   data_pop;
    wire                   data_empty;
    wire                   data_full;

    wire                   resp_push;
    wire                   resp_pop;
    wire                   resp_empty;
    wire                   resp_full;

    reg [1:0] burst_cnt;
    wire                    burst_full;

    wire                   axi_last;
    wire                   ahb_last;
    wire [1:0]             cmd_resp;

    assign                 cmd_resp = cmd_err | HRESP ? RESP_SLVERR : 2'b00;

    assign                 wdata_ready = burst_cnt > 'd0;

    assign                 WREADY = (~data_full) & (~burst_full);


    assign                 data_push = WVALID & WREADY;
    assign                 data_pop  = wdata_phase & HREADY;

    assign                 axi_last = WVALID & WREADY & WLAST;
    assign                 ahb_last = wdata_phase & data_last;

    assign                 burst_full = burst_cnt == {2{1'b1}};

    always @(posedge clk or posedge reset)
        if (reset)
            burst_cnt <= 'd0;
        else if (axi_last | ahb_last)
            burst_cnt <= burst_cnt + axi_last - ahb_last;

    prgen_fifo #(32, FIFO_LINES)
    data_fifo(
      .clk(clk),
      .reset(reset),
      .push(data_push),
      .pop(data_pop),
      .din({WDATA}),
      .dout({HWDATA}),
      .empty(data_empty),
      .full(data_full)
    );


    assign                 resp_push = ahb_last;
    assign                 resp_pop  = BVALID & BREADY;

    assign                 BVALID = (~resp_empty);

    prgen_fifo #(2+4, 1)
    resp_fifo(
      .clk(clk),
      .reset(reset),
      .push(resp_push),
      .pop(resp_pop),
      .din({cmd_resp,WID}),
      .dout({BRESP,BID}),
      .empty(resp_empty),
      .full(resp_full)
    );



endmodule




