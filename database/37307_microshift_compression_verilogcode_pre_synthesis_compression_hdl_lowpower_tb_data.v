// This program was cloned from: https://github.com/zhangmozhe/microshift_compression
// License: Apache License 2.0

// -------------------------------------------------------------
// 
// File Name: C:\Users\Bo\OneDrive - HKUST Connect\Bit depth compression\FPGA Implementation\Final\temp\codegen\compression_hdl_lowpower\hdlsrc\compression_hdl_lowpower_tb_data.v
// Created: 2018-07-17 11:59:52
// 
// Generated by MATLAB 9.1, MATLAB Coder 3.2 and HDL Coder 3.9
// 
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: compression_hdl_lowpower_tb_data
// Source Path: 
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module compression_hdl_lowpower_tb_data
          (
           clk,
           resetx,
           pixelIn_addr,
           hStart_addr,
           hEnd_addr,
           vStart_addr,
           vEnd_addr,
           valid_addr,
           mode_addr,
           bitstreamready_addr,
           bitstreamlengt_addr,
           subimageindexo_addr,
           bitstreamoutpu_addr,
           hstartoutput_addr,
           hendoutput_addr,
           vstartoutput_addr,
           vendoutput_addr,
           validoutput_addr,
           tb_enb_delay,
           rdEnb,
           ceout,
           pixelin,
           hstart,
           hend,
           vstart,
           vend,
           valid,
           mode,
           bitstreamready_expected,
           bitstreamlengt_expected,
           subimageindexo_expected,
           bitstreamoutpu_expected,
           hstartoutput_expected,
           hendoutput_expected,
           vstartoutput_expected,
           vendoutput_expected,
           validoutput_expected
          );



  input   clk;
  input   resetx;
  input   [15:0] pixelIn_addr;  // ufix16
  input   [15:0] hStart_addr;  // ufix16
  input   [15:0] hEnd_addr;  // ufix16
  input   [15:0] vStart_addr;  // ufix16
  input   [15:0] vEnd_addr;  // ufix16
  input   [15:0] valid_addr;  // ufix16
  input   [15:0] mode_addr;  // ufix16
  input   [15:0] bitstreamready_addr;  // ufix16
  input   [15:0] bitstreamlengt_addr;  // ufix16
  input   [15:0] subimageindexo_addr;  // ufix16
  input   [15:0] bitstreamoutpu_addr;  // ufix16
  input   [15:0] hstartoutput_addr;  // ufix16
  input   [15:0] hendoutput_addr;  // ufix16
  input   [15:0] vstartoutput_addr;  // ufix16
  input   [15:0] vendoutput_addr;  // ufix16
  input   [15:0] validoutput_addr;  // ufix16
  input   tb_enb_delay;
  input   rdEnb;
  input   ceout;
  output  [7:0] pixelin;  // uint8
  output  hstart;
  output  hend;
  output  vstart;
  output  vend;
  output  valid;
  output  [1:0] mode;  // ufix2
  output  bitstreamready_expected;
  output  [3:0] bitstreamlengt_expected;  // ufix4
  output  [3:0] subimageindexo_expected;  // ufix4
  output  [9:0] bitstreamoutpu_expected;  // ufix10
  output  hstartoutput_expected;
  output  hendoutput_expected;
  output  vstartoutput_expected;
  output  vendoutput_expected;
  output  validoutput_expected;

  reg signed [31:0] fp_pixelin;  // sfix32
  reg [7:0] pixelinraw;  // uint8
  reg signed [31:0] status_pixelin;  // sfix32
  wire [7:0] rawData_pixelin;  // uint8
  reg [7:0] holdData_pixelin;  // uint8
  reg [7:0] pixelin_offset;  // uint8
  reg signed [31:0] fp_hstart;  // sfix32
  reg  hstartraw;
  reg signed [31:0] status_hstart;  // sfix32
  wire rawData_hstart;
  reg  holdData_hstart;
  reg  hstart_offset;
  reg signed [31:0] fp_hend;  // sfix32
  reg  hendraw;
  reg signed [31:0] status_hend;  // sfix32
  wire rawData_hend;
  reg  holdData_hend;
  reg  hend_offset;
  reg signed [31:0] fp_vstart;  // sfix32
  reg  vstartraw;
  reg signed [31:0] status_vstart;  // sfix32
  wire rawData_vstart;
  reg  holdData_vstart;
  reg  vstart_offset;
  reg signed [31:0] fp_vend;  // sfix32
  reg  vendraw;
  reg signed [31:0] status_vend;  // sfix32
  wire rawData_vend;
  reg  holdData_vend;
  reg  vend_offset;
  reg signed [31:0] fp_valid;  // sfix32
  reg  validraw;
  reg signed [31:0] status_valid;  // sfix32
  wire rawData_valid;
  reg  holdData_valid;
  reg  valid_offset;
  reg signed [31:0] fp_mode;  // sfix32
  reg [1:0] moderaw;  // ufix2
  reg signed [31:0] status_mode;  // sfix32
  wire [1:0] rawData_mode;  // ufix2
  reg [1:0] holdData_mode;  // ufix2
  reg [1:0] mode_offset;  // ufix2
  reg signed [31:0] fp_bitstreamready_expected;  // sfix32
  reg  bitstreamready_expected_1;
  reg signed [31:0] status_bitstreamready_expected;  // sfix32
  reg signed [31:0] fp_bitstreamlengt_expected;  // sfix32
  reg [3:0] bitstreamlengt_expected_1;  // ufix4
  reg signed [31:0] status_bitstreamlengt_expected;  // sfix32
  reg signed [31:0] fp_subimageindexo_expected;  // sfix32
  reg [3:0] subimageindexo_expected_1;  // ufix4
  reg signed [31:0] status_subimageindexo_expected;  // sfix32
  reg signed [31:0] fp_bitstreamoutpu_expected;  // sfix32
  reg [9:0] bitstreamoutpu_expected_1;  // ufix10
  reg signed [31:0] status_bitstreamoutpu_expected;  // sfix32
  reg signed [31:0] fp_hstartoutput_expected;  // sfix32
  reg  hstartoutput_expected_1;
  reg signed [31:0] status_hstartoutput_expected;  // sfix32
  reg signed [31:0] fp_hendoutput_expected;  // sfix32
  reg  hendoutput_expected_1;
  reg signed [31:0] status_hendoutput_expected;  // sfix32
  reg signed [31:0] fp_vstartoutput_expected;  // sfix32
  reg  vstartoutput_expected_1;
  reg signed [31:0] status_vstartoutput_expected;  // sfix32
  reg signed [31:0] fp_vendoutput_expected;  // sfix32
  reg  vendoutput_expected_1;
  reg signed [31:0] status_vendoutput_expected;  // sfix32
  reg signed [31:0] fp_validoutput_expected;  // sfix32
  reg  validoutput_expected_1;
  reg signed [31:0] status_validoutput_expected;  // sfix32


  // Data source for pixelin
  initial
    begin : pixelin_fileread
      fp_pixelin = $fopen("pixelin.dat", "r");
      status_pixelin = $rewind(fp_pixelin);
    end

  always @(pixelIn_addr, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        pixelinraw <= 0;
      end
      else if (rdEnb == 1) begin
        status_pixelin = $fscanf(fp_pixelin, "%h", pixelinraw);
      end
    end

  assign rawData_pixelin = (rdEnb == 1'b0 ? 8'b00000000 :
              pixelinraw);



  // holdData reg for pixelIn
  always @(posedge clk or negedge resetx)
    begin : stimuli_pixelIn
      if (!resetx) begin
        holdData_pixelin <= 0;
      end
      else begin
        holdData_pixelin <= rawData_pixelin;
      end
    end

  always @(rawData_pixelin or rdEnb or tb_enb_delay)
    begin : stimuli_pixelIn_1
      if (tb_enb_delay == 1'b0) begin
        pixelin_offset <= 8'b0;
      end
      else begin
        if (rdEnb == 1'b0) begin
          pixelin_offset <= holdData_pixelin;
        end
        else begin
          pixelin_offset <= rawData_pixelin;
        end
      end
    end

  assign #2 pixelin = pixelin_offset;

  // Data source for hstart
  initial
    begin : hstart_fileread
      fp_hstart = $fopen("hstart.dat", "r");
      status_hstart = $rewind(fp_hstart);
    end

  always @(hStart_addr, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        hstartraw <= 0;
      end
      else if (rdEnb == 1) begin
        status_hstart = $fscanf(fp_hstart, "%h", hstartraw);
      end
    end

  assign rawData_hstart = (rdEnb == 1'b0 ? 1'b0 :
              hstartraw);



  // holdData reg for hStart
  always @(posedge clk or negedge resetx)
    begin : stimuli_hStart
      if (!resetx) begin
        holdData_hstart <= 0;
      end
      else begin
        holdData_hstart <= rawData_hstart;
      end
    end

  always @(rawData_hstart or rdEnb or tb_enb_delay)
    begin : stimuli_hStart_1
      if (tb_enb_delay == 1'b0) begin
        hstart_offset <= 1'b0;
      end
      else begin
        if (rdEnb == 1'b0) begin
          hstart_offset <= holdData_hstart;
        end
        else begin
          hstart_offset <= rawData_hstart;
        end
      end
    end

  assign #2 hstart = hstart_offset;

  // Data source for hend
  initial
    begin : hend_fileread
      fp_hend = $fopen("hend.dat", "r");
      status_hend = $rewind(fp_hend);
    end

  always @(hEnd_addr, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        hendraw <= 0;
      end
      else if (rdEnb == 1) begin
        status_hend = $fscanf(fp_hend, "%h", hendraw);
      end
    end

  assign rawData_hend = (rdEnb == 1'b0 ? 1'b0 :
              hendraw);



  // holdData reg for hEnd
  always @(posedge clk or negedge resetx)
    begin : stimuli_hEnd
      if (!resetx) begin
        holdData_hend <= 0;
      end
      else begin
        holdData_hend <= rawData_hend;
      end
    end

  always @(rawData_hend or rdEnb or tb_enb_delay)
    begin : stimuli_hEnd_1
      if (tb_enb_delay == 1'b0) begin
        hend_offset <= 1'b0;
      end
      else begin
        if (rdEnb == 1'b0) begin
          hend_offset <= holdData_hend;
        end
        else begin
          hend_offset <= rawData_hend;
        end
      end
    end

  assign #2 hend = hend_offset;

  // Data source for vstart
  initial
    begin : vstart_fileread
      fp_vstart = $fopen("vstart.dat", "r");
      status_vstart = $rewind(fp_vstart);
    end

  always @(vStart_addr, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        vstartraw <= 0;
      end
      else if (rdEnb == 1) begin
        status_vstart = $fscanf(fp_vstart, "%h", vstartraw);
      end
    end

  assign rawData_vstart = (rdEnb == 1'b0 ? 1'b0 :
              vstartraw);



  // holdData reg for vStart
  always @(posedge clk or negedge resetx)
    begin : stimuli_vStart
      if (!resetx) begin
        holdData_vstart <= 0;
      end
      else begin
        holdData_vstart <= rawData_vstart;
      end
    end

  always @(rawData_vstart or rdEnb or tb_enb_delay)
    begin : stimuli_vStart_1
      if (tb_enb_delay == 1'b0) begin
        vstart_offset <= 1'b0;
      end
      else begin
        if (rdEnb == 1'b0) begin
          vstart_offset <= holdData_vstart;
        end
        else begin
          vstart_offset <= rawData_vstart;
        end
      end
    end

  assign #2 vstart = vstart_offset;

  // Data source for vend
  initial
    begin : vend_fileread
      fp_vend = $fopen("vend.dat", "r");
      status_vend = $rewind(fp_vend);
    end

  always @(vEnd_addr, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        vendraw <= 0;
      end
      else if (rdEnb == 1) begin
        status_vend = $fscanf(fp_vend, "%h", vendraw);
      end
    end

  assign rawData_vend = (rdEnb == 1'b0 ? 1'b0 :
              vendraw);



  // holdData reg for vEnd
  always @(posedge clk or negedge resetx)
    begin : stimuli_vEnd
      if (!resetx) begin
        holdData_vend <= 0;
      end
      else begin
        holdData_vend <= rawData_vend;
      end
    end

  always @(rawData_vend or rdEnb or tb_enb_delay)
    begin : stimuli_vEnd_1
      if (tb_enb_delay == 1'b0) begin
        vend_offset <= 1'b0;
      end
      else begin
        if (rdEnb == 1'b0) begin
          vend_offset <= holdData_vend;
        end
        else begin
          vend_offset <= rawData_vend;
        end
      end
    end

  assign #2 vend = vend_offset;

  // Data source for valid
  initial
    begin : valid_fileread
      fp_valid = $fopen("valid.dat", "r");
      status_valid = $rewind(fp_valid);
    end

  always @(valid_addr, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        validraw <= 0;
      end
      else if (rdEnb == 1) begin
        status_valid = $fscanf(fp_valid, "%h", validraw);
      end
    end

  assign rawData_valid = (rdEnb == 1'b0 ? 1'b0 :
              validraw);



  // holdData reg for valid
  always @(posedge clk or negedge resetx)
    begin : stimuli_valid
      if (!resetx) begin
        holdData_valid <= 0;
      end
      else begin
        holdData_valid <= rawData_valid;
      end
    end

  always @(rawData_valid or rdEnb or tb_enb_delay)
    begin : stimuli_valid_1
      if (tb_enb_delay == 1'b0) begin
        valid_offset <= 1'b0;
      end
      else begin
        if (rdEnb == 1'b0) begin
          valid_offset <= holdData_valid;
        end
        else begin
          valid_offset <= rawData_valid;
        end
      end
    end

  assign #2 valid = valid_offset;

  // Data source for mode
  initial
    begin : mode_fileread
      fp_mode = $fopen("mode.dat", "r");
      status_mode = $rewind(fp_mode);
    end

  always @(mode_addr, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        moderaw <= 0;
      end
      else if (rdEnb == 1) begin
        status_mode = $fscanf(fp_mode, "%h", moderaw);
      end
    end

  assign rawData_mode = (rdEnb == 1'b0 ? 2'b00 :
              moderaw);



  // holdData reg for mode
  always @(posedge clk or negedge resetx)
    begin : stimuli_mode
      if (!resetx) begin
        holdData_mode <= 0;
      end
      else begin
        holdData_mode <= rawData_mode;
      end
    end

  always @(rawData_mode or rdEnb or tb_enb_delay)
    begin : stimuli_mode_1
      if (tb_enb_delay == 1'b0) begin
        mode_offset <= 2'b0;
      end
      else begin
        if (rdEnb == 1'b0) begin
          mode_offset <= holdData_mode;
        end
        else begin
          mode_offset <= rawData_mode;
        end
      end
    end

  assign #2 mode = mode_offset;

  // Data source for bitstreamready_expected
  initial
    begin : bitstreamready_expected_fileread
      fp_bitstreamready_expected = $fopen("bitstreamready_expected.dat", "r");
      status_bitstreamready_expected = $rewind(fp_bitstreamready_expected);
    end

  always @(bitstreamready_addr, ceout, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        bitstreamready_expected_1 <= 0;
      end
      else if (ceout == 1) begin
        status_bitstreamready_expected = $fscanf(fp_bitstreamready_expected, "%h", bitstreamready_expected_1);
      end
    end

  assign bitstreamready_expected = bitstreamready_expected_1;

  // Data source for bitstreamlengt_expected
  initial
    begin : bitstreamlengt_expected_fileread
      fp_bitstreamlengt_expected = $fopen("bitstreamlengt_expected.dat", "r");
      status_bitstreamlengt_expected = $rewind(fp_bitstreamlengt_expected);
    end

  always @(bitstreamlengt_addr, ceout, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        bitstreamlengt_expected_1 <= 0;
      end
      else if (ceout == 1) begin
        status_bitstreamlengt_expected = $fscanf(fp_bitstreamlengt_expected, "%h", bitstreamlengt_expected_1);
      end
    end

  assign bitstreamlengt_expected = bitstreamlengt_expected_1;

  // Data source for subimageindexo_expected
  initial
    begin : subimageindexo_expected_fileread
      fp_subimageindexo_expected = $fopen("subimageindexo_expected.dat", "r");
      status_subimageindexo_expected = $rewind(fp_subimageindexo_expected);
    end

  always @(subimageindexo_addr, ceout, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        subimageindexo_expected_1 <= 0;
      end
      else if (ceout == 1) begin
        status_subimageindexo_expected = $fscanf(fp_subimageindexo_expected, "%h", subimageindexo_expected_1);
      end
    end

  assign subimageindexo_expected = subimageindexo_expected_1;

  // Data source for bitstreamoutpu_expected
  initial
    begin : bitstreamoutpu_expected_fileread
      fp_bitstreamoutpu_expected = $fopen("bitstreamoutpu_expected.dat", "r");
      status_bitstreamoutpu_expected = $rewind(fp_bitstreamoutpu_expected);
    end

  always @(bitstreamoutpu_addr, ceout, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        bitstreamoutpu_expected_1 <= 0;
      end
      else if (ceout == 1) begin
        status_bitstreamoutpu_expected = $fscanf(fp_bitstreamoutpu_expected, "%h", bitstreamoutpu_expected_1);
      end
    end

  assign bitstreamoutpu_expected = bitstreamoutpu_expected_1;

  // Data source for hstartoutput_expected
  initial
    begin : hstartoutput_expected_fileread
      fp_hstartoutput_expected = $fopen("hstartoutput_expected.dat", "r");
      status_hstartoutput_expected = $rewind(fp_hstartoutput_expected);
    end

  always @(hstartoutput_addr, ceout, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        hstartoutput_expected_1 <= 0;
      end
      else if (ceout == 1) begin
        status_hstartoutput_expected = $fscanf(fp_hstartoutput_expected, "%h", hstartoutput_expected_1);
      end
    end

  assign hstartoutput_expected = hstartoutput_expected_1;

  // Data source for hendoutput_expected
  initial
    begin : hendoutput_expected_fileread
      fp_hendoutput_expected = $fopen("hendoutput_expected.dat", "r");
      status_hendoutput_expected = $rewind(fp_hendoutput_expected);
    end

  always @(hendoutput_addr, ceout, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        hendoutput_expected_1 <= 0;
      end
      else if (ceout == 1) begin
        status_hendoutput_expected = $fscanf(fp_hendoutput_expected, "%h", hendoutput_expected_1);
      end
    end

  assign hendoutput_expected = hendoutput_expected_1;

  // Data source for vstartoutput_expected
  initial
    begin : vstartoutput_expected_fileread
      fp_vstartoutput_expected = $fopen("vstartoutput_expected.dat", "r");
      status_vstartoutput_expected = $rewind(fp_vstartoutput_expected);
    end

  always @(vstartoutput_addr, ceout, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        vstartoutput_expected_1 <= 0;
      end
      else if (ceout == 1) begin
        status_vstartoutput_expected = $fscanf(fp_vstartoutput_expected, "%h", vstartoutput_expected_1);
      end
    end

  assign vstartoutput_expected = vstartoutput_expected_1;

  // Data source for vendoutput_expected
  initial
    begin : vendoutput_expected_fileread
      fp_vendoutput_expected = $fopen("vendoutput_expected.dat", "r");
      status_vendoutput_expected = $rewind(fp_vendoutput_expected);
    end

  always @(vendoutput_addr, ceout, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        vendoutput_expected_1 <= 0;
      end
      else if (ceout == 1) begin
        status_vendoutput_expected = $fscanf(fp_vendoutput_expected, "%h", vendoutput_expected_1);
      end
    end

  assign vendoutput_expected = vendoutput_expected_1;

  // Data source for validoutput_expected
  initial
    begin : validoutput_expected_fileread
      fp_validoutput_expected = $fopen("validoutput_expected.dat", "r");
      status_validoutput_expected = $rewind(fp_validoutput_expected);
    end

  always @(validoutput_addr, ceout, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        validoutput_expected_1 <= 0;
      end
      else if (ceout == 1) begin
        status_validoutput_expected = $fscanf(fp_validoutput_expected, "%h", validoutput_expected_1);
      end
    end

  assign validoutput_expected = validoutput_expected_1;

endmodule  // compression_hdl_lowpower_tb_data

