// This program was cloned from: https://github.com/buncram/cram-soc
// License: CERN Open Hardware Licence Version 2 - Weakly Reciprocal

//------------------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- RobustVerilog version 1.2 (limited free version)
//-- Invoked Mon Feb 06 01:29:27 2023
//-- Source file: axi2ahb_ctrl.v
//-- Parent file: axi2ahb.v
//-- Run directory: F:/largework/rust-win/code/robust_axi2ahb/
//-- Target directory: out/
//-- Command flags: .\src\base\axi2ahb.v -od out -I .\src\gen\ -list list.txt -listpath -header
//-- www.provartec.com/edatools ... info@provartec.com
//------------------------------------------------------------------





module axi2ahb_ctrl (clk,
                     reset,
                     HADDR,
                     HBURST,
                     HSIZE,
                     HTRANS,
                     HWRITE,
                     HWDATA,
                     HRDATA,
                     HREADY,
                     HRESP,
                     ahb_finish,
                     rdata_phase,
                     wdata_phase,
                     data_last,
                     rdata_ready,
                     wdata_ready,
                     cmd_empty,
                     cmd_read,
                     cmd_addr,
                     cmd_len,
                     cmd_size);


    input                  clk;
    input                  reset;

    output [23:0]          HADDR;
    output [2:0]           HBURST;
    output [1:0]           HSIZE;
    output [1:0]           HTRANS;
    output                 HWRITE;
    output [31:0]          HWDATA;
    input [31:0]           HRDATA;
    input                  HREADY;
    input                  HRESP;

    output                 ahb_finish;
    output                 rdata_phase;
    output                 wdata_phase;
    output                 data_last;

    input                  rdata_ready;
    input                  wdata_ready;
    input                  cmd_empty;
    input                  cmd_read;
    input [24-1:0]  cmd_addr;
    input [3:0]            cmd_len;
    input [1:0]            cmd_size;

    parameter              TRANS_IDLE   = 2'b00;
    parameter              TRANS_BUSY   = 2'b01;
    parameter              TRANS_NONSEQ = 2'b10;
    parameter              TRANS_SEQ    = 2'b11;

    parameter              BURST_SINGLE = 3'b000;
    parameter              BURST_INCR4  = 3'b011;
    parameter              BURST_INCR8  = 3'b101;
    parameter              BURST_INCR16 = 3'b111;


    wire                   data_ready;
    wire                   ahb_idle;
    wire                   ahb_ack;
    wire                   ahb_ack_last;
    wire                   ahb_start;
    wire                   ahb_last;
    wire                   data_last;
    reg [4:0]              cmd_counter;
    reg                    rdata_phase;
    reg                    wdata_phase;
    wire                   data_phase;
    reg [1:0]              HTRANS;
    reg [2:0]              HBURST;
    reg [1:0]              HSIZE;
    reg                    HWRITE;
    reg [24-1:0]    HADDR;


    assign                 ahb_finish = ahb_ack_last;

    assign                 data_ready = cmd_read ? rdata_ready : wdata_ready;
    assign                 data_phase = wdata_phase | rdata_phase;

    assign                 ahb_idle     = HTRANS == TRANS_IDLE;
    assign                 ahb_ack      = HTRANS[1] & HREADY;
    assign                 ahb_ack_last = ahb_last & ahb_ack;
    assign                 ahb_start    = (~cmd_empty) & data_ready & ahb_idle & (HREADY | (~data_phase));
    assign                 data_last    = HREADY & (ahb_idle || (HTRANS == TRANS_NONSEQ));

    always @(posedge clk or posedge reset)
        if (reset)
            cmd_counter <= 4'd0;
        else if (ahb_ack_last)
            cmd_counter <= 4'd0;
        else if (ahb_ack)
            cmd_counter <= cmd_counter + 1'b1;

    assign             ahb_last = cmd_counter == cmd_len;

    always @(posedge clk or posedge reset)
        if (reset)
            rdata_phase <= 1'b0;
        else if (ahb_ack & (~HWRITE))
            rdata_phase <= 1'b1;
        else if (data_last)
            rdata_phase <= 1'b0;

    always @(posedge clk or posedge reset)
        if (reset)
            wdata_phase <= 1'b0;
        else if (ahb_ack & HWRITE)
            wdata_phase <= 1'b1;
        else if (data_last)
            wdata_phase <= 1'b0;

    always @(posedge clk or posedge reset)
        if (reset)
            HTRANS <= TRANS_IDLE;
        else if (ahb_start)
            HTRANS <= TRANS_NONSEQ;
        else if (ahb_ack_last)
            HTRANS <= TRANS_IDLE;
        else if (ahb_ack)
            HTRANS <= TRANS_SEQ;

    always @(posedge clk or posedge reset)
        if (reset)
            HBURST <= BURST_SINGLE;
        else if (ahb_start & (cmd_len == 4'd0))
            HBURST <= BURST_SINGLE;
        else if (ahb_start & (cmd_len == 4'd3))
            HBURST <= BURST_INCR4;
        else if (ahb_start & (cmd_len == 4'd7))
            HBURST <= BURST_INCR8;
        else if (ahb_start & (cmd_len == 4'd15))
            HBURST <= BURST_INCR16;

    always @(posedge clk or posedge reset)
        if (reset)
            HSIZE <= 2'b00;
        else if (ahb_start)
            HSIZE <= cmd_size;

    always @(posedge clk or posedge reset)
        if (reset)
            HWRITE <= 2'b00;
        else if (ahb_start)
            HWRITE <= (~cmd_read);

    always @(posedge clk or posedge reset)
        if (reset)
            HADDR <= {24{1'b0}};
        else if (ahb_start)
            HADDR <= cmd_addr;
        else if (ahb_ack_last)
            HADDR <= {24{1'b0}};
        else if (ahb_ack)
            HADDR <= HADDR + (
            HSIZE == 2'b00 ? 4'd1 :
            HSIZE == 2'b01 ? 4'd2 :
            HSIZE == 2'b10 ? 4'd4 :
            HSIZE == 2'b11 ? 4'd8 :
            4'd0);


endmodule




